

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.png">
  <link rel="icon" href="/img/avatar.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="求解过程数据预处理首先读取出每个城市的坐标信息，并计算出每两个城市之间的直线距离：
123456789101112def read_array():    data = np.loadtxt(&amp;#x27;data.txt&amp;#x27;)    city_name = data[:, 0]    city_point = data[:, 1:]    city_count = len(city_nam">
  <meta name="author" content="Juhick">
  <meta name="keywords" content="">
  <meta name="description" content="求解过程数据预处理首先读取出每个城市的坐标信息，并计算出每两个城市之间的直线距离： 123456789101112def read_array():    data &#x3D; np.loadtxt(&amp;#x27;data.txt&amp;#x27;)    city_name &#x3D; data[:, 0]    city_point &#x3D; data[:, 1:]    city_count &#x3D; len(city_nam">
<meta property="og:type" content="article">
<meta property="og:title" content="采用遗传算法解决TSP问题">
<meta property="og:url" content="https://blog.qinhaiqi.com/2021/12/08/%E9%87%87%E7%94%A8%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95%E8%A7%A3%E5%86%B3TSP%E9%97%AE%E9%A2%98/index.html">
<meta property="og:site_name" content="曾许人间第一流">
<meta property="og:description" content="求解过程数据预处理首先读取出每个城市的坐标信息，并计算出每两个城市之间的直线距离： 123456789101112def read_array():    data &#x3D; np.loadtxt(&amp;#x27;data.txt&amp;#x27;)    city_name &#x3D; data[:, 0]    city_point &#x3D; data[:, 1:]    city_count &#x3D; len(city_nam">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20211209161208.png">
<meta property="og:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20211209193559.png">
<meta property="article:published_time" content="2021-12-08T13:48:00.000Z">
<meta property="article:modified_time" content="2021-12-09T12:15:00.022Z">
<meta property="article:author" content="Juhick">
<meta property="article:tag" content="遗传算法">
<meta property="article:tag" content="TSP问题">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20211209161208.png">
  
  <title>采用遗传算法解决TSP问题 - 曾许人间第一流</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/hybrid.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"blog.qinhaiqi.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Juhick</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="采用遗传算法解决TSP问题">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-12-08 21:48" pubdate>
        2021年12月8日 晚上
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      14k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      45 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">采用遗传算法解决TSP问题</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：几秒前
                
              </p>
            
            <div class="markdown-body">
              <h1 id="求解过程"><a href="#求解过程" class="headerlink" title="求解过程"></a>求解过程</h1><h2 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h2><p>首先读取出每个城市的<strong>坐标信息</strong>，并计算出每两个城市之间的<strong>直线距离</strong>：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_array</span>():</span><br>    data = np.loadtxt(<span class="hljs-string">&#x27;data.txt&#x27;</span>)<br>    city_name = data[:, <span class="hljs-number">0</span>]<br>    city_point = data[:, <span class="hljs-number">1</span>:]<br>    city_count = <span class="hljs-built_in">len</span>(city_name)<br>    distance = np.zeros([city_count, city_count])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_count):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_count):<br>            distance[i][j] = math.sqrt((city_point[i][<span class="hljs-number">0</span>] - city_point[j][<span class="hljs-number">0</span>]) ** <span class="hljs-number">2</span> +<br>                                       (city_point[i][<span class="hljs-number">1</span>] - city_point[j][<span class="hljs-number">1</span>]) ** <span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">return</span> city_count, distance<br></code></pre></div></td></tr></table></figure>
<span id="more"></span>
<h2 id="种群初始化"><a href="#种群初始化" class="headerlink" title="种群初始化"></a>种群初始化</h2><p>进行初期的优秀个体的选择，先<strong>随机生成</strong>指定个数的个体。</p>
<p>然后对每一个个体进行指定次数的<strong>改良圈算法</strong>，取得<strong>较好</strong>的个体</p>
<p>改良圈算法即每次随机选择个体中的两个相异城市<code>u</code>和<code>v</code>，如果交换这两个城市能够取得<strong>更好的适应度</strong>（即更小的总距离），则交换这两个城市，重复改良操作指定次数得到多个较好的个体。具体的改良圈算法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">improve</span>(<span class="hljs-params">x</span>):</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; improve_count:<br>        <span class="hljs-comment"># 生成指定范围的两个整数</span><br>        u = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(x) - <span class="hljs-number">2</span>)<br>        v = random.randint(u + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(x) - <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 如果倒序区间内的路径可以取得更好的路径时，更新路径</span><br>        <span class="hljs-keyword">if</span> Distance[u - <span class="hljs-number">1</span>][v] + Distance[u][v + <span class="hljs-number">1</span>] &lt; Distance[u - <span class="hljs-number">1</span>][u] + Distance[v][v + <span class="hljs-number">1</span>]:<br>            t = x[u]<br>            x[u] = x[v]<br>            x[v] = t<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> x<br></code></pre></div></td></tr></table></figure>
<p>初始化的全过程：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python">population = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count):<br>    <span class="hljs-comment"># 随机生成个体</span><br>    x = index.copy()<br>    <span class="hljs-comment"># 打乱顺序</span><br>    random.shuffle(x)<br>    <span class="hljs-comment"># 改良圈算法优化种群</span><br>    x = improve(x)<br>    <span class="hljs-comment"># 把每个个体逐个添加到种群里</span><br>    population.append(x)<br></code></pre></div></td></tr></table></figure>
<h2 id="自然选择"><a href="#自然选择" class="headerlink" title="自然选择"></a>自然选择</h2><p>在遗传学中，适应度是指个体对自然环境的适应程度，自然选择过程中需要根据适者生存的原则保存优秀的个体，淘汰不适应环境的个体。</p>
<p>在TSP问题中，适应度即为一个个体的总距离。</p>
<p>若当前城市为最后一个城市，则总距离加上回到起点的距离，否则加上当前城市与下一城市之间的距离。</p>
<p>计算单个个体总距离的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_total_distance</span>(<span class="hljs-params">x</span>):</span><br>    distance = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 距离矩阵中第一个点到这个个体的第一个点的距离</span><br>    distance += Distance[origin][x[<span class="hljs-number">0</span>]]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(x) - <span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 从终点回到起点</span><br>            distance += Distance[origin][x[i]]<br>        <span class="hljs-keyword">else</span>:<br>            distance += Distance[x[i]][x[i + <span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">return</span> distance<br></code></pre></div></td></tr></table></figure>
<p>总距离越小越符合我们的要求，所以按照<strong>总距离的升序</strong>排序即为<strong>适应度</strong>从大到小的顺序。</p>
<p>首先根据<strong>适者生存</strong>的原则，选择指定比例适应度高的个体<strong>直接生存</strong>，然后采用<strong>轮盘赌法</strong>选择一定数量的个体。</p>
<p>轮盘赌法的具体流程如下：</p>
<ol>
<li><p>计算出种群中每个个体的<strong>适应度</strong>$f(i=1,2,…,\text{M})$，$\text{M}$为<strong>种群大小</strong>，即种群中个体的个数。</p>
</li>
<li><p>计算出每个个体被遗传到下一代群体中的概率，即</p>
<script type="math/tex; mode=display">
p(i)=个体适应度/种群总适应度</script></li>
<li><p>计算每个个体的<strong>累计概率</strong>，即</p>
<script type="math/tex; mode=display">
\begin{align}
q(1) & =p(1) \\
q(2) & =p(1)+p(2) \\
& ... \\
q(n) & =p(1)+p(2)+...+p(n)\\
\end{align}</script></li>
<li><p>在$[0,1]$区间内生成一个均匀分布的伪随机数$\text{r}$</p>
</li>
<li><p>若$\text{r}&lt;q[1]$，则选择个体1，否则，选择个体$\text{k}$，使得：$q[k-1]&lt;r\leq q[k]$成立</p>
</li>
<li><p><strong>重复4、5共$\text{M}$次</strong></p>
</li>
</ol>
<p>轮盘赌的代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 轮盘赌</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">roulette</span>(<span class="hljs-params">population</span>):</span><br>    q = []<br>    p = []<br><br>    <span class="hljs-comment"># 计算每个个体被遗传到下一代群体中的概率</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> population:<br>        p.append(get_total_distance(item))<br>    p /= <span class="hljs-built_in">sum</span>(p)<br><br>    <span class="hljs-comment"># 计算每个个体的累计概率</span><br>    cur = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> p:<br>        cur += i<br>        q.append(cur)<br><br>    choices = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count):<br>        rate = random.random()<br>        <span class="hljs-keyword">for</span> _, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(q):<br>            <span class="hljs-keyword">if</span> rate &lt;= j:<br>                choices.append(_)<br>    <span class="hljs-keyword">return</span> choices<br></code></pre></div></td></tr></table></figure>
<h2 id="交叉"><a href="#交叉" class="headerlink" title="交叉"></a>交叉</h2><blockquote>
<p>  交叉是指每一个个体是由父亲和母亲两个个体繁殖产生，子代个体的 DNA（二进制串） 获得了一半父亲的 DNA，一半母亲的 DNA，但是这里的一半并不是真正的一半，这个位置叫做交配点，是<strong>随机产生</strong>的，可以是染色体的任意位置。</p>
</blockquote>
<p>总的来说，交叉是一个种群中，不同个体的<strong>部分信息交换</strong>。传统的交叉有<strong>单点交叉</strong>、<strong>双点交叉</strong>以及<strong>部分匹配交叉</strong>。</p>
<p>在该问题中采取的是<strong>次序交叉法</strong>。</p>
<p><strong>交叉结束后需要保持种群规模稳定，即种群的总个体数是不变的。</strong></p>
<p>次序杂交算法首先<strong>随机</strong>地在双亲中选择<strong>两个杂交点</strong>，再<strong>交换杂交段</strong>，其他位置根据双亲城市的<strong>相对位置</strong>确定。</p>
<p>具体代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 交叉繁殖</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crossover</span>(<span class="hljs-params">parents</span>):</span><br>    <span class="hljs-comment"># 生成的子代的个数，以此保证种群稳定，即总种群数是不变的</span><br>    target_count = count - <span class="hljs-built_in">len</span>(parents)<br>    <span class="hljs-comment"># 子代列表</span><br>    children = []<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(children) &lt; target_count:<br>        <span class="hljs-comment"># 随机选择父母</span><br>        male_index, female_index = random.sample(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(parents) - <span class="hljs-number">1</span>), <span class="hljs-number">2</span>)<br>        male = parents[male_index]<br>        female = parents[female_index]<br><br>        left = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(male) - <span class="hljs-number">2</span>)<br>        right = random.randint(left + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(male) - <span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 交叉片段</span><br>        <span class="hljs-comment"># 此处的交叉过程参照pdf</span><br>        gene1 = male[left:right]<br>        gene2 = female[left:right]<br><br>        <span class="hljs-comment"># 转换附带染色体的顺序得到亚父代</span><br>        child1_c = male[right:] + male[:right]<br>        child2_c = female[right:] + female[:right]<br>        child1 = child1_c.copy()<br>        child2 = child2_c.copy()<br><br>        <span class="hljs-comment"># 去掉交叉片段</span><br>        <span class="hljs-keyword">for</span> o <span class="hljs-keyword">in</span> gene2:<br>            child1_c.remove(o)<br><br>        <span class="hljs-keyword">for</span> o <span class="hljs-keyword">in</span> gene1:<br>            child2_c.remove(o)<br><br>        <span class="hljs-comment"># 插入交叉片段</span><br>        child1[left:right] = gene2<br>        child2[left:right] = gene1<br><br>        <span class="hljs-comment"># 填入原来的片段</span><br>        child1[right:] = child1_c[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(child1) - right]<br>        child1[:left] = child1_c[<span class="hljs-built_in">len</span>(child1) - right:]<br><br>        child2[right:] = child2_c[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(child2) - right]<br>        child2[:left] = child2_c[<span class="hljs-built_in">len</span>(child2) - right:]<br><br>        children.append(child1)<br>        children.append(child2)<br><br>    <span class="hljs-keyword">return</span> children<br></code></pre></div></td></tr></table></figure>
<h2 id="变异"><a href="#变异" class="headerlink" title="变异"></a>变异</h2><p>变异是对种群选定个体的操作。</p>
<p>遍历种群中的每一个个体，生成$[0,1]$范围内均匀分布的伪随机数，如果随机数<strong>小于给定的变异率</strong>，则该个体执行变异操作。</p>
<p>变异操作的具体操作为：在染色体中随机地取三个整数，满足$1&lt;u&lt;v&lt;w&lt;城市数$，把<code>u</code>和<code>v</code>之间的（包括<code>u</code>和<code>v</code>）的基因段插到<code>w</code>后面。</p>
<p>具体操作如下：</p>
<figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-comment"># 变异</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mutation</span>(<span class="hljs-params">children</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(children)):<br>        <span class="hljs-comment"># 满足条件才变异</span><br>        <span class="hljs-keyword">if</span> random.random() &lt; mutation_rate:<br>            child = children[i]<br>            u = random.randint(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(child) - <span class="hljs-number">4</span>)<br>            v = random.randint(u + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(child) - <span class="hljs-number">3</span>)<br>            w = random.randint(v + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(child) - <span class="hljs-number">2</span>)<br>            <span class="hljs-comment"># 第二和第三段互换</span><br>            child = child[<span class="hljs-number">0</span>:u] + child[v:w] + child[u:v] + child[w:]<br></code></pre></div></td></tr></table></figure>
<h1 id="问题解答"><a href="#问题解答" class="headerlink" title="问题解答"></a>问题解答</h1><h2 id="遗传算法求解TSP问题的流程图"><a href="#遗传算法求解TSP问题的流程图" class="headerlink" title="遗传算法求解TSP问题的流程图"></a>遗传算法求解TSP问题的流程图</h2><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20211209161208.png" srcset="/img/loading.gif" lazyload alt="1"></p>
<h2 id="不同规模的TSP问题的算法性能"><a href="#不同规模的TSP问题的算法性能" class="headerlink" title="不同规模的TSP问题的算法性能"></a>不同规模的TSP问题的算法性能</h2><p>城市数量规模越大或种群规模越大或迭代次数越大，运行时间就越长。</p>
<p>城市规模越大，每次迭代所用的时间越长，获取最优解的时间也越长，当城市规模大到一定程度时，遗传算法的求解性能优于广度/宽度优先搜索算法，耗时远小于一般的搜索算法。</p>
<p>种群规模越大每次迭代耗时越长，迭代次数越大则总时间越长，同时这两个指标的增大也会提高结果的精确度。</p>
<p><strong>实验次数：14</strong></p>
<p><strong>最大迭代次数：500</strong></p>
<p><strong>变异概率：0.1</strong></p>
<p><strong>强者生存率：0.2</strong></p>
<p><strong>改良次数：500</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">城市个数</th>
<th style="text-align:center">时间（ms）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">10422</td>
</tr>
<tr>
<td style="text-align:center">15</td>
<td style="text-align:center">11600</td>
</tr>
<tr>
<td style="text-align:center">20</td>
<td style="text-align:center">12886</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center">14014</td>
</tr>
<tr>
<td style="text-align:center">30</td>
<td style="text-align:center">15411</td>
</tr>
<tr>
<td style="text-align:center">35</td>
<td style="text-align:center">16483</td>
</tr>
<tr>
<td style="text-align:center">40</td>
<td style="text-align:center">17537</td>
</tr>
<tr>
<td style="text-align:center">45</td>
<td style="text-align:center">18811</td>
</tr>
<tr>
<td style="text-align:center">50</td>
<td style="text-align:center">20527</td>
</tr>
<tr>
<td style="text-align:center">55</td>
<td style="text-align:center">21406</td>
</tr>
<tr>
<td style="text-align:center">60</td>
<td style="text-align:center">22610</td>
</tr>
<tr>
<td style="text-align:center">65</td>
<td style="text-align:center">23363</td>
</tr>
<tr>
<td style="text-align:center">70</td>
<td style="text-align:center">24433</td>
</tr>
<tr>
<td style="text-align:center">75</td>
<td style="text-align:center">25549</td>
</tr>
</tbody>
</table>
</div>
<p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20211209193559.png" srcset="/img/loading.gif" lazyload alt="image-20211209193559091"></p>
<p>由图中可以看出，遗传算法的<strong>执行时间随着$TSP$问题规模的增大而增大</strong>，并且大致为线性增长</p>
<h2 id="同一个-TSP-问题，种群规模、交叉概率和变异概率对算法结果的影响"><a href="#同一个-TSP-问题，种群规模、交叉概率和变异概率对算法结果的影响" class="headerlink" title="同一个 TSP 问题，种群规模、交叉概率和变异概率对算法结果的影响"></a>同一个 TSP 问题，种群规模、交叉概率和变异概率对算法结果的影响</h2><ol>
<li><p>种群规模对结果的影响：种群规模越大算法结果越精确，适应度越好，但是运行时间越长。</p>
<p>|  x   | 0    | 1.1  | 3.5  | 3    | 7    | 8    | 4    | 4.5  | 9    | 2    |<br>| :—: | —— | —— | —— | —— | —— | —— | —— | —— | —— | —— |<br>|  y   | 1.1  | 3    | 2    | 4    | 5.1  | 8    | 4    | 4.5  | 9    | 2    |</p>
<p><strong>实验次数：10</strong><br><strong>最大迭代步数：100</strong><br><strong>变异概率：0.1</strong><br><strong>强者生存率：0.2</strong><br><strong>改良次数：500</strong></p>
<p>| 种群规模 |     最好适应度     |            最优路径            |<br>| :———: | :————————: | :——————————————: |<br>|    10    | 26.75325227412243  | [0, 3, 5, 8, 4, 7, 6, 2, 9, 1] |<br>|    20    | 25.165169218366618 | [0, 9, 2, 4, 8, 5, 7, 6, 3, 1] |<br>|    30    | 26.976241673343697 | [0, 3, 4, 5, 8, 7, 6, 2, 9, 1] |<br>|    50    | 26.788575223880752 | [0, 3, 6, 7, 4, 8, 5, 2, 9, 1] |<br>|    80    | 25.165169218366618 | [0, 9, 2, 4, 8, 5, 7, 6, 3, 1] |<br>|   100    |  25.6205952507828  | [0, 1, 3, 7, 5, 8, 4, 6, 2, 9] |<br>|   150    | 25.165169218366618 | [0, 9, 2, 4, 8, 5, 7, 6, 3, 1] |<br>|   200    | 25.165169218366618 | [0, 9, 2, 4, 8, 5, 7, 6, 3, 1] |<br>|   250    | 25.165169218366618 | [0, 9, 2, 4, 5, 8, 7, 6, 3, 1] |<br>|   300    | 25.165169218366618 | [0, 1, 3, 6, 7, 5, 8, 4, 2, 9] |</p>
<p>从表中可以得知，<strong>种群规模越大，越容易找到最优解</strong></p>
</li>
<li><p>交叉概率对结果的影响：交叉概率过低得不到最优解，交叉概率越高则平均适应度越好。</p>
<p>| x    | 9    | 1.1  | 3.5  | 3.5  | 7    | 8    | 4    | 4.5  | 3    | 2    |<br>| —— | —— | —— | —— | —— | —— | —— | —— | —— | —— | —— |<br>| y    | 1.1  | 3    | 1    | 4    | 5.1  | 3    | 1    | 8.5  | 9    | 1    |</p>
<p><strong>实验次数：20</strong><br><strong>种群规模：25</strong><br><strong>最大迭代步数：100</strong><br><strong>变异概率：0.1</strong><br><strong>改良次数：500</strong></p>
<p>| 交叉概率 | 最好适应度 | 最差适应度 |             最优解             |<br>| :———: | :————: | :————: | :——————————————: |<br>|  0.001   |  28.0447   |  36.6567   | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] |<br>|   0.01   |  27.0935   |  34.9943   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |<br>|   0.1    |  28.0447   |  35.3033   | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] |<br>|   0.15   |  28.0447   |  34.1175   | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] |<br>|   0.2    |  28.7108   |  33.9512   | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] |<br>|   0.25   |  28.0447   |  35.1623   | [0, 6, 2, 9, 1, 3, 7, 8, 4, 5] |<br>|   0.3    |  27.0935   |  31.9941   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |<br>|   0.35   |  27.0935   |  32.8085   | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |<br>|   0.4    |  27.0935   |  32.5313   | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |<br>|   0.45   |  27.0935   |  33.2014   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |<br>|   0.5    |  28.0934   |  33.6307   | [0, 2, 6, 9, 8, 3, 1, 7, 4, 5] |<br>|   0.55   |  27.0935   |  33.5233   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |<br>|   0.6    |  27.0935   |  33.2512   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |<br>|   0.65   |  28.0447   |  33.7003   | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] |<br>|   0.7    |  27.0935   |  32.0927   | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |<br>|   0.75   |  28.0447   |  32.4488   | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] |<br>|   0.8    |  27.0935   |  32.1551   | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |<br>|   0.85   |  27.0935   |  34.5399   | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |<br>|   0.9    |  27.0935   |  32.6273   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |<br>|   0.95   |  27.0935   |  32.4672   | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |</p>
<p><strong>交叉概率过低会导致搜索陷入迟钝状态，得不到最优解。</strong></p>
</li>
<li><p>变异概率对结果的影响：变异概率过高或者过低都影响得到最优解。</p>
<p>| x    | 9    | 1.1  | 3.5  | 3.5  | 7    | 8    | 4    | 4.5  | 3    | 2    |<br>| —— | —— | —— | —— | —— | —— | —— | —— | —— | —— | —— |<br>| y    | 1.1  | 3    | 1    | 4    | 5.1  | 3    | 1    | 8.5  | 9    | 1    |</p>
<p><strong>实验次数：10</strong><br><strong>种群规模： 25</strong><br><strong>最大迭代步数：100</strong><br><strong>强者生存率：0.2</strong><br><strong>改良次数：500</strong></p>
<p>| 变异概率 |     最好适应度     |     最差适应度     |             最优解             |<br>| :———: | :————————: | :————————: | :——————————————: |<br>|  0.001   | 29.04461410913315  | 62.857048114582284 | [0, 2, 6, 9, 1, 3, 7, 8, 4, 5] |<br>|   0.01   |  29.8205487605704  | 59.021542403181286 | [0, 6, 2, 9, 1, 8, 7, 3, 4, 5] |<br>|   0.1    | 27.093469055093585 | 67.35172234680323  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |<br>|   0.15   | 28.044704993363116 | 62.34078967932604  | [0, 6, 2, 9, 1, 3, 7, 8, 4, 5] |<br>|   0.2    | 29.663093341048622 | 60.78329972771102  | [0, 4, 7, 8, 3, 1, 9, 6, 2, 5] |<br>|   0.25   | 29.471670891705937 | 56.941498157638016 | [0, 5, 4, 7, 8, 3, 9, 1, 2, 6] |<br>|   0.3    | 27.09346905509359  | 60.80914022879588  | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |<br>|   0.35   |  29.8205487605704  |  59.9879303570508  | [0, 6, 2, 9, 1, 8, 7, 3, 4, 5] |<br>|   0.4    | 28.71080039515015  |  62.0291540376335  | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] |<br>|   0.45   | 27.093469055093585 | 60.020339525499736 | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |<br>|   0.5    | 31.017146449260395 | 61.778858472645226 | [0, 4, 7, 8, 1, 9, 6, 2, 3, 5] |<br>|   0.55   | 29.523109581860524 | 61.308292618582136 | [0, 6, 2, 9, 3, 1, 8, 7, 4, 5] |<br>|   0.6    | 28.71080039515015  | 57.36283637285175  | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] |<br>|   0.65   | 28.044704993363116 | 56.47986578733702  | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] |<br>|   0.7    | 28.71080039515015  | 54.99612885006041  | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] |<br>|   0.75   | 27.093469055093585 | 58.64350752950667  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |<br>|   0.8    | 33.62523662987781  | 58.11757698431604  | [0, 9, 1, 3, 6, 2, 8, 7, 4, 5] |<br>|   0.85   | 30.65911964653145  | 57.26822085037636  | [0, 1, 9, 2, 6, 3, 8, 7, 4, 5] |<br>|   0.9    | 30.558527714409507 | 54.97212958853783  | [0, 4, 7, 8, 1, 9, 2, 6, 3, 5] |<br>|   0.95   | 27.093469055093585 | 58.69791735252354  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |</p>
<p>由上表可知，<strong>变异概率过大或过小都将导致无法得到最优解</strong>。</p>
</li>
</ol>
<h2 id="求解同一-TSP-问题时不同变异-策略及不同个体选择分配策略对算法结果的影响"><a href="#求解同一-TSP-问题时不同变异-策略及不同个体选择分配策略对算法结果的影响" class="headerlink" title="求解同一 TSP 问题时不同变异 策略及不同个体选择分配策略对算法结果的影响"></a>求解同一 TSP 问题时不同变异 策略及不同个体选择分配策略对算法结果的影响</h2><p>不同的变异策略和不同个体选择分配策略几乎不影响算法运行时间，但会影响适应度。</p>
<p><strong>种群规模：100</strong></p>
<p><strong>强者生存率：0.2</strong></p>
<p><strong>变异概率：0.1</strong></p>
<p><strong>迭代次数：100</strong></p>
<p><strong>改良次数：500</strong></p>
<h3 id="不同变异方式"><a href="#不同变异方式" class="headerlink" title="不同变异方式"></a>不同变异方式</h3><h4 id="两段互换变异"><a href="#两段互换变异" class="headerlink" title="两段互换变异"></a>两段互换变异</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>最好适应度</th>
<th>最差适应度</th>
<th>最优解</th>
<th>运行时间(ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>27.093469055093585</td>
<td>64.58673755103145</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>329</td>
</tr>
<tr>
<td>2</td>
<td><font color='red'>28.71080039515015</font></td>
<td>60.364752044464225</td>
<td>[0, 4, 7, 8, 3, 1, 9, 2, 6, 5]</td>
<td>327</td>
</tr>
<tr>
<td>3</td>
<td>27.093469055093585</td>
<td>60.92646207878362</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>332</td>
</tr>
<tr>
<td>4</td>
<td>27.093469055093585</td>
<td>63.35856831546827</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>327</td>
</tr>
<tr>
<td>5</td>
<td>27.093469055093585</td>
<td>62.63158740484413</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>325</td>
</tr>
<tr>
<td>6</td>
<td><font color='red'>28.71080039515015</font></td>
<td>67.19548561742295</td>
<td>[0, 4, 7, 8, 3, 1, 9, 2, 6, 5]</td>
<td>327</td>
</tr>
<tr>
<td>7</td>
<td>27.093469055093585</td>
<td>59.9278211378547</td>
<td>[0, 4, 7, 8, 3, 1, 9, 2, 6, 5]</td>
<td>318</td>
</tr>
<tr>
<td>8</td>
<td><font color='red'>28.044704993363116</font></td>
<td>66.31637670882675</td>
<td>[0, 5, 4, 8, 7, 3, 1, 9, 2, 6]</td>
<td>322</td>
</tr>
<tr>
<td>9</td>
<td><font color='red'>29.8205487605704</font></td>
<td>62.47953168553274</td>
<td>[0, 6, 2, 9, 1, 8, 7, 3, 4, 5]</td>
<td>318</td>
</tr>
<tr>
<td>10</td>
<td>27.093469055093585</td>
<td>67.05238800897004</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>323</td>
</tr>
</tbody>
</table>
</div>
<h4 id="两点互换变异"><a href="#两点互换变异" class="headerlink" title="两点互换变异"></a>两点互换变异</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>最好适应度</th>
<th>最差适应度</th>
<th>最优解</th>
<th>运行时间(ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>27.093469055093585</td>
<td>63.52598521634741</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>320</td>
</tr>
<tr>
<td>2</td>
<td>27.09346905509359</td>
<td>60.61311586996357</td>
<td>[0, 5, 4, 7, 8, 3, 1, 9, 2, 6]</td>
<td>318</td>
</tr>
<tr>
<td>3</td>
<td>27.093469055093585</td>
<td>62.152408970104695</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>321</td>
</tr>
<tr>
<td>4</td>
<td>27.093469055093585</td>
<td>61.42280600968619</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>329</td>
</tr>
<tr>
<td>5</td>
<td>27.093469055093585</td>
<td>66.58043824593932</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>321</td>
</tr>
<tr>
<td>6</td>
<td>27.093469055093585</td>
<td>63.59408495310639</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>319</td>
</tr>
<tr>
<td>7</td>
<td><font color='red'>28.71080039515015</font></td>
<td>65.96786537403402</td>
<td>[0, 4, 7, 8, 3, 1, 9, 2, 6, 5]</td>
<td>321</td>
</tr>
<tr>
<td>8</td>
<td>27.09346905509359</td>
<td>66.7449340200782</td>
<td>[0, 5, 4, 7, 8, 3, 1, 9, 2, 6]</td>
<td>321</td>
</tr>
<tr>
<td>9</td>
<td>27.093469055093585</td>
<td>65.28233845399363</td>
<td>[0, 6, 2, 9, 1, 8, 7, 3, 4, 5]</td>
<td>320</td>
</tr>
<tr>
<td>10</td>
<td>27.093469055093585</td>
<td>63.43117999008514</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>317</td>
</tr>
</tbody>
</table>
</div>
<p>可以看到两种变异方式的运行时间接近，但是两段互换取得了<strong>4次非最优解</strong>，两点互换只取得了<strong>1次非最优解</strong>。可见，在此条件下（变异概率、强者存活率和种群规模等），两点互换比两段互换的算法效果要好。</p>
<h3 id="不同选择概率分配策略"><a href="#不同选择概率分配策略" class="headerlink" title="不同选择概率分配策略"></a>不同选择概率分配策略</h3><h4 id="适应度比例法"><a href="#适应度比例法" class="headerlink" title="适应度比例法"></a>适应度比例法</h4><p>同两点互换</p>
<h4 id="完全随机法"><a href="#完全随机法" class="headerlink" title="完全随机法"></a>完全随机法</h4><div class="table-container">
<table>
<thead>
<tr>
<th>序号</th>
<th>最好适应度</th>
<th>最差适应度</th>
<th>最优解</th>
<th>运行时间(ms)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td><font color='red'>29.8205487605704</font></td>
<td>63.7607928266052</td>
<td>[0, 6, 2, 9, 1, 8, 7, 3, 4, 5]</td>
<td>249</td>
</tr>
<tr>
<td>2</td>
<td>27.09346905509359</td>
<td>60.995357534381405</td>
<td>[0, 5, 4, 7, 8, 3, 1, 9, 2, 6]</td>
<td>239</td>
</tr>
<tr>
<td>3</td>
<td><font color='red'>28.044704993363116</font></td>
<td>59.84856462743046</td>
<td>[0, 5, 4, 8, 7, 3, 1, 9, 2, 6]</td>
<td>241</td>
</tr>
<tr>
<td>4</td>
<td><font color='red'>30.558527714409507</font></td>
<td>63.01318560628126</td>
<td>[0, 4, 7, 8, 1, 9, 2, 6, 3, 5]</td>
<td>241</td>
</tr>
<tr>
<td>5</td>
<td><font color='red'>28.71080039515015</font></td>
<td>58.59344730195132</td>
<td>[0, 4, 7, 8, 3, 1, 9, 2, 6, 5]</td>
<td>246</td>
</tr>
<tr>
<td>6</td>
<td><font color='red'>29.523109581860524</font></td>
<td>64.13625288963031</td>
<td>[0, 6, 2, 9, 3, 1, 8, 7, 4, 5]</td>
<td>242</td>
</tr>
<tr>
<td>7</td>
<td>27.093469055093585</td>
<td>63.757600726543394</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>239</td>
</tr>
<tr>
<td>8</td>
<td>27.093469055093585</td>
<td>61.59802407894025</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>247</td>
</tr>
<tr>
<td>9</td>
<td>27.093469055093585</td>
<td>59.25248048349517</td>
<td>[0, 6, 2, 9, 1, 8, 7, 3, 4, 5]</td>
<td>245</td>
</tr>
<tr>
<td>10</td>
<td>27.093469055093585</td>
<td>66.85067394876258</td>
<td>[0, 6, 2, 9, 1, 3, 8, 7, 4, 5]</td>
<td>241</td>
</tr>
</tbody>
</table>
</div>
<p>对比可知，完全随机法虽然运行速度快，但是<strong>10次中有5次</strong>无法找到最优解。可见，在此条件下（变异概率、强者存活率和种群规模等），个体选择概率分配方式不宜选择完全随机法，适应度比例法效果更好。</p>
<h1 id="整体代码"><a href="#整体代码" class="headerlink" title="整体代码"></a>整体代码</h1><figure class="highlight python"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs python"><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> random<br><br><br><span class="hljs-comment"># 获取数据并计算每两个城市之间的距离</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_array</span>(<span class="hljs-params">n</span>):</span><br>    data = np.loadtxt(<span class="hljs-string">&#x27;data.txt&#x27;</span>)<br>    data = data[<span class="hljs-number">0</span>:n, :]<br>    city_name = data[:, <span class="hljs-number">0</span>]<br>    city_point = data[:, <span class="hljs-number">1</span>:]<br>    city_count = <span class="hljs-built_in">len</span>(city_name)<br>    distance = np.zeros([city_count, city_count])<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_count):<br>        <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(city_count):<br>            distance[i][j] = math.sqrt((city_point[i][<span class="hljs-number">0</span>] - city_point[j][<span class="hljs-number">0</span>]) ** <span class="hljs-number">2</span> +<br>                                       (city_point[i][<span class="hljs-number">1</span>] - city_point[j][<span class="hljs-number">1</span>]) ** <span class="hljs-number">2</span>)<br><br>    <span class="hljs-keyword">return</span> city_count, distance<br><br><br><span class="hljs-comment"># 计算一个个体的总距离</span><br><span class="hljs-comment"># 此处的个体即为其中的一条路径，这里就是求这条路径的总距离</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_total_distance</span>(<span class="hljs-params">x</span>):</span><br>    distance = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 距离矩阵中第一个点到这个个体的第一个点的距离</span><br>    distance += Distance[origin][x[<span class="hljs-number">0</span>]]<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(x)):<br>        <span class="hljs-keyword">if</span> i == <span class="hljs-built_in">len</span>(x) - <span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 从终点回到起点</span><br>            distance += Distance[origin][x[i]]<br>        <span class="hljs-keyword">else</span>:<br>            distance += Distance[x[i]][x[i + <span class="hljs-number">1</span>]]<br>    <span class="hljs-keyword">return</span> distance<br><br><br><span class="hljs-comment"># 改良圈算法</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">improve</span>(<span class="hljs-params">x</span>):</span><br>    i = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> i &lt; improve_count:<br>        <span class="hljs-comment"># 生成指定范围的两个整数</span><br>        u = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(x) - <span class="hljs-number">2</span>)<br>        v = random.randint(u + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(x) - <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 如果倒序区间内的路径可以取得更好的路径时，更新路径</span><br>        <span class="hljs-keyword">if</span> Distance[u - <span class="hljs-number">1</span>][v] + Distance[u][v + <span class="hljs-number">1</span>] &lt; Distance[u - <span class="hljs-number">1</span>][u] + Distance[v][v + <span class="hljs-number">1</span>]:<br>            t = x[u]<br>            x[u] = x[v]<br>            x[v] = t<br>        i += <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> x<br><br><br><span class="hljs-comment"># 获取当前种群的最佳结果，即获取当前种群中总距离最小的那条路径</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_result</span>(<span class="hljs-params">population</span>):</span><br>    graded = [[get_total_distance(x), x] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> population]<br>    graded = <span class="hljs-built_in">sorted</span>(graded)<br>    min_res = graded[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]<br>    max_res = graded[<span class="hljs-built_in">len</span>(graded) - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>]<br>    <span class="hljs-keyword">return</span> min_res, max_res, graded[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br><br><br><span class="hljs-comment"># 轮盘赌</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">roulette</span>(<span class="hljs-params">population</span>):</span><br>    q = []<br>    p = []<br><br>    <span class="hljs-comment"># 计算每个个体被遗传到下一代群体中的概率</span><br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> population:<br>        p.append(get_total_distance(item))<br>    p /= <span class="hljs-built_in">sum</span>(p)<br><br>    <span class="hljs-comment"># 计算每个个体的累计概率</span><br>    cur = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> p:<br>        cur += i<br>        q.append(cur)<br><br>    choices = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count):<br>        rate = random.random()<br>        <span class="hljs-keyword">for</span> _, j <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(q):<br>            <span class="hljs-keyword">if</span> rate &lt;= j:<br>                choices.append(_)<br>                <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">return</span> choices<br><br><br><span class="hljs-comment"># 自然选择过程</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">selection</span>(<span class="hljs-params">population</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    选择</span><br><span class="hljs-string">    先对适应度从大到小排序，选出存活的染色体</span><br><span class="hljs-string">    再进行随机选择，选出适应度虽然小，但是幸存下来的个体（使用轮盘赌方法）</span><br><span class="hljs-string">    :param population: 初始种群</span><br><span class="hljs-string">    :return: 选择出的种群</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-comment"># 适应度从大到小排序，选出存活的染色体，即强者存活</span><br>    graded = [[get_total_distance(x), x] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> population]<br>    graded = [x[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">sorted</span>(graded)]<br>    <span class="hljs-comment"># 选出适应性强的染色体</span><br>    retain_length = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">len</span>(graded) * retain_rate)<br>    parents = graded[:retain_length]<br>    <span class="hljs-comment"># 轮盘赌</span><br>    choices = roulette(graded)<br>    <span class="hljs-keyword">for</span> choice <span class="hljs-keyword">in</span> choices:<br>        <span class="hljs-keyword">if</span> graded[choice] <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> parents:<br>            parents.append(graded[choice])<br>    <span class="hljs-keyword">return</span> parents<br><br><br><span class="hljs-comment"># 交叉繁殖</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">crossover</span>(<span class="hljs-params">parents</span>):</span><br>    <span class="hljs-comment"># 生成的子代的个数，以此保证种群稳定，即总种群数是不变的</span><br>    target_count = count - <span class="hljs-built_in">len</span>(parents)<br>    <span class="hljs-comment"># 子代列表</span><br>    children = []<br>    <span class="hljs-keyword">while</span> <span class="hljs-built_in">len</span>(children) &lt; target_count:<br>        <span class="hljs-comment"># 随机选择父母</span><br>        male_index, female_index = random.sample(<span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(parents) - <span class="hljs-number">1</span>), <span class="hljs-number">2</span>)<br>        male = parents[male_index]<br>        female = parents[female_index]<br><br>        left = random.randint(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(male) - <span class="hljs-number">2</span>)<br>        right = random.randint(left + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(male) - <span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 交叉片段</span><br>        <span class="hljs-comment"># 此处的交叉过程参照pdf</span><br>        gene1 = male[left:right]<br>        gene2 = female[left:right]<br><br>        <span class="hljs-comment"># 转换附带染色体的顺序得到亚父代</span><br>        child1_c = male[right:] + male[:right]<br>        child2_c = female[right:] + female[:right]<br>        child1 = child1_c.copy()<br>        child2 = child2_c.copy()<br><br>        <span class="hljs-comment"># 去掉交叉片段</span><br>        <span class="hljs-keyword">for</span> o <span class="hljs-keyword">in</span> gene2:<br>            child1_c.remove(o)<br><br>        <span class="hljs-keyword">for</span> o <span class="hljs-keyword">in</span> gene1:<br>            child2_c.remove(o)<br><br>        <span class="hljs-comment"># 插入交叉片段</span><br>        child1[left:right] = gene2<br>        child2[left:right] = gene1<br><br>        <span class="hljs-comment"># 填入原来的片段</span><br>        child1[right:] = child1_c[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(child1) - right]<br>        child1[:left] = child1_c[<span class="hljs-built_in">len</span>(child1) - right:]<br><br>        child2[right:] = child2_c[<span class="hljs-number">0</span>:<span class="hljs-built_in">len</span>(child2) - right]<br>        child2[:left] = child2_c[<span class="hljs-built_in">len</span>(child2) - right:]<br><br>        children.append(child1)<br>        children.append(child2)<br><br>    <span class="hljs-keyword">return</span> children<br><br><br><span class="hljs-comment"># 变异</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">mutation</span>(<span class="hljs-params">children</span>):</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(children)):<br>        <span class="hljs-comment"># 满足条件才变异</span><br>        <span class="hljs-keyword">if</span> random.random() &lt; mutation_rate:<br>            child = children[i]<br>            u = random.randint(<span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(child) - <span class="hljs-number">4</span>)<br>            v = random.randint(u + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(child) - <span class="hljs-number">3</span>)<br>            w = random.randint(v + <span class="hljs-number">1</span>, <span class="hljs-built_in">len</span>(child) - <span class="hljs-number">2</span>)<br>            <span class="hljs-comment"># 第二和第三段互换</span><br>            child = child[<span class="hljs-number">0</span>:u] + child[v:w] + child[u:v] + child[w:]<br><br><br><span class="hljs-comment"># 进行遗传算法</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">begin</span>():</span><br>    <span class="hljs-comment"># 使用改良圈算法初始化种群</span><br>    population = []<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(count):<br>        <span class="hljs-comment"># 随机生成个体</span><br>        x = index.copy()<br>        <span class="hljs-comment"># 打乱顺序</span><br>        random.shuffle(x)<br>        <span class="hljs-comment"># 改良圈算法优化种群</span><br>        x = improve(x)<br>        <span class="hljs-comment"># 把每个个体逐个添加到种群里</span><br>        population.append(x)<br><br>    <span class="hljs-comment"># 保存每次最优路径</span><br>    register = []<br>    min_res, max_res, result_path = get_result(population)<br>    <span class="hljs-comment"># 进化次数</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> tqdm.trange(iter_count):<br>        <span class="hljs-comment"># 选择繁殖个体群</span><br>        parents = selection(population)<br>        <span class="hljs-comment"># 交叉繁殖</span><br>        children = crossover(parents)<br>        <span class="hljs-comment"># 变异操作</span><br>        mutation(children)<br>        <span class="hljs-comment"># 更新种群</span><br>        population = parents + children<br>        min_res, max_res, result_path = get_result(population)<br>        register.append(min_res)<br>    <span class="hljs-keyword">return</span> min_res, max_res, result_path<br><br><br><span class="hljs-comment"># 主函数</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 设置参数</span><br>    count = <span class="hljs-number">500</span>  <span class="hljs-comment"># 种群规模</span><br>    retain_rate = <span class="hljs-number">0.2</span>  <span class="hljs-comment"># 强者生存率</span><br>    mutation_rate = <span class="hljs-number">0.1</span>  <span class="hljs-comment"># 变异概率</span><br>    iter_count = <span class="hljs-number">500</span>  <span class="hljs-comment"># 迭代次数</span><br>    improve_count = <span class="hljs-number">500</span>  <span class="hljs-comment"># 改良次数</span><br>    scales = [<span class="hljs-number">10</span>, <span class="hljs-number">15</span>, <span class="hljs-number">20</span>, <span class="hljs-number">25</span>, <span class="hljs-number">30</span>, <span class="hljs-number">35</span>, <span class="hljs-number">40</span>, <span class="hljs-number">45</span>, <span class="hljs-number">50</span>, <span class="hljs-number">55</span>, <span class="hljs-number">60</span>, <span class="hljs-number">65</span>, <span class="hljs-number">70</span>, <span class="hljs-number">75</span>]<br><br>    <span class="hljs-comment"># 设置起点</span><br>    origin = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> scale <span class="hljs-keyword">in</span> scales:<br>        start = time.time()<br><br>        city_count, Distance = read_array(scale)<br><br>        <span class="hljs-comment"># 建立索引</span><br>        index = np.arange(city_count).tolist()<br>        index.remove(origin)<br><br>        min_res, max_res, result_path = begin()<br><br>        <span class="hljs-built_in">print</span>(min_res, max_res)<br>        <span class="hljs-built_in">print</span>(result_path)<br><br>        end = time.time()<br>        <span class="hljs-built_in">print</span>(scale, end-start)<br></code></pre></div></td></tr></table></figure>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD%E7%AE%97%E6%B3%95/">人工智能算法</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/">遗传算法</a>
                    
                      <a class="hover-with-bg" href="/tags/TSP%E9%97%AE%E9%A2%98/">TSP问题</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/11/18/%E6%9C%AA%E6%9B%BE%E4%B8%8E%E4%BD%A0%E5%85%B1%E5%BA%A6%E4%B8%80%E5%88%87/">
                        <span class="hidden-mobile">未曾与你共度一切</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments" lazyload>
                
                  
                
                
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"d1d427beff57ea9d6ccf","clientSecret":"ba3d1540396867fd92f96cfe7c41f48334fdc7fb","repo":"juhick.github.io","owner":"juhick","admin":["juhick"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: '8ddfae7498f14e630fa7a719793d73db'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>





  

  
    <!-- MathJax -->
    <script>
      MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']]
        },
        loader: {
          
        },
        options: {
          renderActions: {
            findScript: [10, doc => {
              document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                const display = !!node.type.match(/; *mode=display/);
                const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                const text = document.createTextNode('');
                node.parentNode.replaceChild(text, node);
                math.start = { node: text, delim: '', n: 0 };
                math.end = { node: text, delim: '', n: 0 };
                doc.math.push(math);
              });
            }, '', false],
            insertedScript: [200, () => {
              document.querySelectorAll('mjx-container').forEach(node => {
                let target = node.parentNode;
                if (target.nodeName.toLowerCase() === 'li') {
                  target.parentNode.classList.add('has-jax');
                }
              });
            }, '', false]
          }
        }
      };
    </script>

    <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.1.4/es5/tex-svg.js" ></script>

  











<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
