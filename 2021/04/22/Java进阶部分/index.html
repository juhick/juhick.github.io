

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="Java进阶从Java5.0开始，JDK中提供了java.util.concurrent（简称JUC ）包，在此包中增加了并发编程中常用的工具类，用于定义线程的自定义子系统，包括线程池、异步IO 和轻量级任务框架等。">
  <meta name="author" content="Juhick">
  <meta name="keywords" content="">
  <meta name="description" content="Java进阶从Java5.0开始，JDK中提供了java.util.concurrent（简称JUC ）包，在此包中增加了并发编程中常用的工具类，用于定义线程的自定义子系统，包括线程池、异步IO 和轻量级任务框架等。">
<meta property="og:type" content="article">
<meta property="og:title" content="Java进阶部分">
<meta property="og:url" content="https://blog.qinhaiqi.com/2021/04/22/Java%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/index.html">
<meta property="og:site_name" content="曾许人间第一流">
<meta property="og:description" content="Java进阶从Java5.0开始，JDK中提供了java.util.concurrent（简称JUC ）包，在此包中增加了并发编程中常用的工具类，用于定义线程的自定义子系统，包括线程池、异步IO 和轻量级任务框架等。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421211812.png">
<meta property="og:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421211901.png">
<meta property="og:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421212003.png">
<meta property="og:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421212118.png">
<meta property="og:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421212700.png">
<meta property="og:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421212745.png">
<meta property="og:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422111547.png">
<meta property="og:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422145850.png">
<meta property="og:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422150246.png">
<meta property="article:published_time" content="2021-04-22T06:31:14.000Z">
<meta property="article:modified_time" content="2021-09-23T10:46:50.957Z">
<meta property="article:author" content="Juhick">
<meta property="article:tag" content="面试">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421211812.png">
  
  <title>Java进阶部分 - 曾许人间第一流</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/github-gist.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  


<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->


  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"blog.qinhaiqi.com","root":"/","version":"1.8.12","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":"§"},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname"}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Juhick</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/bg/post.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h2" id="subtitle" title="Java进阶部分">
              
            </span>

            
              <div class="mt-3">
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2021-04-22 14:31" pubdate>
        2021年4月22日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      17k 字
    </span>
  

  
    <span class="post-meta mr-2">
      <i class="iconfont icon-clock-fill"></i>
      
      
      52 分钟
    </span>
  

  
  
</div>

            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Java进阶部分</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：14 分钟前
                
              </p>
            
            <div class="markdown-body">
              <h3 id="Java进阶"><a href="#Java进阶" class="headerlink" title="Java进阶"></a>Java进阶</h3><p>从Java5.0开始，JDK中提供了<strong>java.util.concurrent（简称JUC ）包</strong>，在此包中增加了并发编程中常用的工具类，用于定义线程的自定义子系统，包括线程池、异步IO 和轻量级任务框架等。</p>
<span id="more"></span>
<h4 id="进程和线程的区别：（重点掌握）"><a href="#进程和线程的区别：（重点掌握）" class="headerlink" title="进程和线程的区别：（重点掌握）"></a>进程和线程的区别：（重点掌握）</h4><ul>
<li>进程是资源分配的基本单位；线程是程序执行的基本单位</li>
<li>进程是一个“执行中的程序”，是系统进行<strong>资源分配和调度</strong>的一个独立单位</li>
<li>线程是进程的一个实体，一个进程中一般拥有多个线程。线程之间<strong>共享地址空间</strong>和其它资源（所以通信和同步等操作,线程比进程更加容易）</li>
<li>线程一般不拥有系统资源，但是也有一些必不可少的资源（使用ThreadLocal存储）</li>
<li>线程上下文的切换比进程上下文切换要快很多。</li>
</ul>
<h5 id="线程上下文切换比进程上下文切换快的原因"><a href="#线程上下文切换比进程上下文切换快的原因" class="headerlink" title="线程上下文切换比进程上下文切换快的原因"></a>线程上下文切换比进程上下文切换快的原因</h5><ul>
<li><strong>进程切换时</strong>，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置</li>
<li><strong>线程切换时</strong>，仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作</li>
</ul>
<h5 id="线程可以拥有自己的资源嘛"><a href="#线程可以拥有自己的资源嘛" class="headerlink" title="线程可以拥有自己的资源嘛"></a>线程可以拥有自己的资源嘛</h5><p>可以的，通过ThreadLocal可以存储线程的特有对象，也就是属于当前线程的资源。</p>
<h5 id="进程之间常见的通信方式"><a href="#进程之间常见的通信方式" class="headerlink" title="进程之间常见的通信方式"></a>进程之间常见的通信方式</h5><ul>
<li>通过使用套接字Socket来实现不同机器间的进程通信</li>
<li>通过映射一段可以被多个进程访问的共享内存来进行通信</li>
<li>通过写进程和读进程利用管道进行通信</li>
</ul>
<h4 id="多线程和单线程的关系"><a href="#多线程和单线程的关系" class="headerlink" title="多线程和单线程的关系"></a>多线程和单线程的关系</h4><ul>
<li>多线程是指在<strong>一个进程中，并发执行了多个线程</strong>，每个线程都实现了不同的功能</li>
<li>在单核CPU中，将CPU分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用CPU的机制。由于<strong>CPU轮询</strong>的速度非常快，所以看起来像是“同时”在执行一样</li>
<li>多线程会存在<strong>线程上下文切换</strong>，会导致程序执行速度变慢</li>
<li>多线程不会提高程序的执行速度，反而会降低速度。但是对于用户来说，可以<strong>减少用户的等待响应时间，提高了资源的利用效率</strong></li>
</ul>
<p><strong>多线程并发利用了CPU轮询时间片的特点</strong>，在一个线程进入阻塞状态时，可以快速切换到其余线程执行其余操作，这有利于<strong>提高资源的利用率，最大限度的利用系统提供的处理能力</strong>，<strong>有效减少了用户的等待响应时间</strong>。</p>
<p>但是，多线程并发编程也会带来数据的安全问题，线程之间的竞争也会导致线程死锁和锁死等<strong>活性故障</strong>。线程之间的上下文切换也会带来<strong>额外的开销</strong>等问题。</p>
<h4 id="线程的状态有哪些？"><a href="#线程的状态有哪些？" class="headerlink" title="线程的状态有哪些？"></a>线程的状态有哪些？</h4><p>线程的状态包括 <strong>新建状态，运行状态，阻塞等待状态和消亡状态。</strong>其中阻塞等待状态又分为<strong>BLOCKED, WAITING和TIMED_WAITING</strong>状态。</p>
<p>JDK8中对于Thread状态的枚举定义，所有的状态如下所示：</p>
<ol>
<li><p>NEW：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421211812.png" srcset="/img/loading.gif" lazyload alt="图片说明"><br>这是属于一个已经创建的线程，但是还没有调用start方法启动的线程所处的状态。</p>
</li>
<li><p>RUNNABLE：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421211901.png" srcset="/img/loading.gif" lazyload alt="图片说明"><br>该状态包含两种可能。有可能正在运行，或者正在等待CPU资源。总体上就是当我们创建线程并且启动之后，就属于Runnable状态。</p>
</li>
<li><p>BLOCKED：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421212003.png" srcset="/img/loading.gif" lazyload alt="图片说明"><br>阻塞状态，当线程准备进入synchronized同步块或同步方法的时候，需要申请一个监视器锁而进行的等待，会使线程进入BLOCKED状态。</p>
</li>
<li><p>WAITING<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421212118.png" srcset="/img/loading.gif" lazyload alt="图片说明"><br>该状态的出现是因为调用了<strong>Object.wait()或者Thread.join()或者LockSupport.park()</strong>。处于该状态下的线程在等待另一个线程 执行一些其余action来将其唤醒。</p>
</li>
<li><p>TIMED_WAITING:<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421212700.png" srcset="/img/loading.gif" lazyload alt="图片说明"><br>该状态和上一个状态其实是一样的，只不过其等待的时间是明确的。</p>
</li>
<li><p>TERMINATED：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421212745.png" srcset="/img/loading.gif" lazyload alt="图片说明"></p>
<p>消亡状态比较容易理解，那就是线程执行结束了，run方法执行结束表示线程处于消亡状态了。</p>
</li>
</ol>
<h4 id="多线程编程中常用的函数比较："><a href="#多线程编程中常用的函数比较：" class="headerlink" title="多线程编程中常用的函数比较："></a>多线程编程中常用的函数比较：</h4><p><strong>sleep和wait的区别：</strong></p>
<ul>
<li><strong>sleep方法：</strong>是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）。</li>
<li><strong>wait方法：</strong>是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有<strong>重新占用互斥锁</strong>之后才会进入可运行状态。睡眠时，会释放互斥锁。</li>
</ul>
<p><strong>join 方法：</strong>当前线程调用，则其它线程全部停止，等待当前线程执行完毕，接着执行。</p>
<p><strong>yield 方法：</strong>该方法使得线程放弃当前分得的 CPU 时间。但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。</p>
<h4 id="线程活性障碍有哪些？"><a href="#线程活性障碍有哪些？" class="headerlink" title="线程活性障碍有哪些？"></a>线程活性障碍有哪些？</h4><p>由于资源的稀缺性或者程序自身的问题导致线程<strong>一直处于非Runnable状态</strong>，并且其处理的任务<strong>一直无法完成的现象</strong>被称为是线程活性故障。常见的线程活性故障包括<strong>死锁，锁死，活锁与线程饥饿</strong>。</p>
<p>每一个线程都有其特定的任务处理逻辑。由于资源的稀缺性或者资源本身的一些特性，导致多个线程需要共享一些排他性资源，比如说处理器，数据库连接等。当出现资源争用的时候，部分线程会进入等待状态。</p>
<h5 id="线程死锁："><a href="#线程死锁：" class="headerlink" title="线程死锁："></a>线程死锁：</h5><p>死锁是最常见的一种线程活性故障。死锁的起因是多个线程之间相互等待对方而被永远暂停（处于非Runnable）。死锁的产生必须满足如下<strong>四个必要条件：</strong></p>
<ul>
<li><strong>资源互斥</strong>：一个资源每次只能被一个线程使用</li>
<li><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放</li>
<li><strong>不剥夺条件</strong>：线程已经获得的资源，在未使用完之前，不能被强行剥夺</li>
<li><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系</li>
</ul>
<h5 id="如何避免死锁的发生？"><a href="#如何避免死锁的发生？" class="headerlink" title="如何避免死锁的发生？"></a>如何避免死锁的发生？</h5><ul>
<li><p><strong>粗锁法：</strong>使用一个粒度粗的锁来消除“请求与保持条件”，缺点是会明显降低程序的并发性能并且会导致资源的浪费。</p>
</li>
<li><p><strong>锁排序法：（必须回答出来的点）</strong><br><strong>指定获取锁的顺序</strong>，比如某个线程只有获得A锁和B锁，才能对某资源进行操作，在多线程条件下，如何避免死锁？</p>
<p>通过指定锁的获取顺序，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁。这通常被认为是解决死锁很好的一种方法。</p>
<ul>
<li>使用<strong>显式锁</strong>中的<strong>ReentrantLock.try(long,TimeUnit)</strong>来申请锁</li>
</ul>
</li>
</ul>
<h5 id="线程锁死"><a href="#线程锁死" class="headerlink" title="线程锁死"></a>线程锁死</h5><p>线程锁死是另一种常见的线程活性故障，与线程死锁不可以混为一谈。</p>
<p><strong>线程锁死的定义如下：</strong></p>
<p>线程锁死是指等待线程由于唤醒其所需的条件永远无法成立，或者其他线程无法唤醒这个线程而一直处于非运行状态（线程并未终止）导致其任务一直无法进展。</p>
<p>线程死锁和线程锁死的外部表现是一致的，即故障线程一直处于非运行状态使得其所执行的任务没有进展。但是锁死的产生条件和线程死锁不一样，即使产生死锁的4个必要条件都没有发生，线程锁死仍然可能已经发生。</p>
<h5 id="线程锁死的种类："><a href="#线程锁死的种类：" class="headerlink" title="线程锁死的种类："></a>线程锁死的种类：</h5><ul>
<li><p><strong>信号丢失锁死：</strong><br>信号丢失锁死是因为没有对应的通知线程来将等待线程唤醒，导致等待线程一直处于等待状态。</p>
<p><strong>典型例子</strong>是等待线程在执行Object.wait( )/Condition.await( )前<strong>没有对保护条件进行判断，而此时保护条件实际上可能已经成立</strong>，此后可能并无其他线程更新相应保护条件涉及的共享变量使其成立并通知等待线程，这就使得等待线程一直处于等待状态，从而使其任务一直无法进展。</p>
</li>
<li><p><strong>嵌套监视器锁死：</strong>嵌套监视器锁死是由于嵌套锁导致等待线程永远无法被唤醒的一种故障。</p>
<p>比如一个线程，只释放了内层锁Y.wait()，但是没有释放外层锁X; 但是通知线程必须先获得外层锁X，才可以通过 Y.notifyAll()来唤醒等待线程，这就导致出现了嵌套等待现象。</p>
</li>
</ul>
<h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁是一种特殊的线程活性故障。当一个线程一直处于运行状态，但是其所执行的任务却没有任何进展称为活锁。比如，一个线程一直在申请其所需要的资源，但是却无法申请成功。</p>
<h5 id="线程饥饿"><a href="#线程饥饿" class="headerlink" title="线程饥饿"></a>线程饥饿</h5><p>线程饥饿是指线程一直无法获得其所需的资源导致任务一直无法运行的情况。线程调度模式有公平调度和非公平调度两种模式。<strong>在线程的非公平调度模式下</strong>，就可能出现线程饥饿的情况。</p>
<h5 id="线程活性故障总结"><a href="#线程活性故障总结" class="headerlink" title="线程活性故障总结"></a>线程活性故障总结</h5><ul>
<li>线程饥饿发生时，如果线程处于可运行状态，也就是其一直在申请资源，那么就会转变为活锁</li>
<li>只要存在一个或多个线程因为获取不到其所需的资源而无法进展就是线程饥饿，所以线程死锁其实也算是线程饥饿</li>
</ul>
<h4 id="原子性，可见性与有序性"><a href="#原子性，可见性与有序性" class="headerlink" title="原子性，可见性与有序性"></a>原子性，可见性与有序性</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>对于涉及到共享变量访问的操作，若该操作从执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，该操作具有原子性。即，其它线程不会“看到”该操作执行了部分的中间结果。</p>
<h5 id="原子性的实现方式"><a href="#原子性的实现方式" class="headerlink" title="原子性的实现方式"></a>原子性的实现方式</h5><ul>
<li>利用<strong>锁的排他性</strong>，保证同一时刻只有一个线程在操作一个共享变量</li>
<li>利用<strong>CAS（Compare And Swap）</strong>保证</li>
<li>Java<strong>语言规范中</strong>，保证了除long和double型以外的任何变量的写操作都是原子操作</li>
<li>Java<strong>语言规范</strong>中又规定，volatile关键字修饰的变量可以保证其写操作的原子性</li>
</ul>
<h5 id="原子性相关的问题"><a href="#原子性相关的问题" class="headerlink" title="原子性相关的问题"></a>原子性相关的问题</h5><ul>
<li>原子性针对的是多个线程的共享变量，所以对于局部变量来说不存在共享问题，也就无所谓是否是原子操作</li>
<li>单线程环境下讨论是否是原子操作没有意义</li>
<li>volatile关键字仅仅能保证变量写操作的原子性，不保证复合操作，比如说读写操作的原子性</li>
</ul>
<h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性是指一个线程对于共享变量的更新，对于后续访问该变量的线程是否可见的问题。</p>
<p>为了阐述可见性问题，我们先来简单介绍<strong>处理器缓存</strong>的概念。</p>
<p>现代处理器处理速度远大于主内存的处理速度，所以在主内存和处理器之间加入了寄存器，高速缓存，写缓冲器以及无效化队列等部件来加速内存的读写操作。也就是说，我们的处理器可以和这些部件进行读写操作的交互，这些部件可以称为处理器缓存。</p>
<p>处理器对内存的读写操作，其实仅仅是与处理器缓存进行了交互。一个处理器的缓存上的内容无法被另外一个处理器读取，所以另外一个处理器必须通过缓存一致性协议来读取的其他处理器缓存中的数据，并且同步到自己的处理器缓存中，这样保证了其余处理器对该变量的更新对于另外处理器是可见的。</p>
<h5 id="单处理器中，为什么也会出现可见性的问题"><a href="#单处理器中，为什么也会出现可见性的问题" class="headerlink" title="单处理器中，为什么也会出现可见性的问题"></a>单处理器中，为什么也会出现可见性的问题</h5><p>单处理器中，由于是多线程并发编程，所以会存在线程的上下文切换，线程会将对变量的更新当作上下文存储起来，导致其余线程无法看到该变量的更新。所以单处理器下的多线程并发编程也会出现可见性问题的。</p>
<h5 id="可见性如何保证"><a href="#可见性如何保证" class="headerlink" title="可见性如何保证"></a>可见性如何保证</h5><ul>
<li>当前处理器需要<strong>刷新处理器缓存</strong>，使得其余处理器对变量所做的更新可以同步到当前的处理器缓存中</li>
<li>当前处理器对共享变量更新之后，需要<strong>冲刷处理器缓存</strong>，使得该更新可以被写入处理器缓存中</li>
</ul>
<h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性是指一个处理器上运行的线程所执行的内存访问操作在另外一个处理器上运行的线程来看是否有序的问题。</p>
<h5 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h5><p>为了提高程序执行的性能，Java编译器在其认为不影响程序正确性的前提下，可能会对源代码顺序进行一定的调整，导致程序运行顺序与源代码顺序不一致。</p>
<p>重排序是对内存读写操作的一种优化，在单线程环境下不会导致程序的正确性问题，但是多线程环境下可能会影响程序的正确性。</p>
<h5 id="重排序举例"><a href="#重排序举例" class="headerlink" title="重排序举例"></a>重排序举例</h5><p><strong>Instance instance = new Instance()都发生了啥？</strong></p>
<p><strong>具体步骤如下所示三步：</strong></p>
<ul>
<li>在堆内存上分配对象的内存空间</li>
<li>在堆内存上初始化对象</li>
<li>设置instance指向刚分配的内存地址</li>
</ul>
<p>第二步和第三步可能会发生重排序，导致引用型变量指向了一个不为null但是也不完整的对象。（<strong>在多线程下的单例模式中，我们必须通过volatile来禁止指令重排序</strong>）</p>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul>
<li><strong>原子性</strong>是一组操作要么完全发生，要么没有发生，其余线程不会看到中间过程的存在。注意，<strong>原子操作+原子操作不一定还是原子操作。</strong></li>
<li><strong>可见性</strong>是指一个线程对共享变量的更新<strong>对于另外一个线程是否可见</strong>的问题。</li>
<li><strong>有序性</strong>是指一个线程对共享变量的更新在其余线程看起来是<strong>按照什么顺序执行</strong>的问题。</li>
<li>可以这么认为，<strong>原子性 + 可见性 -&gt; 有序性</strong></li>
</ul>
<h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p><strong>synchronized是Java中的一个关键字，是一个内部锁</strong>。它可以使用在方法上和方法块上，表示同步方法和同步代码块。在多线程环境下，同步方法或者同步代码块在同一时刻只允许有一个线程在执行，其余线程都在等待获取锁，也就是实现了整体并发中的局部串行。</p>
<h5 id="内部锁底层实现"><a href="#内部锁底层实现" class="headerlink" title="内部锁底层实现"></a>内部锁底层实现</h5><ul>
<li>进入时，执行<strong>monitorenter</strong>，将计数器+1，释放锁<strong>monitorexit</strong>时，计数器-1</li>
<li>当一个线程判断到计数器为0时，则当前锁空闲，可以占用；反之，当前线程进入等待状态</li>
</ul>
<h5 id="synchronized内部锁对原子性的保证："><a href="#synchronized内部锁对原子性的保证：" class="headerlink" title="synchronized内部锁对原子性的保证："></a>synchronized内部锁对原子性的保证：</h5><p>锁通过互斥来保障原子性，互斥是指一个锁一次只能被一个线程所持有，所以，临界区代码只能被一个线程执行，即保障了原子性。</p>
<h5 id="synchronized内部锁对可见性的保证："><a href="#synchronized内部锁对可见性的保证：" class="headerlink" title="synchronized内部锁对可见性的保证："></a>synchronized内部锁对可见性的保证：</h5><p>synchronized内部锁通过写线程<strong>冲刷处理器缓存</strong>和读线程<strong>刷新处理器缓存</strong>保证可见性。</p>
<ul>
<li>获得锁之后，需要<strong>刷新处理器缓存</strong>，使得前面写线程所做的更新可以同步到本线程。</li>
<li>释放锁需要<strong>冲刷处理器缓存</strong>，使得当前线程对共享数据的改变可以被推送到下一个线程处理器的高速缓冲中。</li>
</ul>
<h5 id="synchronized内部锁对有序性的保证："><a href="#synchronized内部锁对有序性的保证：" class="headerlink" title="synchronized内部锁对有序性的保证："></a>synchronized内部锁对有序性的保证：</h5><p>由于原子性和可见性的保证，使得写线程<strong>在临界区中</strong>所执行的一系列操作在读线程所执行的临界区<strong>看起来像是完全按照源代码顺序执行的</strong>，即保证了有序性。</p>
<h5 id="synchronized内部锁使用样例"><a href="#synchronized内部锁使用样例" class="headerlink" title="synchronized内部锁使用样例"></a>synchronized内部锁使用样例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> niuke;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">synchronized</span> (SynchronizedTest.class)&#123;<br>            System.out.println(<span class="hljs-string">&quot;这是一个同步方法块&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;这是一个同步方法，因为在方法上使用了synchronized关键字&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="JVM对资源的调度方式"><a href="#JVM对资源的调度方式" class="headerlink" title="JVM对资源的调度方式"></a>JVM对资源的调度方式</h5><p><strong>JVM对资源的调度分为公平调度和非公平调度方式</strong>。</p>
<p><strong>公平调度方式：</strong></p>
<p>按照<strong>申请的先后顺序</strong>授予资源的独占权。</p>
<p><strong>非公平调度方式：</strong></p>
<p>在该策略中，资源的持有线程释放该资源的时候，等待队列中一个线程会被唤醒，而该线程从被唤醒到其继续执行可能需要一段时间。在该段时间内，<strong>新来的线程（活跃线程）</strong>可以先被授予该资源的独占权。</p>
<p>如果新来的线程占用该资源的时间不长，那么它完全有可能在被唤醒的线程继续执行前释放相应的资源，从而不影响该被唤醒的线程申请资源。</p>
<h5 id="公平调度和非公平调度的优缺点分析"><a href="#公平调度和非公平调度的优缺点分析" class="headerlink" title="公平调度和非公平调度的优缺点分析"></a>公平调度和非公平调度的优缺点分析</h5><p><strong>非公平调度策略：</strong></p>
<ul>
<li>优点：吞吐率较高，单位时间内可以为更多的申请者调配资源</li>
<li>缺点：资源申请者申请资源所需的时间偏差可能较大，并可能出现线程饥饿的现象</li>
</ul>
<p><strong>公平调度策略：</strong></p>
<ul>
<li>优点：线程申请资源所需的时间偏差较小；不会出现线程饥饿的现象；适合在资源的持有线程占用资源的时间相对长或者资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用；</li>
<li>缺点：吞吐率较小</li>
</ul>
<h5 id="JVM对synchronized内部锁的调度："><a href="#JVM对synchronized内部锁的调度：" class="headerlink" title="JVM对synchronized内部锁的调度："></a>JVM对synchronized内部锁的调度：</h5><p>JVM对内部锁的调度是一种<strong>非公平的调度方式</strong>，JVM会给每个内部锁分配一个<strong>入口集（Entry Set）</strong>，用于记录等待获得相应内部锁的线程。当锁被持有的线程释放的时候，该锁的入口集中的任意一个线程将会被唤醒，从而得到再次申请锁的机会。被唤醒的线程等待占用处理器运行时可能还有其他新的活跃线程与该线程抢占这个被释放的锁。</p>
<h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile关键字是一个轻量级的锁，<strong>可以保证可见性和有序性，但是不保证原子性。</strong></p>
<ul>
<li>volatile 可以保证<strong>主内存和工作内存直接产生交互</strong>，进行读写操作，保证可见性</li>
<li>volatile 仅能保证变量<strong>写操作的原子性</strong>，不能保证读写操作的原子性。</li>
<li>volatile可以<strong>禁止指令重排序</strong>（通过插入内存屏障），典型案例是在单例模式中使用。</li>
</ul>
<h5 id="volatile的开销"><a href="#volatile的开销" class="headerlink" title="volatile的开销"></a>volatile的开销</h5><p>volatile不会导致线程上下文切换，但是其读取变量的成本较高，因为其每次都需要从高速缓存或者主内存中读取，无法直接从寄存器中读取变量。</p>
<h5 id="volatile在什么情况下可以替代锁"><a href="#volatile在什么情况下可以替代锁" class="headerlink" title="volatile在什么情况下可以替代锁"></a>volatile在什么情况下可以替代锁</h5><p>volatile是一个轻量级的锁，适合多个线程<strong>共享一个状态变量</strong>，而锁适合多个线程<strong>共享一组状态变量</strong>。可以<strong>将多个线程共享的一组状态变量合并成一个对象</strong>，用一个volatile变量来引用该对象，从而替代锁。</p>
<h4 id="ReentrantLock和synchronized的区别"><a href="#ReentrantLock和synchronized的区别" class="headerlink" title="ReentrantLock和synchronized的区别"></a>ReentrantLock和synchronized的区别</h4><p>ReentrantLock<strong>是显示锁</strong>，其提供了一些内部锁不具备的特性，但并不是内部锁的替代品。<strong>显式锁支持公平和非公平的调度方式</strong>，默认采用非公平调度。</p>
<p>synchronized 内部锁简单，但是不灵活。显示锁支持在一个方法内申请锁，并且在另一个方法里释放锁。<strong>显示锁定义了一个tryLock()方法，尝试去获取锁</strong>，成功返回true，失败并不会导致其执行的线程被暂停而是直接返回false，即可以<strong>避免死锁</strong>。</p>
<h4 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h4><p>java.util.concurrent.ThreadPoolExecutor类就是一个线程池。客户端调用ThreadPoolExecutor.submit(Runnable task)提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有3种形态：</p>
<ul>
<li><strong>当前线程池大小</strong>：表示线程池中实际工作者线程的数量</li>
<li><strong>最大线程池大小（maxinumPoolSize）</strong>：表示线程池中允许存在的工作者线程的数量上限</li>
<li><strong>核心线程大小（corePoolSize ）</strong>：表示一个不大于最大线程池大小的工作者线程数量上限</li>
</ul>
<p><strong>线程池的优势体现如下：</strong></p>
<ul>
<li>线程池可以重复利用已创建的线程，一次创建可以执行多次任务，有效降低线程创建和销毁所造成的资源消耗；</li>
<li>线程池技术使得请求可以快速得到响应，节约了创建线程的时间；</li>
<li>线程的创建需要占用系统内存，消耗系统资源，使用线程池可以更好的管理线程，做到统一分配、调优和监控线程，提高系统的稳定性。</li>
</ul>
<p>创建线程是有开销的，为了重复利用已创建的线程降低线程创建和销毁的消耗，提高资源的利用效率，所以出现了线程池。线程池的参数字段如下所示：</p>
<p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422111547.png" srcset="/img/loading.gif" lazyload alt="图片说明"></p>
<ul>
<li><strong>corePoolSize：核心线程数</strong></li>
<li><strong>maximumPoolSize：最大线程数</strong></li>
<li><strong>keepAliveTime ：线程空闲但是保持不被回收的时间</strong></li>
<li><strong>unit：时间单位</strong></li>
<li><strong>workQueue：存储线程的队列</strong></li>
<li><strong>threadFactory：创建线程的工厂</strong></li>
<li><strong>handler：拒绝策略</strong></li>
</ul>
<h5 id="线程池的排队策略"><a href="#线程池的排队策略" class="headerlink" title="线程池的排队策略"></a>线程池的排队策略</h5><p>当我们向线程池提交任务的时候，需要遵循一定的排队策略，具体策略如下：</p>
<ul>
<li>如果运行的线程少于corePoolSize，则Executor始终首选添加新的线程，而不进行排队</li>
<li>如果运行的线程等于或者多于corePoolSize，则Executor始终首选将请求加入队列，而不是添加新线程</li>
<li>如果无法将请求加入队列，即队列已经满了，则创建新的线程，除非创建此线程超出maxinumPoolSize，在这种情况下，任务默认将被拒绝。</li>
</ul>
<h5 id="常见的线程池类型："><a href="#常见的线程池类型：" class="headerlink" title="常见的线程池类型："></a>常见的线程池类型：</h5><p><strong>newCachedThreadPool( )</strong></p>
<ul>
<li>核心线程池大小为0，最大线程池大小不受限，来一个创建一个线程</li>
<li>适合用来执行大量耗时较短且提交频率较高的任务</li>
</ul>
<p><strong>newFixedThreadPool( )</strong></p>
<ul>
<li>固定大小的线程池</li>
<li>当线程池大小达到核心线程池大小，就不会增加也不会减小工作者线程的固定大小的线程池</li>
</ul>
<p><strong>newSingleThreadExecutor( )</strong></p>
<ul>
<li>便于实现单（多）生产者-消费者模式</li>
</ul>
<h5 id="常见的阻塞队列"><a href="#常见的阻塞队列" class="headerlink" title="常见的阻塞队列"></a>常见的阻塞队列</h5><p>前面我们介绍了线程池内部有一个排队策略，任务可能需要在队列中进行排队等候。常见的阻塞队列包括如下的三种，接下来我们一起来看看吧。</p>
<p><strong>ArrayBlockingQueue:</strong></p>
<ul>
<li>内部使用一个<strong>数组</strong>作为其存储空间，数组的存储空间是<strong>预先分配</strong>的</li>
<li><strong>优点是</strong> put 和 take操作不会增加GC的负担（因为空间是预先分配的）</li>
<li><strong>缺点是</strong> put 和 take操作使用同一个锁，可能导致锁争用，导致较多的上下文切换。</li>
<li>ArrayBlockingQueue适合在生产者线程和消费者线程之间的<strong>并发程序较低</strong>的情况下使用。</li>
</ul>
<p><strong>LinkedBlockingQueue：</strong></p>
<ul>
<li>是一个无界队列（其实队列长度是Integer.MAX_VALUE）</li>
<li>内部存储空间是一个<strong>链表</strong>，并且链表节点所需的<strong>存储空间是动态分配</strong>的</li>
<li><strong>优点是</strong> put 和 take 操作使用两个显式锁（putLock和takeLock）</li>
<li><strong>缺点是</strong>增加了GC的负担，因为空间是动态分配的。</li>
<li>LinkedBlockingQueue适合在生产者线程和消费者线程之间的并发程序较高的情况下使用。</li>
</ul>
<p><strong>SynchronousQueue：</strong></p>
<ul>
<li>SynchronousQueue可以被看做一种特殊的有界队列。生产者线程生产一个产品之后，会等待消费者线程来取走这个产品，才会接着生产下一个产品，适合在生产者线程和消费者线程之间的处理能力相差不大的情况下使用。</li>
</ul>
<p>我们前边介绍<strong>newCachedThreadPool时候说，这个线程池来一个线程就创建一个，这是因为其内部队列使用了SynchronousQueue，所以不存在排队。</strong></p>
<h5 id="关于线程池，应该知道的事："><a href="#关于线程池，应该知道的事：" class="headerlink" title="关于线程池，应该知道的事："></a>关于线程池，应该知道的事：</h5><ul>
<li>使用JDK提供的<strong>快捷方式</strong>创建线程池，比如说newCachedThreadPool会出现一些内存溢出的问题，因为<strong>队列可以被塞入很多任务</strong>。所以，大多数情况下，我们<strong>都应该自定义线程池。</strong></li>
<li>线程池提供了一些<strong>监控API</strong>，可以很方便的监控当前以及塞进队列的任务数以及当前线程池已经完成的任务数等。</li>
</ul>
<h4 id="CountDownLatch和CyclicBarrier"><a href="#CountDownLatch和CyclicBarrier" class="headerlink" title="CountDownLatch和CyclicBarrier"></a>CountDownLatch和CyclicBarrier</h4><p><strong>CountDownLatch</strong>是一个<strong>倒计时协调器</strong>，它可以实现一个或者多个线程等待其余线程完成一组特定的操作之后，继续运行。</p>
<p><strong>CountDownLatch的内部实现如下：</strong></p>
<ul>
<li><strong>CountDownLatch</strong>内部维护一个计数器，CountDownLatch.countDown()每被执行一次都会使计数器值减少1。</li>
<li><strong>当计数器不为0时</strong>，CountDownLatch.await()方法的调用将会导致执行线程被暂停，这些线程就叫做该CountDownLatch上的等待线程。</li>
<li>CountDownLatch.countDown()相当于一个通知方法，<strong>当计数器值达到0时</strong>，唤醒所有等待线程。当然对应还有指定等待时间长度的CountDownLatch.await(long , TimeUnit)方法。</li>
</ul>
<p><strong>CyclicBarrier</strong>是<strong>一个栅栏</strong>，可以实现多个线程相互等待执行到指定的地点，这时候这些线程会再接着执行，在实际工作中可以用来<strong>模拟高并发请求测试</strong>。</p>
<p><strong>可以认为是这样的</strong>，当我们爬山的时候，到了一个平坦处，前面队伍会稍作休息，等待后边队伍跟上来，当最后一个爬山伙伴也达到该休息地点时，所有人同时开始从该地点出发，继续爬山。</p>
<p><strong>CyclicBarrier的内部实现如下：</strong></p>
<ul>
<li>使用CyclicBarrier实现等待的线程被称为<strong>参与方（Party）</strong>，参与方只需要执行CyclicBarrier.await（）就可以实现等待，<strong>该栅栏维护了一个显示锁</strong>，可以识别出最后一个参与方，<strong>当最后一个参与方调用await（）方法时</strong>，前面等待的参与方都会被唤醒，并且该最后一个参与方也不会被暂停。</li>
<li><strong>CyclicBarrier内部维护了一个计数器变量count = 参与方的个数</strong>，调用await方法可以使得count -1。<strong>当判断到是最后一个参与方时</strong>，调用singalAll唤醒所有线程。</li>
</ul>
<h4 id="TreadLocal"><a href="#TreadLocal" class="headerlink" title="TreadLocal"></a>TreadLocal</h4><p>使用ThreadLocal维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。</p>
<p><strong>ThreadLocal内部实现机制：</strong></p>
<ul>
<li>每个线程内部都会维护一个类似HashMap的对象，称为<strong>ThreadLocalMap</strong>，里边会包含若干了<strong>Entry（K-V键值对）</strong>，相应的线程被称为这些Entry的属主线程</li>
<li><strong>Entry的Key是一个ThreadLocal实例，Value是一个线程特有对象</strong>。Entry的作用是为其属主线程建立起一个ThreadLocal实例与一个线程特有对象之间的对应关系</li>
<li>Entry对Key的引用是弱引用；Entry对Value的引用是强引用。</li>
</ul>
<h4 id="Atmoic"><a href="#Atmoic" class="headerlink" title="Atmoic"></a>Atmoic</h4><h5 id="i-操作是线程安全的吗？"><a href="#i-操作是线程安全的吗？" class="headerlink" title="i++操作是线程安全的吗？"></a>i++操作是线程安全的吗？</h5><p>i++操作并不是线程安全的，它是一个复合操作，包含三个步骤：</p>
<ul>
<li><strong>拷贝i的值到临时变量</strong></li>
<li><strong>临时变量++操作</strong></li>
<li><strong>拷贝回原始变量i</strong></li>
</ul>
<p>这是一个<strong>复合操作，不能保证原子性</strong>，所以这不是线程安全的操作。<strong>那么如何实现原子自增等操作呢？</strong></p>
<p>这里就用到了JDK在java.util.concurrent.atomic包下的AtomicInteger等原子类了。<strong>AtomicInteger类提供了getAndIncrement和incrementAndGet等原子性的自增自减等操作</strong>。<strong>Atomic等原子类内部使用了CAS来保证原子性。</strong></p>
<p>接下来，我们来看代码吧，首先是使用变量i的情况：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; <span class="hljs-number">1000000</span>; m++) &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ThreadTest mt = <span class="hljs-keyword">new</span> ThreadTest();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(mt);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(mt);<br>        t1.start();<br>        t2.start();<br>        <span class="hljs-comment">// 休眠一下，让线程执行完毕。</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        System.out.println(ThreadTest.i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该程序的输出是不确定的，比如输出1933446，也就是线程不安全，发生了竟态导致计算结果有误。</p>
<p>当我们使用了<strong>Atomic等原子类</strong>时，会发现每次输出结果都是2000000，符合我们的程序设计要求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; <span class="hljs-number">1000000</span>; m++) &#123;<br>            i.getAndIncrement();<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ThreadTest mt = <span class="hljs-keyword">new</span> ThreadTest();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(mt);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(mt);<br>        t1.start();<br>        t2.start();<br>        <span class="hljs-comment">// 休眠一下，让线程执行完毕。</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        System.out.println(ThreadTest.i.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="happened-before原则"><a href="#happened-before原则" class="headerlink" title="happened-before原则"></a>happened-before原则</h4><p>前一个操作的执行结果必须对后一个操作可见。</p>
<p>这里的happened-before并不是前一个操作必须早于后一个操作，而是前一个操作必须对后一个操作可见，否则不能重排序。</p>
<p>具体的八个hb原则：</p>
<ol>
<li><p>单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。<br>首先是单线程的 HB ，前面的操作产生的结果必须对后面的操作可见。而不是前面的操作必须先于后面的操作执行，比如按照 as-if-serial 语义，没有数据依赖的两条指令是可以进行重排序的。而这种情况对于 HB 原则来说，因为两条指令都没有产生对方需要的结果，而不需要对对方可见，及时执行顺序被调转也是符合 HB 原则的。</p>
</li>
<li><p>锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。<br>个人理解强调的是解锁操作在多线程环境的可见性。一个线程进行了解锁操作，对于晚于该操作的加锁操作必须能够及时感应到锁的状态变化。解锁操作的结果对后面的加锁操作一定是可见的，无论两个是否在一个线程。</p>
</li>
<li><p>volatile的happen-before原则： 对一个volatile变量的写操作happen-before对此变量的任意操作。<br>对 volatile 变量的写操作的结果对于发生于其后的任何操作的结果都是可见的。x86 架构下volatile 通过内存屏障和缓存一致性协议实现了变量在多核心之间的一致性。</p>
</li>
<li><p>happen-before的传递性原则：  如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。<br>HB 可以说是两项操作之间的<strong>偏序关系</strong>，满足偏序关系的各项性质，我们都知道偏序关系中有一条很重要的性质：传递性，所以Happens-Before也满足传递性。这个性质非常重要，通过这个性质可以推导出两个没有直接联系的操作之间存在Happens-Before关系</p>
</li>
<li><p>线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。<br>start 放法与其它方法可能并没有数据依赖关系，但是显而易见的，为了程序的正确性，我们必须做到这一点。start 方法造成的函数副作用必须对其它方法可见。</p>
</li>
<li><p>线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。<br>interrupt 方法改变的状态必须对后续执行的检测方法可见。</p>
</li>
<li><p>线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。<br>为了安全的关闭线程，线程中的方法造成的函数副作用必须对线程关闭方法可见。</p>
</li>
<li><p>对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。<br>单线程下对象的创建于销毁存在数据依赖，该条原则强调的是多线程情况下对象初始化的结果必须对发生于其后的对象销毁方法可见。</p>
</li>
</ol>
<h4 id="JVM对内部锁有哪些优化"><a href="#JVM对内部锁有哪些优化" class="headerlink" title="JVM对内部锁有哪些优化"></a>JVM对内部锁有哪些优化</h4><p>优化主要包括锁消除（Lock Elision）、锁粗化（Lock Coarsening）、偏向锁（Biased Locking）以及适应性锁（Adaptive Locking）。</p>
<h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除（Lock Elision）是JIT编译器对内部锁的具体实现所做的一种优化。</p>
<p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422145850.png" srcset="/img/loading.gif" lazyload alt="face/TF2SkMAAKFfj7TSWrrC5QaiDSaCswn6T.png"></p>
<p>在动态编译同步块的时候，JIT编译器可以借助一种被称为逃逸分析（Escape Analysis）的技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候并不生成synchronized所表示的锁的申请与释放对应的机器码，而仅生成原临界区代码对应的机器码，这就造成了被动态编译的字节码就像是不包含monitorenter（申请锁）和monitorexit（释放锁）这两个字节码指令一样，即消除了锁的使用。这种编译器优化就被称为锁消除（Lock Elision），它使得特定情况下我们可以完全消除锁的开销。</p>
<p>锁消除优化能否被实施还取决于被调用的同步方法（或者带同步块的方法）是否能够被内联。</p>
<p>因为锁消除是JIT编译器而不是javac所做的一种优化，而一段代码只有在其被执行的频率足够大的情况下才有可能会被JIT编译器优化。也就是说在JIT编译器优化介入之前，只要源代码中使用了内部锁，那么这个锁的开销就会存在。另外，JIT编译器所执行的内联优化、逃逸分析以及锁消除优化本身都是有其开销的。</p>
<p>在锁消除的作用下，利用ThreadLocal将一个线程安全的对象（比如Random）作为一个线程特有对象来使用，不仅仅可以避免锁的争用，还可以彻底消除这些对象内部所使用的锁的开销。</p>
<h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>锁粗化（Lock Coarsening/Lock Merging）是JIT编译器对内部锁的具体实现所做的一种优化。</p>
<p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422150246.png" srcset="/img/loading.gif" lazyload alt="face/ENSjarckiW474mpxyhEjFNsRAR2XNtm4.png"></p>
<p>对于相邻的几个同步块，如果这些同步块使用的是同一个锁实例，那么JIT编译器会将这些同步块合并为一个大同步块，从而避免了一个线程反复申请、释放同一个锁所导致的开销。然而，锁粗化可能导致一个线程持续持有一个锁的时间变长，从而使得同步在该锁之上的其他线程在申请锁时的等待时间变长。例如上图中，第1个同步块结束和第2个同步块开始之间的时间间隙中，其他线程本来是有机会获得monitorX的，但是经过锁粗化之后由于临界区的长度变长，这些线程在申请monitorX时所需的等待时间也相应变长了。因此，锁粗化不会被应用到循环体内的相邻同步块。</p>
<p>相邻的两个同步块之间如果存在其他语句，也不一定就会阻碍JIT编译器执行锁粗化优化，这是因为JIT编译器可能在执行锁粗化优化前将这些语句挪到（即指令重排序）后一个同步块的临界区之中（当然，JIT编译器并不会将临界区内的代码挪到临界区之外）。</p>
<p>实际上，我们写的代码中可能很少会出现上图中那种连续的同步块。这种同一个锁实例引导的相邻同步块往往是JIT编译器编译之后形成的。</p>
<p>锁粗化默认是开启的。</p>
<h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁（Biased Locking）是Java虚拟机对锁的实现所做的一种优化。这种优化基于这样的观测结果（Observation）：大多数锁并没有被争用（Contented），并且这些锁在其整个生命周期内至多只会被一个线程持有。然而，Java虚拟机在实现monitorenter字节码（申请锁）和monitorexit字节码（释放锁）时需要借助一个原子操作（CAS操作），这个操作代价相对来说比较昂贵。因此，Java虚拟机会为每个对象维护一个偏好（Bias），即一个对象对应的内部锁第1次被一个线程获得，那么这个线程就会被记录为该对象的偏好线程（Biased Thread）。这个线程后续无论是再次申请该锁还是释放该锁，都无须借助原先（指未实施偏向锁优化前）昂贵的原子操作，从而减少了锁的申请与释放的开销。</p>
<p>然而，一个锁没有被争用并不代表仅仅只有一个线程访问该锁，当一个对象的偏好线程以外的其他线程申请该对象的内部锁时，Java虚拟机需要收回（Revoke）该对象对原偏好线程的“偏好”并重新设置该对象的偏好线程。这个偏好收回和重新分配过程的代价也是比较昂贵的，因此如果程序运行过程中存在比较多的锁争用的情况，那么这种偏好收回和重新分配的代价便会被放大。有鉴于此，偏向锁优化只适合于存在相当大一部分锁并没有被争用的系统之中。如果系统中存在大量被争用的锁而没有被争用的锁仅占极小的部分，那么我们可以考虑关闭偏向锁优化。</p>
<p>偏向锁优化默认是开启的。</p>
<h5 id="适应性锁"><a href="#适应性锁" class="headerlink" title="适应性锁"></a>适应性锁</h5><p>适应性锁（Adaptive Locking，也被称为 Adaptive Spinning ）是JIT编译器对内部锁实现所做的一种优化。</p>
<p>存在锁争用的情况下，一个线程申请一个锁的时候如果这个锁恰好被其他线程持有，那么这个线程就需要等待该锁被其持有线程释放。实现这种等待的一种保守方法——将这个线程暂停（线程的生命周期状态变为非Runnable状态）。由于暂停线程会导致上下文切换，因此对于一个具体锁实例来说，这种实现策略比较适合于系统中绝大多数线程对该锁的持有时间较长的场景，这样才能够抵消上下文切换的开销。另外一种实现方法就是采用忙等（Busy Wait）。所谓忙等相当于如下代码所示的一个循环体为空的循环语句：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当锁被其他线程持有时一直循环 </span><br><span class="hljs-keyword">while</span> (lockIsHeldByOtherThread)&#123;&#125;<br></code></pre></td></tr></table></figure>
<p>可见，忙等是通过反复执行空操作（什么也不做）直到所需的条件成立为止而实现等待的。这种策略的好处是不会导致上下文切换，缺点是比较耗费处理器资源——如果所需的条件在相当长时间内未能成立，那么忙等的循环就会一直被执行。因此，对于一个具体的锁实例来说，忙等策略比较适合于绝大多数线程对该锁的持有时间较短的场景，这样能够避免过多的处理器时间开销。</p>
<p>事实上，Java虚拟机也不是非要在上述两种实现策略之中择其一 ——它可以综合使用上述两种策略。对于一个具体的锁实例，Java虚拟机会根据其运行过程中收集到的信息来判断这个锁是属于被线程持有时间“较长”的还是“较短”的。对于被线程持有时间“较长”的锁，Java虚拟机会选用暂停等待策略；而对于被线程持有时间“较短”的锁，Java虚拟机会选用忙等等待策略。Java虚拟机也可能先采用忙等等待策略，在忙等失败的情况下再采用暂停等待策略。Java虚拟机的这种优化就被称为适应性锁（Adaptive Locking），这种优化同样也需要JIT编译器介入。</p>
<p>适应性锁优化可以是以具体的一个锁实例为基础的。也就是说，Java虚拟机可能对一个锁实例采用忙等等待策略，而对另外一个锁实例采用暂停等待策略。</p>
<h4 id="如何进行无锁化编程"><a href="#如何进行无锁化编程" class="headerlink" title="如何进行无锁化编程"></a>如何进行无锁化编程</h4><h5 id="无锁的特点"><a href="#无锁的特点" class="headerlink" title="无锁的特点"></a>无锁的特点</h5><ol>
<li>无障碍的；</li>
<li>保证有一个线程胜出；</li>
<li>如果临界区的某个线程在每次竞争中都无法胜出那么该线程即将被饿死。</li>
</ol>
<h5 id="CAS-Compare-And-Swap-Set-比较交换算法"><a href="#CAS-Compare-And-Swap-Set-比较交换算法" class="headerlink" title="CAS(Compare And Swap/Set)比较交换算法"></a>CAS(Compare And Swap/Set)比较交换算法</h5><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论如何，CAS最后会返回当前V的真实值。CAS操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p>
<p>CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</p>
<h5 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h5><p>sun.misc.Unsafe是JDK内部用的工具类。它通过暴露一些Java意义上说“不安全”的功能给Java层代码，来让JDK能够更多的使用Java代码来实现一些原本是平台相关的、需要使用native语言（例如C或C++）才可以实现的功能。该类不应该在JDK核心类库之外使用。</p>
<h5 id="Java中的无锁类"><a href="#Java中的无锁类" class="headerlink" title="Java中的无锁类"></a>Java中的无锁类</h5><ul>
<li>AtomicInteger<br>AtomicInteger和Integer一样，都继承与Number类。当然还有AtomicBoolean，AtomicLong等等，都大同小异。</li>
<li>AtomicReference<br>AtomicReference是一种模板类，它可以用来封装任意类型的数据。</li>
<li>AtomicStampedReference<br>CAS操作带来的ABA问题。ABA在一些敏感的场合是不适合的，比如个一个账户充了10块钱，又消费了10元，随后又充值了10元，虽然该账户最余额是10元但不能说该账户没有消费。因为CAS在比操作值得时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，中间变成B，最后又变成A，那么使用CAS进行检查时会发现值没有发生变化，但是实际上是变化了的。解决思路就是添加版本号。 JDK1.5之后，Atomic包提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。其内部实现一个Pair类来封装值和时间戳。<br>这个类的主要思想是加入时间戳来标识每一次改变。当期望值等于当前值，并且期望时间戳等于现在的时间戳时，才写入新值，并且更新新的时间戳。</li>
</ul>
<h5 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h5><ol>
<li>CPU开销过大<br>在并发量比较高的时候，如果许多线程都尝试去更新一个变量的值，却又一直比较失败，导致提交失败，产生自旋，循环往复，会对CPU造成很大的压力和开销。</li>
<li>不能确保代码块的原子性（注意是代码块）<br>CAS机制所确保的是一个变量的原子性操作，而不能保证整个代码块的原子性，比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized或者lock了。</li>
<li>ABA问题</li>
</ol>
<h5 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h5><p>AQS又称为队列同步器，用来构建锁或其他同步组件的基础框架。 内部通过一个int成员变量state来控制同步状态，当state = 0时，说明没有任何线程占有共享资源的锁； state = 1时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待，当然state也可以继续执行+1操作，比如可重入锁。AQS同步器的实现依赖于内部的同步队列(FIFO的双向链表队列)完成对同步状态(state)的管理，当前线程获取锁(同步状态)失败时，AQS会将该线程以及相关等待信息包装成 一个节点(Node)并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会将头结点head中的线 程唤醒，让其尝试获取同步状态。简单来说，就是同步状态state和同步队列。ReentrantLock锁就是使用了AQS 来控制同步状态。</p>

            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a>
                    
                      <a class="hover-with-bg" href="/tags/Java/">Java</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均采用 <a target="_blank" href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" rel="nofollow noopener noopener">CC BY-SA 4.0 协议</a> ，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/04/22/jvm%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">jvm内存机制</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/04/22/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/">
                        <span class="hidden-mobile">Java基础部分</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  <script  src="/js/local-search.js" ></script>



  
    <script  src="/js/img-lazyload.js" ></script>
  



  



  
    <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>
  
  
    <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>
  
  
    <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>
  



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var title = document.getElementById('subtitle').title;
      
      typing(title)
      
    })(window, document);
  </script>















<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>


</body>
</html>
