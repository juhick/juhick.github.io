---
title: 子序列宽度之和
date: 2022-11-18 11:45:47
tags:
 - leetcode
 - 数学
categories:
 - leetcode
math: true
---

# 子序列宽度值之和

[原题链接](https://leetcode.cn/problems/sum-of-subsequence-widths/)

## 解题思路

对于每个子序列而言，设其最大值为$max$，最小值为$min$，则子序列对最后结果的贡献为$(max - min)$。

若某个数$nums[i]$为最大值参与的子序列数为$m$个，则其对结果的贡献为$nums[i]*m$

若某个数$nums[i]$为最小值参与的子序列数为$n$个，则其对结果的贡献为$-nums[i]*n$

因此，我们只需要求出$nums[i]$作为最大值和最小值的次数即可求出其对答案的贡献为$(m - n) * nums[i]$，将所有的结果累加即为最终结果

### 求出$nums[i]$作为最值时，有多少个子序列

当$nums[i]$作为序列最小值时，设比它大的数有$k$个，则可以构成的子序列数为$2^k$个。

同理，作为序列最大值时只需考虑比它小的数，即可求得子序列个数。

### $2^k$重复计算问题

在计算过程中会有许多相同的$2^k$被计算，所以最好预先计算出会使用的$2^k$保存。

<!-- more -->

## 代码

~~~cpp
class Solution {
public:
    int sumSubseqWidths(vector<int>& nums) {
        static long long N = 100010, MOD = 1e9 + 7;
        long long p[N];
        p[0] = 1;
        for (int i = 1; i < N; ++i){
            p[i] = p[i - 1] * 2 % MOD;
        }
        int n = nums.size();
        long long ans = 0;
        sort(nums.begin(), nums.end());
        for (int i = 0; i < n; ++i) {
            ans += (p[i] * nums[i]) % MOD;
            ans %= MOD;
            ans -= (p[n - i - 1] * nums[i]) % MOD;
            ans %= MOD;
        }
        return (int)ans;
    }
};
~~~

