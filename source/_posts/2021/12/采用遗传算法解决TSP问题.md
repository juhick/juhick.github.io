---
title: 采用遗传算法解决TSP问题
date: 2021-12-08 21:48:00
tags:
 - 遗传算法
 - TSP问题
categories:
 - 人工智能算法
math: true
---

# 求解过程

## 数据预处理

首先读取出每个城市的**坐标信息**，并计算出每两个城市之间的**直线距离**：

```python
def read_array():
    data = np.loadtxt('data.txt')
    city_name = data[:, 0]
    city_point = data[:, 1:]
    city_count = len(city_name)
    distance = np.zeros([city_count, city_count])
    for i in range(city_count):
        for j in range(city_count):
            distance[i][j] = math.sqrt((city_point[i][0] - city_point[j][0]) ** 2 +
                                       (city_point[i][1] - city_point[j][1]) ** 2)

    return city_count, distance
```

<!-- more -->

## 种群初始化

进行初期的优秀个体的选择，先**随机生成**指定个数的个体。

然后对每一个个体进行指定次数的**改良圈算法**，取得**较好**的个体

改良圈算法即每次随机选择个体中的两个相异城市`u`和`v`，如果交换这两个城市能够取得**更好的适应度**（即更小的总距离），则交换这两个城市，重复改良操作指定次数得到多个较好的个体。具体的改良圈算法如下：

```python
def improve(x):
    i = 0
    while i < improve_count:
        # 生成指定范围的两个整数
        u = random.randint(0, len(x) - 2)
        v = random.randint(u + 1, len(x) - 1)
        # 如果倒序区间内的路径可以取得更好的路径时，更新路径
        if Distance[u - 1][v] + Distance[u][v + 1] < Distance[u - 1][u] + Distance[v][v + 1]:
            t = x[u]
            x[u] = x[v]
            x[v] = t
        i += 1
    return x
```

初始化的全过程：

```python
population = []
for i in range(count):
    # 随机生成个体
    x = index.copy()
    # 打乱顺序
    random.shuffle(x)
    # 改良圈算法优化种群
    x = improve(x)
    # 把每个个体逐个添加到种群里
    population.append(x)
```

## 自然选择

在遗传学中，适应度是指个体对自然环境的适应程度，自然选择过程中需要根据适者生存的原则保存优秀的个体，淘汰不适应环境的个体。

在TSP问题中，适应度即为一个个体的总距离。

若当前城市为最后一个城市，则总距离加上回到起点的距离，否则加上当前城市与下一城市之间的距离。

计算单个个体总距离的代码如下：

```python
def get_total_distance(x):
    distance = 0
    # 距离矩阵中第一个点到这个个体的第一个点的距离
    distance += Distance[origin][x[0]]
    for i in range(len(x)):
        if i == len(x) - 1:
            # 从终点回到起点
            distance += Distance[origin][x[i]]
        else:
            distance += Distance[x[i]][x[i + 1]]
    return distance
```

总距离越小越符合我们的要求，所以按照**总距离的升序**排序即为**适应度**从大到小的顺序。

首先根据**适者生存**的原则，选择指定比例适应度高的个体**直接生存**，然后采用**轮盘赌法**选择一定数量的个体。

轮盘赌法的具体流程如下：

1.   计算出种群中每个个体的**适应度**$f(i=1,2,...,\text{M})$，$\text{M}$为**种群大小**，即种群中个体的个数。

2.   计算出每个个体被遗传到下一代群体中的概率，即
     $$
     p(i)=个体适应度/种群总适应度
     $$

3.   计算每个个体的**累计概率**，即
     $$
     \begin{align}
     q(1) & =p(1) \\
     q(2) & =p(1)+p(2) \\
     & ... \\
     q(n) & =p(1)+p(2)+...+p(n)\\
     \end{align}
     $$

4.   在$[0,1]$区间内生成一个均匀分布的伪随机数$\text{r}$

5.   若$\text{r}<q[1]$，则选择个体1，否则，选择个体$\text{k}$，使得：$q[k-1]<r\leq q[k]$成立

6.   **重复4、5共$\text{M}$次**

轮盘赌的代码如下：

```python
# 轮盘赌
def roulette(population):
    q = []
    p = []

    # 计算每个个体被遗传到下一代群体中的概率
    for item in population:
        p.append(get_total_distance(item))
    p /= sum(p)

    # 计算每个个体的累计概率
    cur = 0
    for i in p:
        cur += i
        q.append(cur)

    choices = []
    for i in range(count):
        rate = random.random()
        for _, j in enumerate(q):
            if rate <= j:
                choices.append(_)
    return choices
```

## 交叉

>   交叉是指每一个个体是由父亲和母亲两个个体繁殖产生，子代个体的 DNA（二进制串） 获得了一半父亲的 DNA，一半母亲的 DNA，但是这里的一半并不是真正的一半，这个位置叫做交配点，是**随机产生**的，可以是染色体的任意位置。

总的来说，交叉是一个种群中，不同个体的**部分信息交换**。传统的交叉有**单点交叉**、**双点交叉**以及**部分匹配交叉**。

在该问题中采取的是**次序交叉法**。

**交叉结束后需要保持种群规模稳定，即种群的总个体数是不变的。**

次序杂交算法首先**随机**地在双亲中选择**两个杂交点**，再**交换杂交段**，其他位置根据双亲城市的**相对位置**确定。

具体代码如下：

```python
# 交叉繁殖
def crossover(parents):
    # 生成的子代的个数，以此保证种群稳定，即总种群数是不变的
    target_count = count - len(parents)
    # 子代列表
    children = []
    while len(children) < target_count:
        # 随机选择父母
        male_index, female_index = random.sample(range(0, len(parents) - 1), 2)
        male = parents[male_index]
        female = parents[female_index]

        left = random.randint(0, len(male) - 2)
        right = random.randint(left + 1, len(male) - 1)

        # 交叉片段
        # 此处的交叉过程参照pdf
        gene1 = male[left:right]
        gene2 = female[left:right]

        # 转换附带染色体的顺序得到亚父代
        child1_c = male[right:] + male[:right]
        child2_c = female[right:] + female[:right]
        child1 = child1_c.copy()
        child2 = child2_c.copy()

        # 去掉交叉片段
        for o in gene2:
            child1_c.remove(o)

        for o in gene1:
            child2_c.remove(o)

        # 插入交叉片段
        child1[left:right] = gene2
        child2[left:right] = gene1

        # 填入原来的片段
        child1[right:] = child1_c[0:len(child1) - right]
        child1[:left] = child1_c[len(child1) - right:]

        child2[right:] = child2_c[0:len(child2) - right]
        child2[:left] = child2_c[len(child2) - right:]

        children.append(child1)
        children.append(child2)

    return children
```

## 变异

变异是对种群选定个体的操作。

遍历种群中的每一个个体，生成$[0,1]$范围内均匀分布的伪随机数，如果随机数**小于给定的变异率**，则该个体执行变异操作。

变异操作的具体操作为：在染色体中随机地取三个整数，满足$1<u<v<w<城市数$，把`u`和`v`之间的（包括`u`和`v`）的基因段插到`w`后面。

具体操作如下：

```python
# 变异
def mutation(children):
    for i in range(len(children)):
        # 满足条件才变异
        if random.random() < mutation_rate:
            child = children[i]
            u = random.randint(1, len(child) - 4)
            v = random.randint(u + 1, len(child) - 3)
            w = random.randint(v + 1, len(child) - 2)
            # 第二和第三段互换
            child = child[0:u] + child[v:w] + child[u:v] + child[w:]
```

# 问题解答

## 遗传算法求解TSP问题的流程图

![1](https://raw.githubusercontent.com/juhick/picJuhick/master/2021/12/20211209161208.png)

## 不同规模的TSP问题的算法性能

城市数量规模越大或种群规模越大或迭代次数越大，运行时间就越长。

城市规模越大，每次迭代所用的时间越长，获取最优解的时间也越长，当城市规模大到一定程度时，遗传算法的求解性能优于广度/宽度优先搜索算法，耗时远小于一般的搜索算法。

种群规模越大每次迭代耗时越长，迭代次数越大则总时间越长，同时这两个指标的增大也会提高结果的精确度。

**实验次数：14**

**最大迭代次数：500**

**变异概率：0.1**

**强者生存率：0.2**

**改良次数：500**

| 城市个数 | 时间（ms） |
| :------: | :--------: |
|    10    |   10422    |
|    15    |   11600    |
|    20    |   12886    |
|    25    |   14014    |
|    30    |   15411    |
|    35    |   16483    |
|    40    |   17537    |
|    45    |   18811    |
|    50    |   20527    |
|    55    |   21406    |
|    60    |   22610    |
|    65    |   23363    |
|    70    |   24433    |
|    75    |   25549    |

![image-20211209193559091](https://raw.githubusercontent.com/juhick/picJuhick/master/2021/12/20211209193559.png)

由图中可以看出，遗传算法的**执行时间随着$TSP$问题规模的增大而增大**，并且大致为线性增长



## 同一个 TSP 问题，种群规模、交叉概率和变异概率对算法结果的影响

1.   种群规模对结果的影响：种群规模越大算法结果越精确，适应度越好，但是运行时间越长。

     |  x   | 0    | 1.1  | 3.5  | 3    | 7    | 8    | 4    | 4.5  | 9    | 2    |
     | :--: | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
     |  y   | 1.1  | 3    | 2    | 4    | 5.1  | 8    | 4    | 4.5  | 9    | 2    |

     **实验次数：10**
     **最大迭代步数：100**
     **变异概率：0.1**
     **强者生存率：0.2**
     **改良次数：500**

     | 种群规模 |     最好适应度     |            最优路径            |
     | :------: | :----------------: | :----------------------------: |
     |    10    | 26.75325227412243  | [0, 3, 5, 8, 4, 7, 6, 2, 9, 1] |
     |    20    | 25.165169218366618 | [0, 9, 2, 4, 8, 5, 7, 6, 3, 1] |
     |    30    | 26.976241673343697 | [0, 3, 4, 5, 8, 7, 6, 2, 9, 1] |
     |    50    | 26.788575223880752 | [0, 3, 6, 7, 4, 8, 5, 2, 9, 1] |
     |    80    | 25.165169218366618 | [0, 9, 2, 4, 8, 5, 7, 6, 3, 1] |
     |   100    |  25.6205952507828  | [0, 1, 3, 7, 5, 8, 4, 6, 2, 9] |
     |   150    | 25.165169218366618 | [0, 9, 2, 4, 8, 5, 7, 6, 3, 1] |
     |   200    | 25.165169218366618 | [0, 9, 2, 4, 8, 5, 7, 6, 3, 1] |
     |   250    | 25.165169218366618 | [0, 9, 2, 4, 5, 8, 7, 6, 3, 1] |
     |   300    | 25.165169218366618 | [0, 1, 3, 6, 7, 5, 8, 4, 2, 9] |

     从表中可以得知，**种群规模越大，越容易找到最优解**

2.   交叉概率对结果的影响：交叉概率过低得不到最优解，交叉概率越高则平均适应度越好。

     | x    | 9    | 1.1  | 3.5  | 3.5  | 7    | 8    | 4    | 4.5  | 3    | 2    |
     | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
     | y    | 1.1  | 3    | 1    | 4    | 5.1  | 3    | 1    | 8.5  | 9    | 1    |

     **实验次数：20**
     **种群规模：25**
     **最大迭代步数：100**
     **变异概率：0.1**
     **改良次数：500**

     | 交叉概率 | 最好适应度 | 最差适应度 |             最优解             |
     | :------: | :--------: | :--------: | :----------------------------: |
     |  0.001   |  28.0447   |  36.6567   | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] |
     |   0.01   |  27.0935   |  34.9943   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |
     |   0.1    |  28.0447   |  35.3033   | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] |
     |   0.15   |  28.0447   |  34.1175   | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] |
     |   0.2    |  28.7108   |  33.9512   | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] |
     |   0.25   |  28.0447   |  35.1623   | [0, 6, 2, 9, 1, 3, 7, 8, 4, 5] |
     |   0.3    |  27.0935   |  31.9941   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |
     |   0.35   |  27.0935   |  32.8085   | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |
     |   0.4    |  27.0935   |  32.5313   | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |
     |   0.45   |  27.0935   |  33.2014   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |
     |   0.5    |  28.0934   |  33.6307   | [0, 2, 6, 9, 8, 3, 1, 7, 4, 5] |
     |   0.55   |  27.0935   |  33.5233   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |
     |   0.6    |  27.0935   |  33.2512   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |
     |   0.65   |  28.0447   |  33.7003   | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] |
     |   0.7    |  27.0935   |  32.0927   | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |
     |   0.75   |  28.0447   |  32.4488   | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] |
     |   0.8    |  27.0935   |  32.1551   | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |
     |   0.85   |  27.0935   |  34.5399   | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |
     |   0.9    |  27.0935   |  32.6273   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |
     |   0.95   |  27.0935   |  32.4672   | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |

     **交叉概率过低会导致搜索陷入迟钝状态，得不到最优解。**

3.   变异概率对结果的影响：变异概率过高或者过低都影响得到最优解。

     | x    | 9    | 1.1  | 3.5  | 3.5  | 7    | 8    | 4    | 4.5  | 3    | 2    |
     | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
     | y    | 1.1  | 3    | 1    | 4    | 5.1  | 3    | 1    | 8.5  | 9    | 1    |

     **实验次数：10**
     **种群规模： 25**
     **最大迭代步数：100**
     **强者生存率：0.2**
     **改良次数：500**

     | 变异概率 |     最好适应度     |     最差适应度     |             最优解             |
     | :------: | :----------------: | :----------------: | :----------------------------: |
     |  0.001   | 29.04461410913315  | 62.857048114582284 | [0, 2, 6, 9, 1, 3, 7, 8, 4, 5] |
     |   0.01   |  29.8205487605704  | 59.021542403181286 | [0, 6, 2, 9, 1, 8, 7, 3, 4, 5] |
     |   0.1    | 27.093469055093585 | 67.35172234680323  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |
     |   0.15   | 28.044704993363116 | 62.34078967932604  | [0, 6, 2, 9, 1, 3, 7, 8, 4, 5] |
     |   0.2    | 29.663093341048622 | 60.78329972771102  | [0, 4, 7, 8, 3, 1, 9, 6, 2, 5] |
     |   0.25   | 29.471670891705937 | 56.941498157638016 | [0, 5, 4, 7, 8, 3, 9, 1, 2, 6] |
     |   0.3    | 27.09346905509359  | 60.80914022879588  | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] |
     |   0.35   |  29.8205487605704  |  59.9879303570508  | [0, 6, 2, 9, 1, 8, 7, 3, 4, 5] |
     |   0.4    | 28.71080039515015  |  62.0291540376335  | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] |
     |   0.45   | 27.093469055093585 | 60.020339525499736 | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |
     |   0.5    | 31.017146449260395 | 61.778858472645226 | [0, 4, 7, 8, 1, 9, 6, 2, 3, 5] |
     |   0.55   | 29.523109581860524 | 61.308292618582136 | [0, 6, 2, 9, 3, 1, 8, 7, 4, 5] |
     |   0.6    | 28.71080039515015  | 57.36283637285175  | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] |
     |   0.65   | 28.044704993363116 | 56.47986578733702  | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] |
     |   0.7    | 28.71080039515015  | 54.99612885006041  | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] |
     |   0.75   | 27.093469055093585 | 58.64350752950667  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |
     |   0.8    | 33.62523662987781  | 58.11757698431604  | [0, 9, 1, 3, 6, 2, 8, 7, 4, 5] |
     |   0.85   | 30.65911964653145  | 57.26822085037636  | [0, 1, 9, 2, 6, 3, 8, 7, 4, 5] |
     |   0.9    | 30.558527714409507 | 54.97212958853783  | [0, 4, 7, 8, 1, 9, 2, 6, 3, 5] |
     |   0.95   | 27.093469055093585 | 58.69791735252354  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] |

     由上表可知，**变异概率过大或过小都将导致无法得到最优解**。

## 求解同一 TSP 问题时不同变异 策略及不同个体选择分配策略对算法结果的影响

不同的变异策略和不同个体选择分配策略几乎不影响算法运行时间，但会影响适应度。

**种群规模：100**

**强者生存率：0.2**

**变异概率：0.1**

**迭代次数：100**

**改良次数：500**

### 不同变异方式

#### 两段互换变异

| 序号 | 最好适应度                                  | 最差适应度         | 最优解                         | 运行时间(ms) |
| ---- | ------------------------------------------- | ------------------ | ------------------------------ | ------------ |
| 1    | 27.093469055093585                          | 64.58673755103145  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 329          |
| 2    | <font color='red'>28.71080039515015</font>  | 60.364752044464225 | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] | 327          |
| 3    | 27.093469055093585                          | 60.92646207878362  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 332          |
| 4    | 27.093469055093585                          | 63.35856831546827  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 327          |
| 5    | 27.093469055093585                          | 62.63158740484413  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 325          |
| 6    | <font color='red'>28.71080039515015</font>  | 67.19548561742295  | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] | 327          |
| 7    | 27.093469055093585                          | 59.9278211378547   | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] | 318          |
| 8    | <font color='red'>28.044704993363116</font> | 66.31637670882675  | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] | 322          |
| 9    | <font color='red'>29.8205487605704</font>   | 62.47953168553274  | [0, 6, 2, 9, 1, 8, 7, 3, 4, 5] | 318          |
| 10   | 27.093469055093585                          | 67.05238800897004  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 323          |

#### 两点互换变异

| 序号 | 最好适应度                                 | 最差适应度         | 最优解                         | 运行时间(ms) |
| ---- | ------------------------------------------ | ------------------ | ------------------------------ | ------------ |
| 1    | 27.093469055093585                         | 63.52598521634741  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 320          |
| 2    | 27.09346905509359                          | 60.61311586996357  | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] | 318          |
| 3    | 27.093469055093585                         | 62.152408970104695 | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 321          |
| 4    | 27.093469055093585                         | 61.42280600968619  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 329          |
| 5    | 27.093469055093585                         | 66.58043824593932  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 321          |
| 6    | 27.093469055093585                         | 63.59408495310639  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 319          |
| 7    | <font color='red'>28.71080039515015</font> | 65.96786537403402  | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] | 321          |
| 8    | 27.09346905509359                          | 66.7449340200782   | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] | 321          |
| 9    | 27.093469055093585                         | 65.28233845399363  | [0, 6, 2, 9, 1, 8, 7, 3, 4, 5] | 320          |
| 10   | 27.093469055093585                         | 63.43117999008514  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 317          |

可以看到两种变异方式的运行时间接近，但是两段互换取得了**4次非最优解**，两点互换只取得了**1次非最优解**。可见，在此条件下（变异概率、强者存活率和种群规模等），两点互换比两段互换的算法效果要好。

### 不同选择概率分配策略

#### 适应度比例法

同两点互换

#### 完全随机法

| 序号 | 最好适应度                                  | 最差适应度         | 最优解                         | 运行时间(ms) |
| ---- | ------------------------------------------- | ------------------ | ------------------------------ | ------------ |
| 1    | <font color='red'>29.8205487605704</font>   | 63.7607928266052   | [0, 6, 2, 9, 1, 8, 7, 3, 4, 5] | 249          |
| 2    | 27.09346905509359                           | 60.995357534381405 | [0, 5, 4, 7, 8, 3, 1, 9, 2, 6] | 239          |
| 3    | <font color='red'>28.044704993363116</font> | 59.84856462743046  | [0, 5, 4, 8, 7, 3, 1, 9, 2, 6] | 241          |
| 4    | <font color='red'>30.558527714409507</font> | 63.01318560628126  | [0, 4, 7, 8, 1, 9, 2, 6, 3, 5] | 241          |
| 5    | <font color='red'>28.71080039515015</font>  | 58.59344730195132  | [0, 4, 7, 8, 3, 1, 9, 2, 6, 5] | 246          |
| 6    | <font color='red'>29.523109581860524</font> | 64.13625288963031  | [0, 6, 2, 9, 3, 1, 8, 7, 4, 5] | 242          |
| 7    | 27.093469055093585                          | 63.757600726543394 | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 239          |
| 8    | 27.093469055093585                          | 61.59802407894025  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 247          |
| 9    | 27.093469055093585                          | 59.25248048349517  | [0, 6, 2, 9, 1, 8, 7, 3, 4, 5] | 245          |
| 10   | 27.093469055093585                          | 66.85067394876258  | [0, 6, 2, 9, 1, 3, 8, 7, 4, 5] | 241          |

对比可知，完全随机法虽然运行速度快，但是**10次中有5次**无法找到最优解。可见，在此条件下（变异概率、强者存活率和种群规模等），个体选择概率分配方式不宜选择完全随机法，适应度比例法效果更好。

# 整体代码

```python
import math
import time

import tqdm
import numpy as np
import random


# 获取数据并计算每两个城市之间的距离
def read_array(n):
    data = np.loadtxt('data.txt')
    data = data[0:n, :]
    city_name = data[:, 0]
    city_point = data[:, 1:]
    city_count = len(city_name)
    distance = np.zeros([city_count, city_count])
    for i in range(city_count):
        for j in range(city_count):
            distance[i][j] = math.sqrt((city_point[i][0] - city_point[j][0]) ** 2 +
                                       (city_point[i][1] - city_point[j][1]) ** 2)

    return city_count, distance


# 计算一个个体的总距离
# 此处的个体即为其中的一条路径，这里就是求这条路径的总距离
def get_total_distance(x):
    distance = 0
    # 距离矩阵中第一个点到这个个体的第一个点的距离
    distance += Distance[origin][x[0]]
    for i in range(len(x)):
        if i == len(x) - 1:
            # 从终点回到起点
            distance += Distance[origin][x[i]]
        else:
            distance += Distance[x[i]][x[i + 1]]
    return distance


# 改良圈算法
def improve(x):
    i = 0
    while i < improve_count:
        # 生成指定范围的两个整数
        u = random.randint(0, len(x) - 2)
        v = random.randint(u + 1, len(x) - 1)
        # 如果倒序区间内的路径可以取得更好的路径时，更新路径
        if Distance[u - 1][v] + Distance[u][v + 1] < Distance[u - 1][u] + Distance[v][v + 1]:
            t = x[u]
            x[u] = x[v]
            x[v] = t
        i += 1
    return x


# 获取当前种群的最佳结果，即获取当前种群中总距离最小的那条路径
def get_result(population):
    graded = [[get_total_distance(x), x] for x in population]
    graded = sorted(graded)
    min_res = graded[0][0]
    max_res = graded[len(graded) - 1][0]
    return min_res, max_res, graded[0][1]


# 轮盘赌
def roulette(population):
    q = []
    p = []

    # 计算每个个体被遗传到下一代群体中的概率
    for item in population:
        p.append(get_total_distance(item))
    p /= sum(p)

    # 计算每个个体的累计概率
    cur = 0
    for i in p:
        cur += i
        q.append(cur)

    choices = []
    for i in range(count):
        rate = random.random()
        for _, j in enumerate(q):
            if rate <= j:
                choices.append(_)
                break
    return choices


# 自然选择过程
def selection(population):
    """
    选择
    先对适应度从大到小排序，选出存活的染色体
    再进行随机选择，选出适应度虽然小，但是幸存下来的个体（使用轮盘赌方法）
    :param population: 初始种群
    :return: 选择出的种群
    """
    # 适应度从大到小排序，选出存活的染色体，即强者存活
    graded = [[get_total_distance(x), x] for x in population]
    graded = [x[1] for x in sorted(graded)]
    # 选出适应性强的染色体
    retain_length = int(len(graded) * retain_rate)
    parents = graded[:retain_length]
    # 轮盘赌
    choices = roulette(graded)
    for choice in choices:
        if graded[choice] not in parents:
            parents.append(graded[choice])
    return parents


# 交叉繁殖
def crossover(parents):
    # 生成的子代的个数，以此保证种群稳定，即总种群数是不变的
    target_count = count - len(parents)
    # 子代列表
    children = []
    while len(children) < target_count:
        # 随机选择父母
        male_index, female_index = random.sample(range(0, len(parents) - 1), 2)
        male = parents[male_index]
        female = parents[female_index]

        left = random.randint(0, len(male) - 2)
        right = random.randint(left + 1, len(male) - 1)

        # 交叉片段
        # 此处的交叉过程参照pdf
        gene1 = male[left:right]
        gene2 = female[left:right]

        # 转换附带染色体的顺序得到亚父代
        child1_c = male[right:] + male[:right]
        child2_c = female[right:] + female[:right]
        child1 = child1_c.copy()
        child2 = child2_c.copy()

        # 去掉交叉片段
        for o in gene2:
            child1_c.remove(o)

        for o in gene1:
            child2_c.remove(o)

        # 插入交叉片段
        child1[left:right] = gene2
        child2[left:right] = gene1

        # 填入原来的片段
        child1[right:] = child1_c[0:len(child1) - right]
        child1[:left] = child1_c[len(child1) - right:]

        child2[right:] = child2_c[0:len(child2) - right]
        child2[:left] = child2_c[len(child2) - right:]

        children.append(child1)
        children.append(child2)

    return children


# 变异
def mutation(children):
    for i in range(len(children)):
        # 满足条件才变异
        if random.random() < mutation_rate:
            child = children[i]
            u = random.randint(1, len(child) - 4)
            v = random.randint(u + 1, len(child) - 3)
            w = random.randint(v + 1, len(child) - 2)
            # 第二和第三段互换
            child = child[0:u] + child[v:w] + child[u:v] + child[w:]


# 进行遗传算法
def begin():
    # 使用改良圈算法初始化种群
    population = []
    for i in range(count):
        # 随机生成个体
        x = index.copy()
        # 打乱顺序
        random.shuffle(x)
        # 改良圈算法优化种群
        x = improve(x)
        # 把每个个体逐个添加到种群里
        population.append(x)

    # 保存每次最优路径
    register = []
    min_res, max_res, result_path = get_result(population)
    # 进化次数
    for i in tqdm.trange(iter_count):
        # 选择繁殖个体群
        parents = selection(population)
        # 交叉繁殖
        children = crossover(parents)
        # 变异操作
        mutation(children)
        # 更新种群
        population = parents + children
        min_res, max_res, result_path = get_result(population)
        register.append(min_res)
    return min_res, max_res, result_path


# 主函数
if __name__ == '__main__':
    # 设置参数
    count = 500  # 种群规模
    retain_rate = 0.2  # 强者生存率
    mutation_rate = 0.1  # 变异概率
    iter_count = 500  # 迭代次数
    improve_count = 500  # 改良次数
    scales = [10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75]

    # 设置起点
    origin = 0

    for scale in scales:
        start = time.time()

        city_count, Distance = read_array(scale)

        # 建立索引
        index = np.arange(city_count).tolist()
        index.remove(origin)

        min_res, max_res, result_path = begin()

        print(min_res, max_res)
        print(result_path)

        end = time.time()
        print(scale, end-start)
```

