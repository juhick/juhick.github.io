---
title: 分数到小数
date: 2021-10-03 09:04:46
tags:
 - leetcode
 - 数学
categories:
 - leetcode
math: true
---

[原题链接](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)

# 题目分析

题目要求给定的分子和分母，将分数转成整数或小数。由于给定的分子和分母的取值范围都是$[-2^{31}, 2^{31} - 1]$，为了防止计算过程中产生溢出，需要将分子和分母转为$64$位整数表示。

将分数转为整数或小数，做法是计算分子和分母相除的结果。可能的结果有三种：整数、有限小数、无限循环小数。

如果分子可以被分母整除，则结果是整数，将分子除以分母的商以字符串的形式返回即可。

如果分子不能被分母整除，则结果是优先小数或无限循环小数，需要通过模拟长除法的方式计算结果。

为了方便处理，可以根据分子和分母的正负决定结果的正负（注意此时分子和分母都不为0），然后将分子和分母都转成正数，再计算长除法。

<!-- more -->

## 解题方法：长除法

计算长除法时，首先计算结果的整数部分，将以下部分依次拼接到结果中：

1. 如果结果是负数则将负号拼接到结果中，如果结果是整数则跳过这一步；
2. 将整数部分拼接到结果中；
3. 将小数点拼接到结果中。

完成上述部分后，根据余数计算小数部分。

计算小数部分时，每次将余数乘以$10$，然后计算小数的下一位数字，并得到新的余数。重复上述操作直到余数变成$0$或者找到循环节。

* 如果余数变为0，则结果是有限小数，将小数部分拼接到结果中。
* 如果找到循环节，则找到循环节的开始位置和结束位置并加上括号，然后将小数部分拼接到结果中。

### 如何判断循环节

注意到对于相同的余数，计算得到的小数的下一位数字一定是相同的。因此如果计算过程中发现某一位的余数在之前已经出现过，则为找到循环节。

为了记录每个余数是否已经出现过，需要使用哈希表存储每个余数在小数部分第一次出现的下标。

假设在计算小数部分的第$i$位**之前**，余数为$remainder_i$，则在计算小数部分的第$i$位**之后**，余数为$remainder_{i+1}$。

假设存在下标$j$和$k$，满足$j \leq k$且$remainder_j = remainder_{k + 1}$，则小数部分的第$k+1$位和小数部分第$j$位相同，因此小数部分的第$j$位到第$k$位是一个循环节。在计算小数部分的第$k$位之后就会发现这个循环节的存在，因此在小数部分的第$j$位之前加上左括号，在小数部分的末尾(即第$k$位之后)加上右括号。

![fig1](https://raw.githubusercontent.com/juhick/picJuhick/master/1-20211003095557714.png)

![fig2](https://raw.githubusercontent.com/juhick/picJuhick/master/2.png)

# 代码示例

```java
class Solution {
    public String fractionToDecimal(int numerator, int denominator) {
        long numeratorLong = (long) numerator;
        long denominatorLong = (long) denominator;

        if (numeratorLong % denominatorLong == 0){
            return String.valueOf(numeratorLong / denominatorLong);
        }
        StringBuffer sb = new StringBuffer();
        if (numeratorLong < 0 ^ denominator < 0){
            sb.append('-');
        }

        numeratorLong = Math.abs(numeratorLong);
        denominatorLong = Math.abs(denominatorLong);
        long integerPart = numeratorLong / denominatorLong;
        sb.append(integerPart);
        sb.append('.');

        StringBuffer fractionPart = new StringBuffer();
        Map<Long, Integer> remainderIndexMap = new HashMap<>();
        Long remainder = numeratorLong % denominatorLong;
        int index = 0;
        while (remainder != 0 && !remainderIndexMap.containsKey(remainder)){
            remainderIndexMap.put(remainder, index);
            remainder *= 10;
            fractionPart.append(remainder / denominatorLong);
            remainder %= denominatorLong;
            index++;
        }
        if (remainder != 0){
            int insertIndex = remainderIndexMap.get(remainder);
            fractionPart.insert(insertIndex, '(');
            fractionPart.append(')');
        }
        sb.append(fractionPart.toString());

        return sb.toString();
    }
}
```

