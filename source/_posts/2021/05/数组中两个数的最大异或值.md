---
title: 数组中两个数的最大异或值
date: 2021-05-16 09:29:16
tags:
 - leetcode
 - 位运算
categories:
 - leetcode
math: true
---

[题目链接](https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/)

# 题目描述

给你一个整数数组 `nums` ，返回 `nums[i] XOR nums[j]` 的最大运算结果，其中 `0 ≤ i ≤ j < n` 。

**进阶：**你可以在 `O(n)` 的时间解决这个问题吗？

<!-- more -->

**示例 1：**

```
输入：nums = [3,10,5,25,2,8]
输出：28
解释：最大运算结果是 5 XOR 25 = 28.
```

**示例 2：**

```
输入：nums = [0]
输出：0
```

**示例 3：**

```
输入：nums = [2,4]
输出：6
```

**示例 4：**

```
输入：nums = [8,10,2]
输出：10
```

**示例 5：**

```
输入：nums = [14,70,53,83,49,91,36,80,92,51,66,70]
输出：127
```

**提示：**

- `1 <= nums.length <= 2 * 104`
- `0 <= nums[i] <= 231 - 1`

# 思路分析

假设从数组中选择了元素$a_i$和$a_j$（$i \neq j$），异或值`x`的计算方法是
$$
x = a_i \oplus a_j
$$
最简单的方法就是直接一个二重循环枚举i和j，然后依次计算异或值并且与当前最大值进行比较，但是这样的时间复杂度为$O(n^2)$，需要对采用更高效的算法。

根据位异或运算的性质，$x = a_i \oplus a_j$等价于$a_j = x \oplus a_i$。我们可以根据该等式变换从高位到低位确定x的每一位，从而最终得出x的值。该方法的精妙之处：

* 由于数组中的元素都在 $[0, 2^{31})$ 的范围内，那么我们可以将每一个数表示为一个长度为31位的二进制数（如果不满31位，在最高位之前补上若干个前导0即可）；
* 这31个二进制位从低位到高位依次编号为 $0, 1, \cdots, 30$。我们从最高位第 30 个二进制位开始，依次确定 `x` 的每一位是 0 还是 1；
* 由于我们需要找出最大的`x`，因此在枚举每一位时，我们先判断`x`的这一位是否能取到1。如果能，我们取这一位为1，否则我们取这一位为0。

「判断`x`的某一位是否能取到 1」这一步骤并不容易。下面介绍两种判断的方法。

## 方法一：哈希表

### 思路与算法

假设我们已经确定了`x`最高的若干个二进制位，当前正在确定第`k`个二进制位，根据之前的分析，我们希望第`k`个二进制位能够取到1。

我们用$pre^k(x)$表示$x$从最高位第30个二进制位开始，到第$k$个二进制位为止的数，那么$a_j = x \oplus a_i$蕴含着：
$$
pre^k(a_j) = pre^k(x) \oplus pre^k(a_i)
$$
由于$pre^k(x)$对于我们来说是已知的，因此我们将所有的$pre^k(a_j)$放入哈希表中，随后枚举$i$并计算$pre^k(x) \oplus pre^k(a_i)$。如果其出现在哈希表中，那么说明第$k$个二进制位能够取到1，否则第$k$个二进制位只能为0。

### 细节

计算$pre^k(x)$可以使用右移运算$>>$。

### 代码

```java
class Solution {
    // 最高位的二进制位编号为 30
    static final int HIGH_BIT = 30;

    public int findMaximumXOR(int[] nums) {
        int x = 0;
        for (int k = HIGH_BIT; k >= 0; --k) {
            Set<Integer> seen = new HashSet<Integer>();
            // 将所有的 pre^k(a_j) 放入哈希表中
            for (int num : nums) {
                // 如果只想保留从最高位开始到第 k 个二进制位为止的部分
                // 只需将其右移 k 位
                seen.add(num >> k);
            }

            // 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分
            // 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1
            int xNext = x * 2 + 1;
            boolean found = false;
            
            // 枚举 i
            for (int num : nums) {
                if (seen.contains(xNext ^ (num >> k))) {
                    found = true;
                    break;
                }
            }

            if (found) {
                x = xNext;
            } else {
                // 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0
                // 即为 x = x*2
                x = xNext - 1;
            }
        }
        return x;
    }
}
```

### 复杂度分析

- 时间复杂度：$O(n \log C)$，其中`n`是数组 $\textit{nums}$ 的长度，`C`是数组中的元素范围，在本题中 $C < 2^{31}$。枚举答案`x`的每一个二进制位的时间复杂度为 $O(\log C)$，在每一次枚举的过程中，我们需要$O(n)$的时间进行判断，因此总时间复杂度为$O(n \log C)$。
- 空间复杂度：$O(n)$，即为哈希表需要使用的空间。