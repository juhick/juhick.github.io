---
title: 设计模式相关知识
date: 2021-04-23 17:20:38
tags:
 - 面试
 - 设计模式
categories:
 - 面试
math:
---

# 设计模式

### 设计模式的六大原则：

<!-- more -->

#### 单一职责原则（Single responsibility， SRP）：
单一职责规定了一个类应该只有一个发生变化的原因。如果一个类承担了多个职责，则会导致多个职责耦合在一起。但部分职责发生变化的时候，可能会导致其余职责跟着受到影响，也就是说我们的程序耦合性太强，不利于变化。

**那么，单一职责有哪些优点呢？**

- 降低了类的复杂度，每一个类都有清晰明确的职责。
- 程序的可读性和可维护性都得到了提高。
- 降低业务逻辑变化导致的风险，一个接口的修改只对相应的实现类有影响，对其他接口无影响。

#### 里氏替换原则（Liskov Substitution Principle，LSP）：

里氏替换是指所有父类可以出现的地方，子类就都可以出现，使用子类来替换父类，调用方不需要关心目前传递的父类还是子类。

通过里氏替换原则，我们可以将子类对象做为父类对象来使用，屏蔽了不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。里氏替换之后，父类的对象就可以根据当前赋值给它的子类对象的特性以不同的方式运作。

**那么，里氏替换原则有哪些优点呢？**

里氏替换原则可以增强程序的健壮性，子类可以任意增加和缩减，我们都不需要修改接口参数。在实际开发中，实现了传递不同的子类来完成不同的业务逻辑。

#### 依赖倒置原则（Dependence Inversion Principle，DIP）

依赖倒置原则是指高层模块不应该依赖于底层模块，抽象不应该依赖细节，细节应该依赖抽象。在Java中，接口和抽象类都是抽象，而其实现类就是细节。也就是说，我们应该做到面向接口编程，而非面向实现编程。

**那么，依赖导致原则的好处有哪些呢？**

- 依赖倒置通过抽象(接口或抽象类)使各个类或模块的独立，实现模块间的松耦合。
- 面向接口编程可以使得当需求变化的时候，程序改动的工作量不至于太大。

#### 接口隔离原则(Interface Segregation Principle, ISP)：

接口隔离原则是指客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。

**接口隔离原则的使用原则：**

- 根据接口隔离原则拆分接口时，首先必须满足单一职责原则。
- 接口需要高内聚，提高接口，类和模块的处理能力，减少对外的交互。
- 定制服务，单独为一个个体提供优良服务(只提供访问者需要的方法)。
- 接口设计要有限度，接口设计的太小，容易造成开发难度增加或者可维护性降低。

#### 迪米特法则(Law of Demeter，LoD)：

迪米特法则也叫最少知识原则，是指一个对象应该对其依赖的对象有最少的了解。该类不需要知道其依赖类的具体实现，只需要依赖类给其提供一个公开对外的public方法即可，其余一概不需要了解。

迪米特法则的核心就是解耦合，减弱类间的各个耦合，提高类的复用率。

#### 开闭原则（Open Close Principle，OCP）：

开闭原则是指一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。也就是说，通过开闭原则，我们可以通过扩展行为来实现新的功能，而不是通过修改已有的代码。开闭原则可以帮助我们构建一个稳定，灵活的软件系统。

#### 简单总结

- **单一职责原则：类或者接口要实现职责单一**
- **里氏替换原则：使用子类来替换父类，做出通用的编程**
- **依赖倒置原则：面向接口编程**
- **接口隔离原则：接口的设计需要精简单一**
- **迪米特法则：降低依赖之间耦合**
- **开闭原则：对扩展开放，对修改关闭**

### 单例模式（创建型模式）

单例模式是指在一个系统中，一个类有且只有一个对象实例。

**单例模式的实现：**单例模式从创建方式上又分为饿汉式和懒汉式两种。

饿汉式的单例模式：

```java
/**
 * @author 秦海祺 {2021/4/23}
 */
public class Single {
    private static final Single s = new Single();
    private Single(){}
    public static Single getInstance(){
        return s;
    }
}
```

饿汉式的单例模式在程序初始化的时候即创建了对象，在需要的时候可以直接返回该对象实例。

懒汉式的单例模式：

```java
/**
 * @author 秦海祺 {2021/4/23}
 */
public class Single {
    private static Single s = null;
    private Single(){}
    public static Single getInstance(){
        if(null == s){
            s = new Single();
        }
        return s;
    }
}
```

加入synchronized内部锁来解决多线程环境下的线程安全问题，代码实现如下所示：

```java
public class Single {
    private static Single s = null;
    private Single(){}
    public static Single getInstance(){
        if(null ==s){
            synchronized (Single.class){{
                if(null == s){
                    s = new Single();
                }
            }}
        }
        return s;
    }
}
```

**Instance instance = new Instance()都发生了啥？**

具体步骤如下三步所示：

- 在堆内存上分配对象的内存空间
- 在堆内存上初始化对象
- 设置instance指向刚分配的内存地址

第二步和第三步可能会发生重排序，导致引用型变量指向了一个不为null但是也不完整的对象。所以，在多线程下上述的代码会返回一个不完整的对象。我们需要加入一个**volatile**关键字来禁止指令重排序。

**完整的多线程环境下的单例模式的实现代码如下**:

```java
/**
 * @author 秦海祺 {2021/4/23}
 */
public class Single {
    private static volatile Single s = null;
    private Single(){}
    public static Single getInstance(){
        if(null == s){
            synchronized (Single.class){{
                if(null == s){
                    s = new Single();
                }
            }}
        }
        return s;
    }
}
```

**单例模式的优点：**单例模式保证了一个类在一个系统中有且只有一个对象实例，减少了系统内存和性能的开销。

**单例模式的使用场景：**创建一个对象需要消耗太多的资源或者在一个系统中不适合创建多个对象实例的情况下，我们可以采用单例模式设计实现。

### 工厂方法模式（创建型模式）

工厂方法模式是一种常见的设计模式。工厂方法模式定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类。

**工厂方法模式的类图：**

![图片说明](https://raw.githubusercontent.com/juhick/picJuhick/master/2021/04/20210423193638.png)

其中，Product和ConcreteProduct分别表示抽象产品类和具体产品类。Creator和ConcreteCreator则分别表示抽象创建类和具体创建类。抽象创建类Creator中定义了创建产品的方法createProduct。

```java
/**
 * @author 秦海祺 {2021/4/21}
 */


public class Main {

    public static void main(String[] args) throws InterruptedException{
        Creator creator = new ConcreteCreator();

        Product product = creator.createProduct(ConcreteProduct.class);

        product.method1();
        product.method2();
    }
}

abstract class Product{
    public void method1(){

    }

    public abstract void method2();
}

class ConcreteProduct extends Product{

    @Override
    public void method2() {

    }
}

abstract class Creator{
    public abstract <T extends Product> T createProduct(Class<T> c);
}

class ConcreteCreator extends Creator{

    @Override
    public <T extends Product> T createProduct(Class<T> c) {
        Product product = null;
        try{
            product = (Product) Class.forName(c.getName()).newInstance();
        }catch (ClassNotFoundException | InstantiationException | IllegalAccessException e){

        }
        return (T)product;
    }
}
```

**那么，工厂方法模式的优点有哪些呢？**

- 工厂方法模式具有很好的封装性。客户端不需要知道创建对象的过程，只需要知道要创建的是哪个具体的产品即可。
- 工厂方法模式对扩展开放。当新增一个产品种类的时候，我们只需要传入新增产品类对象给具体工厂，即可返回新增的产品对象。

**工厂方法模式的使用场景：**

- 工厂方法模式的作用就是创建指定的对象，可以做为new一个对象的替代方式。但是需要考虑是否有必要使用工厂方法模式来创建对象。
- 当需要灵活，可扩展的创建多个对象的场景时，可以使用工厂方法模式。

### 模板方法模式（行为型模式）

模板方法模式也是一个常见的模式。模板方法模式定义了一个框架，将一些步骤延迟到其子类中实现，子类可以在不改变框架的前提下重新定义某些特定的执行步骤。

![图片说明](https://raw.githubusercontent.com/juhick/picJuhick/master/2021/04/20210423195257.png)

AbstractClass是一个抽象模板，它的方法分为模板方法和基本方法。

- 基本方法：是抽象方法，由子类实现，并且在模板方法中被调用。
- 模板方法：可以有一个或者几个，一般是具体的方法，实现对基本方法的调度，完成确定的业务逻辑，确定一个框架。

ConcreteClass1和ConcreteClass2属于具体模板类，实现抽象模板所定义的抽象方法，并且拥有父类模板中的模板方法。

接下来，我们给出一个模板方法模式的Demo：

```java
/**
 * @author 秦海祺 {2021/4/21}
 */


public class Main {

    public static void main(String[] args) throws InterruptedException{
        Dog dog = new Dog();
        Cat cat = new Cat();

        dog.start();
        cat.start();

    }
}

abstract class Animal{
    abstract void eat();
    abstract void run();

    public void start(){
        eat();
        run();
    }
}

class Dog extends Animal{

    @Override
    void eat() {
        System.out.println("我是小狗，我在吃东西...");
    }

    @Override
    void run() {
        System.out.println("我是小狗，我在跑步...");
    }
}

class Cat extends Animal{

    @Override
    void eat() {
        washHand();
        System.out.println("我是小猫，我在吃东西...");
    }

    @Override
    void run() {
        System.out.println("我是小猫，我在跑步...");
    }

    private void washHand(){
        System.out.println("我是小猫，我在洗手...");
    }
}
```

**那么，模板方法模式的优点有哪些呢？**

- 封装不变部分，扩展可变部分
- 提取公共部分代码，便于维护
- 行为由父类控制，子类实现

模板方法模式就是在模板方法中调用基本方法来确定整个算法的执行框架。

### 抽象工厂模式（创建型模式）

抽象工厂模式为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。

**抽象工厂模式和工厂方法模式的区别：**

如果产品单一，适合使用工厂模式。但是如果有多个业务品种、业务分类时，需要使用抽象工厂模式。也就是说，工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。

### 代理模式（结构型模式）

代理模式为其他对象提供一种代理以控制对这个对象的访问。将原类进行封装，客户端不能直接找到原类，必须通过代理角色。即代理是原类的一个替身，客户端要找原类，必须找代理才可以搞定。明星和经纪人的关系就是一种代理模式。

代理模式又分为静态代理和动态代理。动态代理在实现阶段不用关心代理谁，而在运行阶段才指定代理哪一个对象。相对来说，自己写代理类的方式就是静态代理。

### 策略模式（行为型模式）

在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。

**意图：**定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

**主要解决：**在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

**何时使用：**一个系统有许多许多类，而区分它们的只是他们直接的行为。

**如何解决：**将这些算法封装成一个一个的类，任意地替换。

**关键代码：**实现同一个接口。

**优点：** 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。

**缺点：** 1、策略类会增多。 2、所有策略类都需要对外暴露。

**注意事项：**如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。

类图如下：

![策略模式的 UML 图](https://raw.githubusercontent.com/juhick/picJuhick/master/2021/04/20210423201323.jpeg)

### 责任链模式（行为型模式）

责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。

**意图：**避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

**主要解决：**职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。

**何时使用：**在处理消息的时候以过滤很多道。

**如何解决：**拦截的类都实现统一接口。

**关键代码：**Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。

**优点：** 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。

**缺点：** 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。

### 观察者模式（行为型模式）

当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。

**意图：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**主要解决：**一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。

**何时使用：**一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。

**如何解决：**使用面向对象技术，可以将这种依赖关系弱化。

**关键代码：**在抽象类里有一个 ArrayList 存放观察者们。

**优点：** 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。

**缺点：** 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

**注意事项：** 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。

### 适配器模式（结构型模式）

适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁，它结合了两个独立接口的功能。

这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。

**意图：**将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

**主要解决：**主要解决在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。

**何时使用：** 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）

**如何解决：**继承或依赖（推荐）。

**关键代码：**适配器继承或依赖已有的对象，实现想要的目标接口。

**优点：** 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。

**缺点：** 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。

### 装饰器模式（结构型模式）

装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。

这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。

**意图：**动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。

**主要解决：**一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。

**何时使用：**在不想增加很多子类的情况下扩展类。

**如何解决：**将具体功能职责划分，同时继承装饰者模式。

**关键代码：** 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。

**优点：**装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。

**缺点：**多层装饰比较复杂。

