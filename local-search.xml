<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使所有区间的异或结果为零</title>
    <link href="/2021/05/25/%E4%BD%BF%E6%89%80%E6%9C%89%E5%8C%BA%E9%97%B4%E7%9A%84%E5%BC%82%E6%88%96%E7%BB%93%E6%9E%9C%E4%B8%BA%E9%9B%B6/"/>
    <url>/2021/05/25/%E4%BD%BF%E6%89%80%E6%9C%89%E5%8C%BA%E9%97%B4%E7%9A%84%E5%BC%82%E6%88%96%E7%BB%93%E6%9E%9C%E4%B8%BA%E9%9B%B6/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/make-the-xor-of-all-segments-equal-to-zero/">原题链接</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。区间 <code>[left, right]</code>（<code>left &lt;= right</code>）的 <strong>异或结果</strong> 是对下标位于 <code>left</code> 和 <code>right</code>（包括 <code>left</code> 和 <code>right</code> ）之间所有元素进行 <code>XOR</code> 运算的结果：<code>nums[left] XOR nums[left+1] XOR ... XOR nums[right]</code> 。</p><p>返回数组中 <strong>要更改的最小元素数</strong> ，以使所有长度为 <code>k</code> 的区间异或结果等于零。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[1,2,0,3,0]</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">3</span><br>解释：将数组 <span class="hljs-string">[1,2,0,3,0]</span> 修改为 <span class="hljs-string">[0,0,0,0,0]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">3,4,5,2</span>,<span class="hljs-number">1,7,3,4</span>,<span class="hljs-number">7</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：将数组 [<span class="hljs-number">3,4,5,2</span>,<span class="hljs-number">1,7,3,4</span>,<span class="hljs-number">7</span>] 修改为 [<span class="hljs-number">3,4,7,3</span>,<span class="hljs-number">4,7,3,4</span>,<span class="hljs-number">7</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">1,2,4,1</span>,<span class="hljs-number">2,5,1,2</span>,<span class="hljs-number">6</span>], k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">3</span><br>解释：将数组[<span class="hljs-number">1,2,4,1</span>,<span class="hljs-number">2,5,1,2</span>,<span class="hljs-number">6</span>] 修改为 [<span class="hljs-number">1,2,3,1</span>,<span class="hljs-number">2,3,1,2</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= k &lt;= nums.length &lt;= 2000</code></li><li><code>0 &lt;= nums[i] &lt; 210</code></li></ul><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>设$nums$数组的长度为$n$，修改后的数组任意长度为$k$的区间异或结果为0，则对于任意的$i$有：<br>$$<br>nums[i] \oplus nums[i + 1] \oplus \dots \oplus nums[i + k - 1] = 0<br>$$<br>同时还有：<br>$$<br>nums[i + 1] \oplus nums[i + 2] \oplus \dots \oplus nums[i + k] = 0<br>$$<br>由这两个等式可以推出：<br>$$<br>nums[i] \oplus nums[i + k] = 0<br>$$<br>即$nums[i] = nums[i + k]$，由此可以得出每隔$k$个数字都是相等的，即修改之后的$nums$数组是一个以$k$为周期的数组，即$\forall i \in [0, n - k), nums[i] = nums[i + k]$。</p><p>因此，我们可以将数组$nums$根据下标对$k$取模的结果$0, 1, 2, 3, \dots, k - 1$分成$k$个组，每个组内的元素必须都相等，且这k个组对应元素的异或和为0，即：<br>$$<br>num[0] \oplus nums[1] \oplus \dots \oplus nums[k - 1] = 0<br>$$</p><p>对于第$i$个组，我们可以用哈希表来存储每个分组内出现的元素及其相应个数，之后采用动态规划对该问题求解，即求将每个组内元素修改为全部相等并且全部分组的数字的异或和为0所需的最少次数。</p><p>设$f(i, mask)$为已经处理了第$0, 1, \dots, i$个组，且这些组对应元素的异或和<br>$$<br>nums[0] \oplus nums[1] \oplus \dots \oplus nums[i]<br>$$<br>为$mask$的前提下，这些组<strong>总计</strong>需要修改的元素个数。在进行状态转移时，我们可以枚举第$i$组被修改成了哪个数。假设被修改为了$x$，那么第$0, 1, \dots, i - 1$组的异或值为$mask \oplus x$，因此的到状态转移方程:<br>$$<br>f(i, mask) = \min \limits_{x}[f(i - 1, mask \oplus x) + size(i) - count(i, x)]<br>$$<br>其中$size(i)$代表$i$组的元素个数，$count(i, x)$代表第$i$组中$x$的个数。它们可以根据哈希表得到。</p><p>上述状态转移方程的意义即为：如果我们选择将第$i$组全部修改为$x$，那么有 $\text{count}(i, x)$个数是无需修改的，这样就需要修改$\text{size}(i) - \text{count}(i, x)$次。</p><h2 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h2><p>首先，由于$size(i)$是一个与$x$无关的变量，所以从$min$中取出，即：<br>$$<br>f(i, mask) = size(i) + \min_{x}[f(i - 1, mask \oplus x) - count(i, x)]<br>$$<br>由于我们需要求的是「最小值」，因此在状态转移方程中添加若干大于等于「最小值」的项，对最终的答案不会产生影响。</p><p>考虑$count(i, x)$这一项，如果$x$没有在哈希表中出现，那么这一项的值为0，否则这一项的值大于0，即：</p><ul><li><p>如果$x$没有在哈希表中出现，那么转移的状态为：<br>$$<br>f(i - 1, mask \oplus x)<br>$$</p></li><li><p>如果$x$在哈希表中出现，那么转移的状态为：<br>$$<br>f(i - 1, mask \oplus x) - count(i, x)<br>$$<br>它严格小于$f(i - 1, mask \oplus x)$。如果我们在状态转移方程在添加$f(i - 1, mask \oplus x)$，最终答案不会变化。</p></li></ul><p>因此我们可以将状态转移方程变化为：<br>$$<br>f(i, mask) = size(i) + \min{t1, t2}<br>$$<br>其中$t1$对应$x$在哈希表中的状态，即:<br>$$<br>t1 = \min_{x \in HashTable(i)} {f(i - 1, mask \oplus x) - count(i, x)}<br>$$<br>$t2$对应的是$x$不在哈希表中的状态，以及$x$在哈希表中出现且我们额外添加的状态，即：<br>$$<br>t2 = \min_x f(i-1, mask \oplus x)<br>$$<br>$t2$就是所有状态$f(i-1, ..)$中的最小值。最终的答案为$f(k - 1, 0)$。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>由于$f(i, ..)$只会从 $f(i-1, ..)$转移而来，因此我们可以使用两个长度为$2^{10}$的一维数组代替二维数组，交替地进行状态转移，减少空间复杂度。</p><p>此外，当$i=0$时，$f(-1, ..)$ 都是需要特殊考虑的边界条件。由于 $f(-1, ..)$表示没有考虑任何组时的异或和，因此该异或和一定为 0，即 $f(-1, 0) = 0$。其它的状态都是不合法的状态，我们可以将它们赋予一个极大值 $\infty$。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXX = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> INFTY = Integer.MAX_VALUE / <span class="hljs-number">2</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minChanges</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span>[] f = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXX];<br>        Arrays.fill(f, INFTY);<br>        f[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            <span class="hljs-keyword">int</span> size = <span class="hljs-number">0</span>;<br>            Map&lt;Integer, Integer&gt; memo = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &lt; n; j += k)&#123;<br>                size++;<br>                memo.put(nums[j], memo.getOrDefault(nums[j], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            &#125;<br><br>            <span class="hljs-keyword">int</span> minT2 = Arrays.stream(f).min().getAsInt();<br>            <span class="hljs-keyword">int</span>[] g = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[MAXX];<br>            Arrays.fill(g, minT2);<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> mask = <span class="hljs-number">0</span>; mask &lt; MAXX; mask++)&#123;<br>                <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer, Integer&gt; entry:memo.entrySet())&#123;<br>                    <span class="hljs-keyword">int</span> x = entry.getKey(), countX = entry.getValue();<br>                    g[mask] = Math.min(f[mask ^ x] - countX, g[mask]);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; MAXX; j++)&#123;<br>                g[j] += size;<br>            &#125;<br>            f = g;<br>        &#125;<br>        <span class="hljs-keyword">return</span> f[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>奇怪的打印机</title>
    <link href="/2021/05/24/%E5%A5%87%E6%80%AA%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA/"/>
    <url>/2021/05/24/%E5%A5%87%E6%80%AA%E7%9A%84%E6%89%93%E5%8D%B0%E6%9C%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/strange-printer/">原题链接</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>有台奇怪的打印机有以下两个特殊要求：</p><ul><li>打印机每次只能打印由 <strong>同一个字符</strong> 组成的序列。</li><li>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。</li></ul><p>给你一个字符串 <code>s</code> ，你的任务是计算这个打印机打印它需要的最少打印次数。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;aaabbb&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：首先打印 <span class="hljs-string">&quot;aaa&quot;</span> 然后打印 <span class="hljs-string">&quot;bbb&quot;</span>。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vbnet">输入：s = <span class="hljs-string">&quot;aba&quot;</span><br>输出：<span class="hljs-number">2</span><br>解释：首先打印 <span class="hljs-string">&quot;aaa&quot;</span> 然后在第二个位置打印 <span class="hljs-string">&quot;b&quot;</span> 覆盖掉原来的字符 <span class="hljs-comment">&#x27;a&#x27;。</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length &lt;= 100</code></li><li><code>s</code> 由小写英文字母组成</li></ul><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>我们可以采用动态规划的方法来解决该问题，设$dp[i][j]$代表打印区间$[i,j]$的最少操作数。</p><p>计算$dp[i][j]$时有两种情况：</p><ol><li>如果$s[i] == s[j]$，也就是区间两端的字符相同，那么我们在打印左侧字符$s[i]$时可以顺带把右侧字符$s[j]$打印，所以此时，$dp[i][j] = dp[i][j - 1]$</li><li>如果$s[i] \neq s[j]$，则需要分别对区间的左右两部分进行打印，记两部分区间为$[i, k]$和$[k + 1, j]$(其中$i \leq k &lt; j$)，此时$dp[i][j] = min_{k=i}^{j - 1}f[i][k] + f[k + 1][j]$。</li></ol><p>总结状态转移方程为:<br>$$<br>dp[i][j] =<br>\left{<br>\begin{aligned}<br>&amp; f[i][j - 1], &amp; s[i] = s[j] \<br>&amp; min_{k=i}^{j - 1}f[i][k] + f[k + 1][j], &amp; s[i] \neq s[j]<br>\end{aligned}<br>\right.<br>$$<br>base case为$dp[i][i] = 1$，对于长度为 1 的区间，需要打印 1 次。</p><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">strangePrinter</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = s.length();<br>        <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--)&#123;<br>            dp[i][i] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j))&#123;<br>                    dp[i][j] = dp[i][j - <span class="hljs-number">1</span>];<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    <span class="hljs-keyword">int</span> minn = Integer.MAX_VALUE;<br>                    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i; k &lt; j; k++)&#123;<br>                        minn = Math.min(minn, dp[i][k] + dp[k + <span class="hljs-number">1</span>][j]);<br>                    &#125;<br>                    dp[i][j] = minn;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dp[<span class="hljs-number">0</span>][n - <span class="hljs-number">1</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>动态规划</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑板异或游戏</title>
    <link href="/2021/05/22/%E9%BB%91%E6%9D%BF%E5%BC%82%E6%88%96%E6%B8%B8%E6%88%8F/"/>
    <url>/2021/05/22/%E9%BB%91%E6%9D%BF%E5%BC%82%E6%88%96%E6%B8%B8%E6%88%8F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/chalkboard-xor-game/">原题链接</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>黑板上写着一个非负整数数组 <code>nums[i]</code> 。Alice 和 Bob 轮流从黑板上擦掉一个数字，Alice 先手。如果擦除一个数字后，剩余的所有数字按位异或运算得出的结果等于 0 的话，当前玩家游戏失败。 (另外，如果只剩一个数字，按位异或运算得到它本身；如果无数字剩余，按位异或运算结果为 0。）</p><p>换种说法就是，轮到某个玩家时，如果当前黑板上所有数字按位异或运算结果等于 0，这个玩家获胜。</p><p>假设两个玩家每步都使用最优解，当且仅当 Alice 获胜时返回 <code>true</code>。</p><span id="more"></span><p><strong>示例：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入: nums = [1, 1, 2]<br>输出: false<br>解释: <br>Alice 有两个选择: 擦掉数字<span class="hljs-number"> 1 </span>或 2。<br>如果擦掉 1, 数组变成 [1, 2]。剩余数字按位异或得到<span class="hljs-number"> 1 </span>XOR<span class="hljs-number"> 2 </span>= 3。那么 Bob 可以擦掉任意数字，因为 Alice 会成为擦掉最后一个数字的人，她总是会输。<br>如果 Alice 擦掉 2，那么数组变成[1, 1]。剩余数字按位异或得到<span class="hljs-number"> 1 </span>XOR<span class="hljs-number"> 1 </span>= 0。Alice 仍然会输掉游戏。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= N &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 2^16</code></li></ul><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><h2 id="情况一：初始时黑板上所有数字异或结果为0"><a href="#情况一：初始时黑板上所有数字异或结果为0" class="headerlink" title="情况一：初始时黑板上所有数字异或结果为0"></a>情况一：初始时黑板上所有数字异或结果为0</h2><p>根据游戏规则，轮到某个玩家时，如果当前黑板上所有数字异或结果等于0，则当前玩家获胜。由于Alice是先手，因此如果初始时黑板上所有数字的异或结果为0，则Alice获胜。</p><h2 id="情况二：初始时黑板上所有数字异或结果不为0"><a href="#情况二：初始时黑板上所有数字异或结果不为0" class="headerlink" title="情况二：初始时黑板上所有数字异或结果不为0"></a>情况二：初始时黑板上所有数字异或结果不为0</h2><p>由于两人交替擦除数字，且每次都恰好擦掉一个数字，因此对于这两人中的任意一人，其每次才擦除数字前，黑板上剩余数字的个数的奇偶性一定是相同的。</p><p>如果$\textit{nums}$的长度为偶数，那么享受Alice是否可能失败呢？</p><p>假设Alice面临失败的状态，则只有一种状况，即无论擦掉哪一个数字，剩余所有数字的异或结果都为0。</p><p>设数组$nums$的长度为$n$，$n$是偶数，用$\oplus$表示异或，记$S$为数组$nums$的全部元素的异或结果，则有<br>$$<br>S = nums[0] \oplus nums[1] \oplus \dots \oplus nums[n - 1] \neq 0<br>$$<br>记$S_i$为擦掉$nums[i]$之后，剩余所有数字的异或结果，则有<br>$$<br>S_i \oplus nums[i] = S<br>$$<br>等式两边同时异或$nums[i]$，由于对任意整数$x$都有$x \oplus x = 0$，得<br>$$<br>S_i = S \oplus nums[i]<br>$$<br>如果无论擦掉哪一个数字，剩余的所有数字异或结果都等于0，则对任意$0 \leq i &lt; n$，都有$S_i = 0$。因此对所有的$S_i$异或结果也等于0，即<br>$$<br>S_0 \oplus S_1 \oplus \dots \oplus S_{n - 1} = 0<br>$$<br>将$S_i = S \oplus nums[i]$代入上式，并根据异或运算的交换律和结合律化简，有<br>$$<br>\begin{aligned}<br>0 &amp;= S_0 \oplus S_1 \oplus \dots \oplus S_{n - 1} \<br>&amp;= (S \oplus nums[0]) \oplus (S \oplus nums[1]) \oplus \dots \oplus(S \oplus nums[n - 1]) \<br>&amp;= (S \oplus S \oplus \dots \oplus S) \oplus (nums[0] \oplus nums[1] \oplus \dots \oplus nums[n-1]) \<br>&amp;= 0 \oplus S \<br>&amp;= S<br>\end{aligned}<br>$$<br>上述计算中，第 33行的左边括号为$n$个$S$异或，由于$n$是偶数，因此$n$个$S$异或的结果是0。</p><p>根据上述计算，可以得到$S=0$，与实际情况$S \ne 0$矛盾。</p><p><strong>因此当数组的长度是偶数时，先手Alice总能找到一个数字，在擦掉这个数字之后剩余的所有数字异或结果不等于0。</strong></p><p>在 Alice 擦掉这个数字后，黑板上剩下奇数个数字，无论 Bob 擦掉哪个数字，留给 Alice 的一定是黑板上剩下偶数个数字，此时 Alice 要么获胜，要么仍可以找到一个数字，在擦掉这个数字之后剩余的所有数字异或结果不等于 0，因此 Alice 总能立于不败之地。</p><p>同理可得，当数组的长度是奇数时，Alice 在擦掉一个数字之后，留给 Bob 的一定是黑板上剩下偶数个数字，因此 Bob 必胜。</p><p>综上所述，当且仅当以下两个条件至少满足一个时，Alice必胜：</p><ul><li>数组$nums$的全部元素的异或结果等于0</li><li>数组$nums$的长度是偶数</li></ul><h1 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">xorGame</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">if</span>((n &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>            sum ^= nums[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>博弈论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>找出第K大的异或坐标值</title>
    <link href="/2021/05/19/%E6%89%BE%E5%87%BA%E7%AC%ACK%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%E5%9D%90%E6%A0%87%E5%80%BC/"/>
    <url>/2021/05/19/%E6%89%BE%E5%87%BA%E7%AC%ACK%E5%A4%A7%E7%9A%84%E5%BC%82%E6%88%96%E5%9D%90%E6%A0%87%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/find-kth-largest-xor-coordinate-value/">原题链接</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个二维矩阵 <code>matrix</code> 和一个整数 <code>k</code> ，矩阵大小为 <code>m x n</code> 由非负整数组成。</p><p>矩阵中坐标 <code>(a, b)</code> 的 <strong>值</strong> 可由对所有满足 <code>0 &lt;= i &lt;= a &lt; m</code> 且 <code>0 &lt;= j &lt;= b &lt; n</code> 的元素 <code>matrix[i][j]</code>（<strong>下标从 0 开始计数</strong>）执行异或运算得到。</p><p>请你找出 <code>matrix</code> 的所有坐标中第 <code>k</code> 大的值（**<code>k</code> 的值从 1 开始计数**）。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[5,2],[1,6]]</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-number">7</span><br>解释：坐标 (<span class="hljs-number">0</span>,<span class="hljs-number">1</span>) 的值是 <span class="hljs-number">5</span> XOR <span class="hljs-number">2</span> = <span class="hljs-number">7</span> ，为最大的值。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[5,2],[1,6]]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-number">5</span><br>解释：坐标 (<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) 的值是 <span class="hljs-number">5</span> = <span class="hljs-number">5</span> ，为第 <span class="hljs-number">2</span> 大的值。<br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs lua">输入：matrix = <span class="hljs-string">[[5,2],[1,6]]</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-number">4</span><br>解释：坐标 (<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) 的值是 <span class="hljs-number">5</span> XOR <span class="hljs-number">1</span> = <span class="hljs-number">4</span> ，为第 <span class="hljs-number">3</span> 大的值。<br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：matrix = [[5,2],[1,6]], k = 4<br>输出：0<br>解释：坐标 (1,1) 的值是<span class="hljs-number"> 5 </span>XOR<span class="hljs-number"> 2 </span>XOR<span class="hljs-number"> 1 </span>XOR<span class="hljs-number"> 6 </span>=<span class="hljs-number"> 0 </span>，为第<span class="hljs-number"> 4 </span>大的值。<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>m == matrix.length</code></li><li><code>n == matrix[i].length</code></li><li><code>1 &lt;= m, n &lt;= 1000</code></li><li><code>0 &lt;= matrix[i][j] &lt;= 106</code></li><li><code>1 &lt;= k &lt;= m * n</code></li></ul><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>因为需要快速获取到每个异或坐标值，需要计算二维数组的二维异或前缀和。</p><p>设二维前缀和是矩阵$matrix$中满足中所有满足$0 \leq x &lt; i$且$0 \leq y &lt; j$的元素执行按位异或运算的结果，则<br>$$<br>pre(i, j) = pre(i - 1, j) \oplus pre(i, j - 1) \oplus pre(i - 1, j - 1) \oplus matrix(i, j)<br>$$<br>下面是二位前缀和的可视化展示。</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210519093919.png" alt="fig1"></p><p>在得到前缀和之后，我们只需要找去其中第K大的元素即可，可以采用快速选择算法进行实现。</p><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><p>在二维前缀和的计算过程中，如果我们正在计算首行或者首列，即$i=0$或$j=0$，此时例如$\textit{pre}(i-1,j-1)$是一个超出下标范围的结果。因此我们可以使用一个$(m+1) \times (n+1)$的二维矩阵，将首行和首列空出来赋予默认值0，并使用接下来的$m$行和$n$列存储二维前缀和，这样就不必进行下标范围的判断了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthLargestValue</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> m = matrix.length;<br>        <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>        <span class="hljs-keyword">int</span>[][] pre = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>        List&lt;Integer&gt; results = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++)&#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++)&#123;<br>                pre[i][j] = pre[i - <span class="hljs-number">1</span>][j] ^ pre[i][j - <span class="hljs-number">1</span>] ^ pre[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] ^ matrix[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>                results.add(pre[i][j]);<br>            &#125;<br>        &#125;<br>        quickSelect(results, <span class="hljs-number">0</span>, results.size() - <span class="hljs-number">1</span>, k - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">return</span> results.get(k - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSelect</span><span class="hljs-params">(List&lt;Integer&gt; results, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, <span class="hljs-keyword">int</span> k)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left == right) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> pivot = (<span class="hljs-keyword">int</span>)(left + Math.random()*(right - left + <span class="hljs-number">1</span>));<br>        swap(results, right, pivot);<br>        <span class="hljs-keyword">int</span> sepl = left - <span class="hljs-number">1</span>, sepr = left - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = left; i &lt;= right; i++)&#123;<br>            <span class="hljs-keyword">if</span>(results.get(i) &gt; results.get(right))&#123;<br>                swap(results, i, ++sepr);<br>                swap(results, sepr, ++sepl);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(results.get(i) == results.get(right))&#123;<br>                swap(results, i, ++sepr);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(left + k &gt; sepl &amp;&amp; left + k &lt;= sepr)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left + k &lt;= sepl)&#123;<br>            quickSelect(results, left, sepl, k);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            quickSelect(results, sepr + <span class="hljs-number">1</span>, right, k - (sepr - left + <span class="hljs-number">1</span>));<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(List&lt;Integer&gt; results, <span class="hljs-keyword">int</span> index1, <span class="hljs-keyword">int</span> index2)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> temp = results.get(index1);<br>        results.set(index1, results.get(index2));<br>        results.set(index2, temp);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>形成两个异或相等数组的三元组数目</title>
    <link href="/2021/05/18/%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE/"/>
    <url>/2021/05/18/%E5%BD%A2%E6%88%90%E4%B8%A4%E4%B8%AA%E5%BC%82%E6%88%96%E7%9B%B8%E7%AD%89%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E6%95%B0%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/count-triplets-that-can-form-two-arrays-of-equal-xor/">原题链接</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>arr</code> 。</p><p>现需要从数组中取三个下标 <code>i</code>、<code>j</code> 和 <code>k</code> ，其中 <code>(0 &lt;= i &lt; j &lt;= k &lt; arr.length)</code> 。</p><p><code>a</code> 和 <code>b</code> 定义如下：</p><ul><li><code>a = arr[i] ^ arr[i + 1] ^ ... ^ arr[j - 1]</code></li><li><code>b = arr[j] ^ arr[j + 1] ^ ... ^ arr[k]</code></li></ul><p>注意：<strong>^</strong> 表示 <strong>按位异或</strong> 操作。</p><p>请返回能够令 <code>a == b</code> 成立的三元组 (<code>i</code>, <code>j</code> , <code>k</code>) 的数目。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gcode">输入：arr = [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]<br>输出：<span class="hljs-number">4</span><br>解释：满足题意的三元组分别是 <span class="hljs-comment">(0,1,2)</span>, <span class="hljs-comment">(0,2,2)</span>, <span class="hljs-comment">(2,3,4)</span> 以及 <span class="hljs-comment">(2,4,4)</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[1,1,1,1,1]</span><br>输出：<span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：arr </span>=<span class="hljs-string"> [2,3]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：arr = <span class="hljs-string">[1,3,5,7,9]</span><br>输出：<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：arr = [<span class="hljs-number">7,11,12,9</span>,<span class="hljs-number">5,2,7,17</span>,<span class="hljs-number">22</span>]<br>输出：<span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 300</code></li><li><code>1 &lt;= arr[i] &lt;= 10^8</code></li></ul><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><h2 id="解法一：二重循环"><a href="#解法一：二重循环" class="headerlink" title="解法一：二重循环"></a>解法一：二重循环</h2><p>因为$a == b$，所以$a \oplus b = arr[i] \oplus arr[i + 1] \oplus \cdots \oplus arr[k] = 0$，可以看出最终结果与$j$是没有关系的，所以一个简单的思路是直接二重循环遍历所有的$i$和$k$值，然后异或值为0是结果增加$k-i$即可。</p><h3 id="代码实现："><a href="#代码实现：" class="headerlink" title="代码实现："></a>代码实现：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countTriplets</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++)&#123;<br>            cur = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = i; k &lt; arr.length; k++)&#123;<br>                cur ^= arr[k];<br>                <span class="hljs-keyword">if</span>(cur == <span class="hljs-number">0</span>)&#123;<br>                    res += (k - i);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(n^2)$，$n$是$arr$数组的长度</li><li>空间复杂度：$O(1)$</li></ul><h2 id="思路二：一重循环"><a href="#思路二：一重循环" class="headerlink" title="思路二：一重循环"></a>思路二：一重循环</h2><p>首先定义长度为$n$的数组$arr$的异或前缀和如下<br>$$<br>S_i = \begin{equation}<br>\left{<br>\begin{aligned}<br>&amp;0,&amp;    &amp;i = 0 \<br>&amp;arr[0] \oplus arr[1] \oplus \cdots \oplus arr[i - 1], &amp;&amp;i \leq i \leq n<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$<br>由该定义可得<br>$$<br>S_i = \begin{equation}<br>\left{<br>\begin{aligned}<br>&amp;0, &amp;&amp;i = 0 \<br>&amp;S_{i - 1} \oplus arr[i-1],&amp;&amp;1 \leq i \leq n<br>\end{aligned}<br>\right.<br>\end{equation}<br>$$<br>对于两个下标不同的异或前缀和$S_i$和$S_j$，设$0 &lt; i &lt; j$，有<br>$$<br>S_i \oplus S_j = (arr[0] \oplus arr[1] \oplus \cdots \oplus arr[i - 1]) \oplus (arr[0] \oplus arr[1] \oplus \cdots \oplus arr[i - 1] \oplus arr[i] \oplus \cdots \oplus arr[j - 1])<br>$$<br>由于异或运算满足结合律和交换律，且任意数组异或自身等于0，上式可简化为：<br>$$<br>S_i \oplus S_j = arr[i] \oplus \cdots \oplus arr[j - 1]<br>$$<br>从而，数组$arr$的子区间$[i, j]$的元素异或和可表示为<br>$$<br>S_i \oplus S_{j+1}<br>$$</p><p>则题目中的$a$和$b$可以表示为：<br>$$<br>a = S_i \oplus S_j \<br>b = S_j \oplus S_{k+1}<br>$$<br>若$a=b$，则有：<br>$$<br>S_i \oplus S_j = S_j \oplus S_{k+1}<br>$$<br>即<br>$$<br>S_i = S_{k+1}<br>$$<br>对于下标$k$，若下标$i = i_1, i_2, \cdots , i_m$时均满足$S_i = S_{k + 1}$，这些二元组$(i_1, k), (i_2, k), \cdots ,(i_m, k)$对答案的贡献之和为<br>$$<br>(k - i_1) + (k - i_2) + \cdots + (k - i_m) = m \cdot k - (i_1 + i_2 + \cdots + i_m)<br>$$<br>也就是说，当遍历下标$k$时，我们需要直到所有满足$S_i = S_{k + 1}$的</p><ul><li>下标$i$的出现次数$m$</li><li>下标$i$之和</li></ul><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">countTriplets</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> n = arr.length;<br>        Map&lt;Integer, Integer&gt; cnt = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>        Map&lt;Integer, Integer&gt; total = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;();<br>        <span class="hljs-keyword">int</span> ans = <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;<br>            <span class="hljs-keyword">int</span> val = arr[k];<br>            <span class="hljs-keyword">if</span> (cnt.containsKey(s ^ val)) &#123;<br>                ans += cnt.get(s ^ val) * k - total.get(s ^ val);<br>            &#125;<br>            cnt.put(s, cnt.getOrDefault(s, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>            total.put(s, total.getOrDefault(s, <span class="hljs-number">0</span>) + k);<br>            s ^= val;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：O(n)<em>O</em>(<em>n</em>)，其中 n<em>n</em> 是数组 \textit{arr}<em>arr</em> 的长度。</li><li>空间复杂度：O(n)<em>O</em>(<em>n</em>)。我们需要使用 O(n)<em>O</em>(<em>n</em>) 的空间存储两个哈希表。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数组中两个数的最大异或值</title>
    <link href="/2021/05/16/%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/"/>
    <url>/2021/05/16/%E6%95%B0%E7%BB%84%E4%B8%AD%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%BC%82%E6%88%96%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array/">题目链接</a></p><h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>给你一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p><p><strong>进阶：</strong>你可以在 <code>O(n)</code> 的时间解决这个问题吗？</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：nums = [3,10,5,25,2,8]<br>输出：28<br>解释：最大运算结果是<span class="hljs-number"> 5 </span>XOR<span class="hljs-number"> 25 </span>= 28.<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [0]</span><br><span class="hljs-string">输出：0</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [2,4]</span><br><span class="hljs-string">输出：6</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">输入：nums </span>=<span class="hljs-string"> [8,10,2]</span><br><span class="hljs-string">输出：10</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">14,70,53,83</span>,<span class="hljs-number">49,91,36,80</span>,<span class="hljs-number">92,51,66,70</span>]<br>输出：<span class="hljs-number">127</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 231 - 1</code></li></ul><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><p>假设从数组中选择了元素$a_i$和$a_j$（$i \neq j$），异或值<code>x</code>的计算方法是<br>$$<br>x = a_i \oplus a_j<br>$$<br>最简单的方法就是直接一个二重循环枚举i和j，然后依次计算异或值并且与当前最大值进行比较，但是这样的时间复杂度为$O(n^2)$，需要对采用更高效的算法。</p><p>根据位异或运算的性质，$x = a_i \oplus a_j$等价于$a_j = x \oplus a_i$。我们可以根据该等式变换从高位到低位确定x的每一位，从而最终得出x的值。该方法的精妙之处：</p><ul><li>由于数组中的元素都在 $[0, 2^{31})$ 的范围内，那么我们可以将每一个数表示为一个长度为31位的二进制数（如果不满31位，在最高位之前补上若干个前导0即可）；</li><li>这31个二进制位从低位到高位依次编号为 $0, 1, \cdots, 30$。我们从最高位第 30 个二进制位开始，依次确定 <code>x</code> 的每一位是 0 还是 1；</li><li>由于我们需要找出最大的<code>x</code>，因此在枚举每一位时，我们先判断<code>x</code>的这一位是否能取到1。如果能，我们取这一位为1，否则我们取这一位为0。</li></ul><p>「判断<code>x</code>的某一位是否能取到 1」这一步骤并不容易。下面介绍两种判断的方法。</p><h2 id="方法一：哈希表"><a href="#方法一：哈希表" class="headerlink" title="方法一：哈希表"></a>方法一：哈希表</h2><h3 id="思路与算法"><a href="#思路与算法" class="headerlink" title="思路与算法"></a>思路与算法</h3><p>假设我们已经确定了<code>x</code>最高的若干个二进制位，当前正在确定第<code>k</code>个二进制位，根据之前的分析，我们希望第<code>k</code>个二进制位能够取到1。</p><p>我们用$pre^k(x)$表示$x$从最高位第30个二进制位开始，到第$k$个二进制位为止的数，那么$a_j = x \oplus a_i$蕴含着：<br>$$<br>pre^k(a_j) = pre^k(x) \oplus pre^k(a_i)<br>$$<br>由于$pre^k(x)$对于我们来说是已知的，因此我们将所有的$pre^k(a_j)$放入哈希表中，随后枚举$i$并计算$pre^k(x) \oplus pre^k(a_i)$。如果其出现在哈希表中，那么说明第$k$个二进制位能够取到1，否则第$k$个二进制位只能为0。</p><h3 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h3><p>计算$pre^k(x)$可以使用右移运算$&gt;&gt;$。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-comment">// 最高位的二进制位编号为 30</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> HIGH_BIT = <span class="hljs-number">30</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMaximumXOR</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = HIGH_BIT; k &gt;= <span class="hljs-number">0</span>; --k) &#123;<br>            Set&lt;Integer&gt; seen = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>            <span class="hljs-comment">// 将所有的 pre^k(a_j) 放入哈希表中</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>                <span class="hljs-comment">// 如果只想保留从最高位开始到第 k 个二进制位为止的部分</span><br>                <span class="hljs-comment">// 只需将其右移 k 位</span><br>                seen.add(num &gt;&gt; k);<br>            &#125;<br><br>            <span class="hljs-comment">// 目前 x 包含从最高位开始到第 k+1 个二进制位为止的部分</span><br>            <span class="hljs-comment">// 我们将 x 的第 k 个二进制位置为 1，即为 x = x*2+1</span><br>            <span class="hljs-keyword">int</span> xNext = x * <span class="hljs-number">2</span> + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">boolean</span> found = <span class="hljs-keyword">false</span>;<br>            <br>            <span class="hljs-comment">// 枚举 i</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>                <span class="hljs-keyword">if</span> (seen.contains(xNext ^ (num &gt;&gt; k))) &#123;<br>                    found = <span class="hljs-keyword">true</span>;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span> (found) &#123;<br>                x = xNext;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 如果没有找到满足等式的 a_i 和 a_j，那么 x 的第 k 个二进制位只能为 0</span><br>                <span class="hljs-comment">// 即为 x = x*2</span><br>                x = xNext - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><ul><li>时间复杂度：$O(n \log C)$，其中<code>n</code>是数组 $\textit{nums}$ 的长度，<code>C</code>是数组中的元素范围，在本题中 $C &lt; 2^{31}$。枚举答案<code>x</code>的每一个二进制位的时间复杂度为 $O(\log C)$，在每一次枚举的过程中，我们需要$O(n)$的时间进行判断，因此总时间复杂度为$O(n \log C)$。</li><li>空间复杂度：$O(n)$，即为哈希表需要使用的空间。</li></ul>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机中信息的表示和处理</title>
    <link href="/2021/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/"/>
    <url>/2021/05/15/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E4%BF%A1%E6%81%AF%E7%9A%84%E8%A1%A8%E7%A4%BA%E5%92%8C%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p>[TOC]</p><h1 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h1><p>大部分计算机使用8位的块，或叫作<strong>字节（byte）</strong>，来作为最小的可寻址的存储器单位，而不是访问存储器中单独的位。机器级程序将存储器视为一个非常大的字节数组，称为<strong>虚拟存储器（virtual memory）</strong>。存储器的每个字节都由一个唯一的数字来标识，称为<strong>它的地址（address）</strong>，所有可能地址的集合就称为<strong>虚拟地址空间（virtual address space）</strong>。</p><p>编译器和运行时系统的一个任务就是将这个存储器空间划分为更可管理的单元=，来存放不同的<strong>程序对象（program object）</strong>，也就是，程序数据、指令和控制信息。</p><span id="more"></span><h2 id="十六进制表示法"><a href="#十六进制表示法" class="headerlink" title="十六进制表示法"></a>十六进制表示法</h2><table><thead><tr><th>十六进制数字</th><th>十进制值</th><th>二进制值</th></tr></thead><tbody><tr><td>0</td><td>0</td><td>0000</td></tr><tr><td>1</td><td>1</td><td>0001</td></tr><tr><td>2</td><td>2</td><td>0010</td></tr><tr><td>3</td><td>3</td><td>0011</td></tr><tr><td>4</td><td>4</td><td>0100</td></tr><tr><td>5</td><td>5</td><td>0101</td></tr><tr><td>6</td><td>6</td><td>0110</td></tr><tr><td>7</td><td>7</td><td>0111</td></tr><tr><td>8</td><td>8</td><td>1000</td></tr><tr><td>9</td><td>9</td><td>1001</td></tr><tr><td>A</td><td>10</td><td>1010</td></tr><tr><td>B</td><td>11</td><td>1011</td></tr><tr><td>C</td><td>12</td><td>1100</td></tr><tr><td>D</td><td>13</td><td>1101</td></tr><tr><td>E</td><td>14</td><td>1110</td></tr><tr><td>F</td><td>15</td><td>1111</td></tr></tbody></table><p>一个字节的值域：</p><p>$$<br>\begin{aligned}<br>&amp; 二进制：00000000_2 \sim 11111111_2 \<br>&amp; 十进制：0_{10} \sim 255_{10} \<br>&amp; 十六进制：00_{16} \sim FF_{16}<br>\end{aligned}<br>$$</p><h3 id="十六进制转二进制"><a href="#十六进制转二进制" class="headerlink" title="十六进制转二进制"></a>十六进制转二进制</h3><p>将每个十六进制数字展开成四位二进制然后拼接</p><p>例：转化 <code>0x173A4C</code><br>$$<br>\begin{aligned}<br>&amp; 十六进制 &amp; &amp;\ 1\ &amp;      &amp;\ 7\ &amp;   &amp;\ 3\ &amp;    &amp;\ A\ &amp;    &amp;\ 4\ &amp;   &amp;\ C\ &amp;\<br>&amp; 二进制 &amp;   &amp;\ 0001\ &amp; &amp;\ 0111\ &amp; &amp;\ 0011\ &amp; &amp;\ 1010\ &amp; &amp;\ 0100\ &amp; &amp;\ 1100\ &amp;<br>\end{aligned}<br>$$</p><h3 id="二进制转十六进制"><a href="#二进制转十六进制" class="headerlink" title="二进制转十六进制"></a>二进制转十六进制</h3><p>从后往前每四位二进制转化为一位十六进制数字</p><p>如果怕总数不是四的倍数，最左边的一组可以少于四位，前面用零补足</p><p>例：转化<code>1111001010110110110011</code><br>$$<br>\begin{aligned}<br>&amp;二进制&amp;&amp;\ 11&amp;&amp;\ 1100&amp;&amp;\ 1010&amp;&amp;\ 1101&amp;&amp;\ 1011&amp;&amp;\ 0011&amp;  \<br>&amp;十六进制&amp;&amp;\ 3&amp;&amp;\ C&amp;&amp;\ A&amp;&amp;\ D&amp;&amp;\ B&amp;&amp;\ 3&amp;<br>\end{aligned}<br>$$</p><h2 id="字"><a href="#字" class="headerlink" title="字"></a>字</h2><p>每台计算机都有一个<strong>字长（word size）</strong>，对于一个字长为<code>n</code>位的机器来说，虚拟地址的范围为$0\sim2^n-1$,程序最多访问$2^n$字节。</p><p>今天的计算机基本是32位和64位的。</p><h2 id="寻址和字节顺序"><a href="#寻址和字节顺序" class="headerlink" title="寻址和字节顺序"></a>寻址和字节顺序</h2><h3 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h3><p>在几乎所有的机器中，多字节对象都被存储为连续的字节序列，对象的地址所使用字节序列中最小的地址。</p><h3 id="字节序列排序"><a href="#字节序列排序" class="headerlink" title="字节序列排序"></a>字节序列排序</h3><ol><li><strong>小端法（little endian）</strong>：最低有效字节在最前面</li><li><strong>大端法（big endian）</strong>：最高有效字节在最前面</li></ol>]]></content>
    
    
    <categories>
      
      <category>计算机系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>信息表示</tag>
      
      <tag>信息处理</tag>
      
      <tag>计算机系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>括号生成</title>
    <link href="/2021/05/13/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/"/>
    <url>/2021/05/13/%E6%8B%AC%E5%8F%B7%E7%94%9F%E6%88%90/</url>
    
    <content type="html"><![CDATA[<h1 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h1><p><a href="https://leetcode-cn.com/problems/generate-parentheses/">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">3</span><br>输出：[<span class="hljs-string">&quot;((()))&quot;</span>,<span class="hljs-string">&quot;(()())&quot;</span>,<span class="hljs-string">&quot;(())()&quot;</span>,<span class="hljs-string">&quot;()(())&quot;</span>,<span class="hljs-string">&quot;()()()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">输入：<span class="hljs-built_in">n</span> = <span class="hljs-number">1</span><br>输出：[<span class="hljs-string">&quot;()&quot;</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>有关括号问题有如下两个性质：</p><ol><li><strong>一个“合法”括号组合的左括号数量一定等于右括号数量。</strong></li><li><strong>对于一个“合法”的括号字符串组合<code>p</code>，必然对于任何<code>0 &lt;= i &lt; len(p)</code>都有：子串<code>p[0..i]</code>中左括号的数量都大于或等于右括号的数量。</strong></li></ol><p>因此可以联想到深搜算法，将其转化为如下问题：</p><p><strong>现在有<code>2n</code>个位置，每个位置可以防止字符<code>(</code>或者<code>)</code>，组成的所有括号组合中，有多少个是合法的？</strong></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    List&lt;String&gt; res = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        dfs(n, n, <span class="hljs-keyword">new</span> StringBuilder());<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right, StringBuilder track)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(left &lt; <span class="hljs-number">0</span> || right &lt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(right &lt; left) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>(left == <span class="hljs-number">0</span> &amp;&amp; right == <span class="hljs-number">0</span>)&#123;<br>            res.add(track.toString());<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        track.append(<span class="hljs-string">&quot;(&quot;</span>);<br>        dfs(left - <span class="hljs-number">1</span>, right, track);<br>        track.deleteCharAt(track.length() - <span class="hljs-number">1</span>);<br><br>        track.append(<span class="hljs-string">&quot;)&quot;</span>);<br>        dfs(left, right - <span class="hljs-number">1</span>, track);<br>        track.deleteCharAt(track.length() - <span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>K个一组翻转链表</title>
    <link href="/2021/05/12/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2021/05/12/K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="K个一组翻转链表"><a href="#K个一组翻转链表" class="headerlink" title="K个一组翻转链表"></a>K个一组翻转链表</h1><p><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个链表，每 <em>k</em> 个节点一组进行翻转，请你返回翻转后的链表。</p><p><em>k</em> 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 <em>k</em> 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><span id="more"></span><p><strong>进阶：</strong></p><ul><li>你可以设计一个只使用常数额外空间的算法来解决此问题吗？</li><li><strong>你不能只是单纯的改变节点内部的值</strong>，而是需要实际进行节点交换。</li></ul><p> <strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">2</span><br>输出：<span class="hljs-string">[2,1,4,3,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg" alt="img"></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">3</span><br>输出：<span class="hljs-string">[3,2,1,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：head = <span class="hljs-string">[1,2,3,4,5]</span>, k = <span class="hljs-number">1</span><br>输出：<span class="hljs-string">[1,2,3,4,5]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：head = <span class="hljs-comment">[1]</span>, k = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li>列表中节点的数量在范围 <code>sz</code> 内</li><li><code>1 &lt;= sz &lt;= 5000</code></li><li><code>0 &lt;= Node.val &lt;= 1000</code></li><li><code>1 &lt;= k &lt;= sz</code></li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>因为每次需要翻转K个数据，所以可以首先实现一个翻转指定区间<code>[a, b)</code>内的数据，只需要将标准的翻转函数的判断条件<code>cur == null</code>修改为<code>cur == b</code>即可实现，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode a, ListNode b)</span></span>&#123;<br>        ListNode pre = <span class="hljs-keyword">null</span>, cur = a, nxt;<br>        <span class="hljs-keyword">while</span>(cur != b)&#123;<br>            nxt = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后每次获取到一组的右端端点即可完成K个一组翻转，不足时则不翻转，函数实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        ListNode a, b;<br>        a = b = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            <span class="hljs-keyword">if</span>(b == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;<br>            b = b.next;<br>        &#125;<br>        ListNode newHead = reverse(a, b);<br>        a.next = reverseKGroup(b, k);<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode a, ListNode b)</span></span>&#123;<br>        ListNode pre = <span class="hljs-keyword">null</span>, cur = a, nxt;<br>        <span class="hljs-keyword">while</span>(cur != b)&#123;<br>            nxt = cur.next;<br>            cur.next = pre;<br>            pre = cur;<br>            cur = nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        ListNode a, b;<br>        a = b = head;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++)&#123;<br>            <span class="hljs-keyword">if</span>(b == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">return</span> head;<br>            b = b.next;<br>        &#125;<br>        ListNode newHead = reverse(a, b);<br>        a.next = reverseKGroup(b, k);<br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>滑动窗口的最大值</title>
    <link href="/2021/05/12/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
    <url>/2021/05/12/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h1><p><a href="https://leetcode-cn.com/problems/sliding-window-maximum/">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 <code>nums</code>，有一个大小为 <code>k</code> 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 <code>k</code> 个数字。滑动窗口每次只向右移动一位。</p><p>返回滑动窗口中的最大值。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs subunit">输入：nums = [1,3,<span class="hljs-string">-1</span>,<span class="hljs-string">-3</span>,5,3,6,7], k = 3<br>输出：[3,3,5,5,6,7]<br>解释：<br>滑动窗口的位置                最大值<br>---------------               -----<br>[1  3  <span class="hljs-string">-1</span>] <span class="hljs-string">-3</span>  5  3  6  7       3<br> 1 [3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>] 5  3  6  7       3<br> 1  3 [<span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5] 3  6  7       5<br> 1  3  <span class="hljs-string">-1</span> [<span class="hljs-string">-3</span>  5  3] 6  7       5<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span> [5  3  6] 7       6<br> 1  3  <span class="hljs-string">-1</span>  <span class="hljs-string">-3</span>  5 [3  6  7]      7<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1]</span>, k = 1<br>输出：<span class="hljs-comment">[1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[1,-1]</span>, k = 1<br>输出：<span class="hljs-comment">[1,-1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 4：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[9,11]</span>, k = 2<br>输出：<span class="hljs-comment">[11]</span><br></code></pre></td></tr></table></figure><p><strong>示例 5：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：nums = <span class="hljs-comment">[4,-2]</span>, k = 2<br>输出：<span class="hljs-comment">[4]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 105</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>1 &lt;= k &lt;= nums.length</code></li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><ol><li>首先，最简单也是最暴力的，每次进行扫描，并判断出最大值，但是时间复杂度太高，达到<code>O(nk)</code></li><li>我们考虑对扩大和缩小窗口进行优化，使得每次获得最大值的操作的时间复杂度为<code>O(1)</code></li><li>由此我们想到可以维护一个数据结构使得获取最大值的操作尽可能地简单，这里可以采用单调队列结构</li><li>每次扩张窗口时从队列尾部进行判断，将比当前值小的数出队，直到队列为空或者队尾元素比当前值大，然后当前值入栈，这样队列里的元素就呈递减排列，并且越靠近队头插入时间越早。</li><li>由上可知，我们每次获取最大值时直接获取队头元素即可，并且缩小窗口时，只需要判断删除的那个值是否是队头元素即可，是的话就队头元素出队。</li><li>为了能够方便地从两端都进行插入和删除，采用双端队列进行单调队列的实现。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>        Deque&lt;Integer&gt; q = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span> t = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(i &lt; k - <span class="hljs-number">1</span>)&#123;<br>                <span class="hljs-keyword">while</span>(!q.isEmpty() &amp;&amp; q.getLast() &lt; nums[i])&#123;<br>                    q.pollLast();<br>                &#125;<br>                q.addLast(nums[i]);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">while</span>(!q.isEmpty() &amp;&amp; q.getLast() &lt; nums[i])&#123;<br>                    q.pollLast();<br>                &#125;<br>                q.addLast(nums[i]);<br>                res[t++] = q.getFirst();<br>                <span class="hljs-keyword">if</span>(nums[i - k + <span class="hljs-number">1</span>] == q.getFirst())&#123;<br>                    q.pollFirst();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>单调队列</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>子数组异或查询</title>
    <link href="/2021/05/12/%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/"/>
    <url>/2021/05/12/%E5%AD%90%E6%95%B0%E7%BB%84%E5%BC%82%E6%88%96%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="子数组异或查询"><a href="#子数组异或查询" class="headerlink" title="子数组异或查询"></a>子数组异或查询</h1><p><a href="https://leetcode-cn.com/problems/xor-queries-of-a-subarray/">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>有一个正整数数组 <code>arr</code>，现给你一个对应的查询数组 <code>queries</code>，其中 <code>queries[i] = [Li, Ri]</code>。</p><p>对于每个查询 <code>i</code>，请你计算从 <code>Li</code> 到 <code>Ri</code> 的 <strong>XOR</strong> 值（即 <code>arr[Li] xor arr[Li+1] xor ... xor arr[Ri]</code>）作为本次查询的结果。</p><p>并返回一个包含给定查询 <code>queries</code> 所有结果的数组。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs tap">输入：arr = [1,3,4,8], queries = [[0,1],[1,2],[0,3],[3,3]]<br>输出：[2,7,14,8] <br>解释：<br>数组中元素的二进制表示形式是：<br>1 =<span class="hljs-number"> 0001 </span><br>3 =<span class="hljs-number"> 0011 </span><br>4 =<span class="hljs-number"> 0100 </span><br>8 =<span class="hljs-number"> 1000 </span><br>查询的 XOR 值为：<br>[0,1] =<span class="hljs-number"> 1 </span>xor<span class="hljs-number"> 3 </span>=<span class="hljs-number"> 2 </span><br>[1,2] =<span class="hljs-number"> 3 </span>xor<span class="hljs-number"> 4 </span>=<span class="hljs-number"> 7 </span><br>[0,3] =<span class="hljs-number"> 1 </span>xor<span class="hljs-number"> 3 </span>xor<span class="hljs-number"> 4 </span>xor<span class="hljs-number"> 8 </span>=<span class="hljs-number"> 14 </span><br>[3,3] = 8<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：arr = <span class="hljs-comment">[4,8,2,10]</span>, queries = <span class="hljs-comment">[<span class="hljs-comment">[2,3]</span>,<span class="hljs-comment">[1,3]</span>,<span class="hljs-comment">[0,0]</span>,<span class="hljs-comment">[0,3]</span>]</span><br>输出：<span class="hljs-comment">[8,0,4,4]</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= arr.length &lt;= 3 * 10^4</code></li><li><code>1 &lt;= arr[i] &lt;= 10^9</code></li><li><code>1 &lt;= queries.length &lt;= 3 * 10^4</code></li><li><code>queries[i].length == 2</code></li><li><code>0 &lt;= queries[i][0] &lt;= queries[i][1] &lt; arr.length</code></li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>看到这个，可能首先想到的是每次读出左右边界并进行异或计算，然后存到数组里。</p><p>不妨先假设<code>arr</code>的数组长度为<code>m</code>，<code>queries</code>的数组长度为<code>n</code>，则每次进行查询的最差时间复杂度为<code>O(m)</code>，总的时间复杂度为<code>O(nm)</code>，时间复杂度太高。</p><p>需要对其进行优化，从而使得每次查询操作的时间复杂度降为<code>O(1)</code>。</p><p>这里就需要保存一个<strong>前缀异或数组</strong><code>xors</code>。该数组的长度为<code>m+1</code>，计算过程如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">xors[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>xors[i + <span class="hljs-number">1</span>] = xors[i] ^ arr[i];<br></code></pre></td></tr></table></figure><p>即<code>xors[i]</code>保存的是索引从<code>0</code>到<code>i - 1</code>的<code>arr</code>数组的异或值。</p><p>设每次计算的左右边界分别为<code>left</code>和<code>right</code>，然后需要计算的值如下：<br>$$<br>\begin{aligned}<br>res[i] &amp;= arr[left] \oplus arr[left + 1] \oplus … \oplus arr[right] \<br>&amp;= (arr[0] \oplus arr[1] \oplus…\oplus arr[left - 1]) \oplus (arr[0] \oplus arr[1] \oplus…\oplus arr[left - 1]) \<br>&amp;\oplus (arr[left] \oplus arr[left + 1] \oplus … \oplus arr[right]) \<br>&amp;= xors[left] \oplus xors[right + 1]<br>\end{aligned}<br>$$</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] xorQueries(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span>[][] queries) &#123;<br>        <span class="hljs-keyword">int</span> m = arr.length;<br>        <span class="hljs-keyword">int</span> n = queries.length;<br>        <span class="hljs-keyword">int</span>[] xor = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">int</span>[] res = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        xor[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++i)&#123;<br>            xor[i] = xor[i - <span class="hljs-number">1</span>] ^ arr[i - <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span> ; i &lt; n; i++)&#123;<br>            res[i] = xor[queries[i][<span class="hljs-number">0</span>]] ^ xor[queries[i][<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>];<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解码异或后的排列</title>
    <link href="/2021/05/11/%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97/"/>
    <url>/2021/05/11/%E8%A7%A3%E7%A0%81%E5%BC%82%E6%88%96%E5%90%8E%E7%9A%84%E6%8E%92%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h1 id="解码异或后的排列"><a href="#解码异或后的排列" class="headerlink" title="解码异或后的排列"></a>解码异或后的排列</h1><p><a href="https://leetcode-cn.com/problems/decode-xored-permutation/">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个整数数组 <code>perm</code> ，它是前 <code>n</code> 个正整数的排列，且 <code>n</code> 是个 <strong>奇数</strong> 。</p><p>它被加密成另一个长度为 <code>n - 1</code> 的整数数组 <code>encoded</code> ，满足 <code>encoded[i] = perm[i] XOR perm[i + 1]</code> 。比方说，如果 <code>perm = [1,3,2]</code> ，那么 <code>encoded = [2,1]</code> 。</p><p>给你 <code>encoded</code> 数组，请你返回原始数组 <code>perm</code> 。题目保证答案存在且唯一。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs inform7">输入：encoded = <span class="hljs-comment">[3,1]</span><br>输出：<span class="hljs-comment">[1,2,3]</span><br>解释：如果 perm = <span class="hljs-comment">[1,2,3]</span> ，那么 encoded = <span class="hljs-comment">[1 XOR 2,2 XOR 3]</span> = <span class="hljs-comment">[3,1]</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：encoded = [<span class="hljs-number">6,5,4,6</span>]<br>输出：[<span class="hljs-number">2,4,1,5</span>,<span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>3 &lt;= n &lt; 105</code></li><li><code>n</code> 是奇数。</li><li><code>encoded.length == n - 1</code></li></ul><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><ol><li>由于perm是前<code>n</code>个正整数的排列，所以我们可以轻松的获得所有数的异或值<br>$total = 1\ XOR\ 2\ XOR\ 3\ XOR\ …\ XOR\ n$</li><li>我们可以观察<code>encoded</code>数组的规律如下：<br>$encoded[0] = perm[0]\ XOR\ perm[1]$<br>$encoded[1] = perm[1]\ XOR\ perm[2]$<br>$encoded[2] = perm[2]\ XOR\ perm[3]$<br>$encoded[3] = perm[3]\ XOR\ perm[4]$<br>…<br>根据观察可知，我们只取奇数进行异或操作的话就可以得到不包含<code>perm[0]</code>的其他所有数的异或，该值与之前的<code>total</code>异或可以得到<code>perm[0]</code>的值，然后根据规律与<code>encoded</code>数组依次异或就可以得到<code>perm</code>数组的每个值（<font color='red'>需要注意因为<code>n</code>是一个奇数，所以<code>n-1</code>必定是一个偶数，所以encoded中的奇数下标个数和偶数下标个数是相同的</font>）</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] decode(<span class="hljs-keyword">int</span>[] encoded) &#123;<br>        <span class="hljs-keyword">int</span> n = encoded.length + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span>[] perm = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n];<br>        <span class="hljs-keyword">int</span> total = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)&#123;<br>            total ^= i;<br>        &#125;<br>        <span class="hljs-keyword">int</span> odd = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i += <span class="hljs-number">2</span>)&#123;<br>            odd ^= encoded[i];<br>        &#125;<br>        perm[<span class="hljs-number">0</span>] = total ^ odd;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++)&#123;<br>            perm[i + <span class="hljs-number">1</span>] = perm[i] ^ encoded[i];<br>        &#125;<br>        <span class="hljs-keyword">return</span> perm;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>位运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LFU算法设计</title>
    <link href="/2021/05/07/LFU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/05/07/LFU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="LFU算法设计"><a href="#LFU算法设计" class="headerlink" title="LFU算法设计"></a>LFU算法设计</h1><h2 id="机制简介"><a href="#机制简介" class="headerlink" title="机制简介"></a>机制简介</h2><p>根据访问频度进行淘汰的缓存淘汰机制，每次淘汰那些使用次数最少的数据。</p><p>当遇到多个访问次数相同时，删除最早插入的那个。</p><span id="more"></span><h2 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h2><p>根据LFU的算法逻辑，其需要满足以下几个条件：</p><ol><li>调用<code>get(key)</code>方法时，要返回<code>key</code>对应的<code>val</code>。</li><li>只要用<code>get</code>或者<code>put</code>方法访问一次某个<code>key</code>，该<code>key</code>的<code>freq</code>就要加一。</li><li>如果在容量满了之后继续插入，则需要将<code>frep</code>最小的<code>key</code>删除，如果最小的<code>freq</code>对应着多个<code>key</code>，则删除其中最旧的那个。</li></ol><p>因为我们需要在<code>O(1)</code>的时间复杂度内完成以上操作，所以下面对以上的条件进行具体分析：</p><ol><li>使用一个<code>HashMap</code>存储<code>key</code>到<code>val</code>的映射，就可以快速计算<code>get(key)。</code><br><code>HashMap&lt;Integer, Integer&gt; keyToVal;</code></li><li>使用一个<code>HashMap</code>存储<code>key</code>到<code>freq</code>的映射，就可以快速操作<code>key</code>对应的<code>freq</code>。<br><code>HashMap&lt;Integer, Integer&gt; keyToFreq;</code></li><li>该部分为LFU算法的核心，分为以下几点:<ol><li>需要<code>freq</code>到<code>key</code>的映射</li><li>将<code>freq</code>最小的<code>key</code>删除，那么就应该能够快速得到当前所有<code>key</code>最小的<code>freq</code>是多少。想要时间复杂度<code>O(1)</code>的话，肯定不能遍历，需要使用一个遍历<code>minFreq</code>来记录当前最小的<code>freq</code>。</li><li>可能有多个<code>key</code>拥有相同的<code>freq</code>，所以<code>freq</code>对<code>key</code>是一对多的关系，一个<code>freq</code>对应着一个<code>key</code>的列表</li><li>希望<code>freq</code>对应的<code>key</code>的列表是存在时序的，便于快速查找并删除最旧的<code>key</code>。</li><li>希望能够快速删除<code>key</code>列表中的任何一个<code>key</code>，因为如果频次为<code>freq</code>的某个<code>key</code>被访问，那么它的频度就会变为<code>freq+1</code>，就应该从<code>freq</code>对应的<code>key</code>列表中删除，加到<code>freq+1</code>对应的<code>key</code>列表里。<br><code>HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;</code><br><code>int minFreq = 0;</code></li></ol></li></ol><p>基本数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.LinkedHashSet;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LFUCache</span> </span>&#123;<br>    <span class="hljs-comment">//key到val的映射</span><br>    HashMap&lt;Integer, Integer&gt; keyToVal;<br>    <span class="hljs-comment">//key到freq的映射</span><br>    HashMap&lt;Integer, Integer&gt; keyToFreq;<br>    <span class="hljs-comment">//freq到key表的映射</span><br>    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKey;<br>    <span class="hljs-comment">//记录最小的频次</span><br>    <span class="hljs-keyword">int</span> minFreq;<br>    <span class="hljs-comment">//记录LFU缓存的最大容量</span><br>    <span class="hljs-keyword">int</span> cap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LFUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span></span>&#123;<br>        keyToVal = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        keyToFreq = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        freqToKey = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        cap = capacity;<br>        minFreq = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span>&#123;&#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="代码框架"><a href="#代码框架" class="headerlink" title="代码框架"></a>代码框架</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.LinkedHashSet;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LFUCache</span> </span>&#123;<br>    <span class="hljs-comment">//key到val的映射</span><br>    HashMap&lt;Integer, Integer&gt; keyToVal;<br>    <span class="hljs-comment">//key到freq的映射</span><br>    HashMap&lt;Integer, Integer&gt; keyToFreq;<br>    <span class="hljs-comment">//freq到key表的映射</span><br>    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; freqToKeys;<br>    <span class="hljs-comment">//记录最小的频次</span><br>    <span class="hljs-keyword">int</span> minFreq;<br>    <span class="hljs-comment">//记录LFU缓存的最大容量</span><br>    <span class="hljs-keyword">int</span> cap;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LFUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span></span>&#123;<br>        keyToVal = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        keyToFreq = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        freqToKeys = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        cap = capacity;<br>        minFreq = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!keyToVal.containsKey(key))&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//访问一次增加key对应的频度</span><br>        increaseFreq(key);<br>        <span class="hljs-keyword">return</span> keyToVal.get(key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(cap &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-comment">//若key已经存在，则修改对应的val即可</span><br>        <span class="hljs-keyword">if</span>(keyToVal.containsKey(key))&#123;<br>            keyToVal.put(key, value);<br>            <span class="hljs-comment">//对应的频度加一</span><br>            increaseFreq(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//key不存在，需要插入</span><br>        <span class="hljs-comment">//容量义满的话需要淘汰一个freq最小的key</span><br>        <span class="hljs-keyword">if</span>(cap &lt;= keyToVal.size())&#123;<br>            removeMinFreqKey();<br>        &#125;<br>        <span class="hljs-comment">//插入key和val，对应的freq为一</span><br>        <span class="hljs-comment">//插入KV表</span><br>        keyToVal.put(key, value);<br>        <span class="hljs-comment">//插入KF表</span><br>        keyToFreq.put(key, <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//插入FK表</span><br>        freqToKeys.putIfAbsent(<span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;());<br>        freqToKeys.get(<span class="hljs-number">1</span>).add(key);<br>        <span class="hljs-comment">//插入新key后最小频度为1</span><br>        minFreq = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increaseFreq</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> freq = keyToFreq.get(key);<br>        <span class="hljs-comment">//更新KF表</span><br>        keyToFreq.put(key, freq + <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//更新FK表</span><br>        <span class="hljs-comment">//将key从freq对应的列表中删除</span><br>        freqToKeys.get(freq).remove(key);<br>        <span class="hljs-comment">//将key加入freq+1对应的列表中</span><br>        freqToKeys.putIfAbsent(freq + <span class="hljs-number">1</span>, <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;());<br>        freqToKeys.get(freq + <span class="hljs-number">1</span>).add(key);<br>        <span class="hljs-comment">//如果freq对应的列表空了，移除这个freq</span><br>        <span class="hljs-keyword">if</span>(freqToKeys.get(freq).isEmpty())&#123;<br>            freqToKeys.remove(freq);<br>            <span class="hljs-comment">//如果这个freq恰好是minFreq，更新minFreq</span><br>            <span class="hljs-keyword">if</span>(freq == minFreq)&#123;<br>                minFreq++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeMinFreqKey</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//获取频度最小的列表</span><br>        LinkedHashSet&lt;Integer&gt; keyList = freqToKeys.get(minFreq);<br>        <span class="hljs-comment">//最先被插入的那个key就是被淘汰的key</span><br>        <span class="hljs-keyword">int</span> deletedKey = keyList.iterator().next();<br>        <span class="hljs-comment">//更新Fk表</span><br>        keyList.remove(deletedKey);<br>        <span class="hljs-keyword">if</span>(keyList.isEmpty())&#123;<br>            freqToKeys.remove(minFreq);<br>            <span class="hljs-comment">//此处没有必要更新minFreq，因为remove是在put之前的，put会更新minFreq</span><br>        &#125;<br>        <span class="hljs-comment">//更新KV表</span><br>        keyToVal.remove(deletedKey);<br>        <span class="hljs-comment">//更新KF表</span><br>        keyToFreq.remove(deletedKey);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>LFU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LRU算法设计</title>
    <link href="/2021/05/07/LRU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/05/07/LRU%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="LRU缓存算法设计"><a href="#LRU缓存算法设计" class="headerlink" title="LRU缓存算法设计"></a>LRU缓存算法设计</h1><h2 id="机制简单介绍"><a href="#机制简单介绍" class="headerlink" title="机制简单介绍"></a>机制简单介绍</h2><p>每次放入缓存中的数据会到队列头，如果满了会将队列尾部的删除，每次访问的也放到队列头，也就是根据访问的时序来进行淘汰。</p><span id="more"></span><h2 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h2><p><code>LRUCache</code>数据结构需要满足以下几点：</p><ol><li>其中的元素必须有时序，用来区分最近使用和久未使用的数据，容量满了之后要删除最久未使用的那个元素来腾位置。</li><li>能够迅速地判断<code>key</code>是否存在，并且得到对应的<code>val</code></li><li>每次访问某个<code>key</code>时，需要将这个元素变为最近使用的，也就是该数据结构需要支持在任意位置快速插入和删除元素</li></ol><p>满足以上条件的数据结构为<code>LinkedHashMap</code>，根据该结构对以上的条件进行分析：</p><ol><li>如果默认从链表尾部添加元素，那么显然越靠近尾部的元素就越是最近使用地，越靠近头部的元素就是越久未使用的。</li><li>对于某个<code>key</code>，可以通过哈希表快速定位到链表中的节点，从未取得对应的<code>val</code></li><li>链表支持在任意位置快速插入和删除</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="自己实现双向链表"><a href="#自己实现双向链表" class="headerlink" title="自己实现双向链表"></a>自己实现双向链表</h3><p>自定义双向链表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleList</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Node head, tail;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> size;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DoubleList</span><span class="hljs-params">()</span></span>&#123;<br>        head = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        tail = <span class="hljs-keyword">new</span> Node(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        head.next = tail;<br>        tail.next = head;<br>        size = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addLast</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        x.prev = tail.prev;<br>        x.next = tail;<br>        tail.prev.next = x;<br>        tail.prev = x;<br>        size++;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Node x)</span></span>&#123;<br>        x.prev.next = x.next;<br>        x.next.prev = x.prev;<br>        size--;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">removeFirst</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(head.next == tail)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        Node first = head.next;<br>        remove(first);<br>        <span class="hljs-keyword">return</span> first;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> size; &#125;;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> key, value;<br>    <span class="hljs-keyword">public</span> Node next, prev;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, <span class="hljs-keyword">int</span> v)</span></span>&#123;<br>        key = k;<br>        value = v;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>自定义LRU缓存数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.HashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Integer, Node&gt; map;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DoubleList cache;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> cap;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.cap = capacity;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        cache = <span class="hljs-keyword">new</span> DoubleList();<br>    &#125;<br><br>    <span class="hljs-comment">//将某个Key设置为最近使用</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        Node node = map.get(key);<br><br>        cache.remove(node);<br>        cache.addLast(node);<br>    &#125;<br><br>    <span class="hljs-comment">//添加最近使用的元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> val)</span></span>&#123;<br>        Node node = <span class="hljs-keyword">new</span> Node(key, val);<br>        cache.addLast(node);<br>        map.put(key, node);<br>    &#125;<br><br>    <span class="hljs-comment">//删除一个Key</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteKey</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        Node node = map.get(key);<br>        cache.remove(node);<br>        map.remove(key);<br>    &#125;<br><br>    <span class="hljs-comment">//删除最久未使用的元素</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteLeastRecently</span><span class="hljs-params">()</span></span>&#123;<br>        Node deletedNode = cache.removeFirst();<br>        <span class="hljs-keyword">int</span> deletedKey = deletedNode.key;<br>        map.remove(deletedKey);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!map.containsKey(key))&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//将元素提升为最近使用的</span><br>        makeRecently(key);<br>        <span class="hljs-keyword">return</span> map.get(key).value;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(key))&#123;<br>            deleteKey(key);<br>            addRecently(key, value);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(cap == cache.size())&#123;<br>            deleteLeastRecently();<br>        &#125;<br>        addRecently(key, value);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="使用自带的哈希链表"><a href="#使用自带的哈希链表" class="headerlink" title="使用自带的哈希链表"></a>使用自带的哈希链表</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> cap;<br>    Map&lt;Integer, Integer&gt; cache = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span></span>&#123;<br>        cap = capacity;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(!cache.containsKey(key))&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment">//将key变为最近使用</span><br>        makeRecently(key);<br>        <span class="hljs-keyword">return</span> cache.get(key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(cache.containsKey(key))&#123;<br>            <span class="hljs-comment">//修改key的值</span><br>            cache.put(key, value);<br>            <span class="hljs-comment">//将key变为最近使用</span><br>            makeRecently(key);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(cache.size() &gt; cap)&#123;<br>            <span class="hljs-keyword">int</span> oldestKey = cache.keySet().iterator().next();<br>            cache.remove(oldestKey);<br>        &#125;<br>        cache.put(key, value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeRecently</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> val = cache.get(key);<br>        cache.remove(key);<br>        cache.put(key, val);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>LRU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最长递增子序列的二分搜索解法</title>
    <link href="/2021/04/28/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E8%A7%A3%E6%B3%95/"/>
    <url>/2021/04/28/%E6%9C%80%E9%95%BF%E9%80%92%E5%A2%9E%E5%AD%90%E5%BA%8F%E5%88%97%E7%9A%84%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E8%A7%A3%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="最长递增子序列的二分搜索解法"><a href="#最长递增子序列的二分搜索解法" class="headerlink" title="最长递增子序列的二分搜索解法"></a>最长递增子序列的二分搜索解法</h1><h2 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h2><p>给你一个整数数组 <code>nums</code> ，找到其中最长严格递增子序列的长度。</p><p>子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，<code>[3,6,2,7]</code> 是数组 <code>[0,3,1,6,2,2,7]</code> 的子序列。</p><span id="more"></span> <p><strong>示例 1：</strong></p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dns">输入：nums = [<span class="hljs-number">10,9,2,5</span>,<span class="hljs-number">3,7,101,18</span>]<br>输出：<span class="hljs-number">4</span><br>解释：最长递增子序列是 [<span class="hljs-number">2,3,7,101</span>]，因此长度为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[0,1,0,3,2,3]</span><br>输出：<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">输入：nums = <span class="hljs-string">[7,7,7,7,7,7,7]</span><br>输出：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h2 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h2><p>该解法与windows上蜘蛛纸牌的规则类似。</p><p>首先，给一排扑克牌，我们从左到右把扑克牌分成若干个分组。</p><p><strong>处理分组时的规则如下：</strong></p><ol><li>只能把点数小的牌放到点数大于等于的牌上；</li><li>如果当前牌的点数较大，没有合适的分组可以放入的话就单独划分一个新的分组；</li><li>如果有多个分组可以放入的话，则放入最左边的分组（为了使分组顶端的牌保持有序）。</li></ol><p>按照以上规则对数组进行分组的话，最后的分组数即为最长递增子序列的长度，数学证明我目前不会，等看懂了再进行补充。</p><p>我们只需要根据以上规则进行程序编写，通过二分查找来找到要放的分组位置，最后划分出的分组数即为最长递增子序列的长度。</p><p>样例代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLIS</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-comment">//创建N个分组,只需要保存分组最后放入的数的值</span><br>        <span class="hljs-keyword">int</span>[] group = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        <span class="hljs-comment">//初始化分组数</span><br>        <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>        <span class="hljs-comment">//处理每一个数字</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; ++i)&#123;<br>            <span class="hljs-comment">//当前数字的值</span><br>            <span class="hljs-keyword">int</span> cur = nums[i];<br>            <span class="hljs-comment">//搜索区间</span><br>            <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = count;<br>            <span class="hljs-keyword">while</span>(left &lt; right)&#123;<br>                <span class="hljs-keyword">int</span> mid = left + (right - left)/<span class="hljs-number">2</span>;<br>                <span class="hljs-keyword">if</span>(group[mid] &lt; cur)&#123;<br>                    left = mid + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    right = mid;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//若没有合适的分组则新建分组</span><br>            <span class="hljs-keyword">if</span>(left == count)&#123;<br>                count++;<br>            &#125;<br>            group[left] = cur;<br>        &#125;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>二分搜索</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>排序算法</title>
    <link href="/2021/04/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2021/04/24/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>每次找出数组中最小的元素，将它与数组的第一个元素交换。再次，在剩下的元素中找到最小的元素，将它与数组的第二个元素交换。如此往复，直至将整个数组排序。</p><span id="more"></span><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> n = nums.length;<br>        <span class="hljs-keyword">int</span> min;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)&#123;<br>            min = i;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>                <span class="hljs-keyword">if</span>(nums[min] &gt; nums[j])&#123;<br>                    min = j;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">int</span> tmp = nums[i];<br>            nums[i] = nums[min];<br>            nums[min] = tmp;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>为了给要插入的元素腾出空间，我们需要将其余所有元素在插入之前都向右移动一位。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> n = nums.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = i; j &gt; <span class="hljs-number">0</span> &amp;&amp; nums[j] &lt; nums[j - <span class="hljs-number">1</span>]; j--)&#123;<br>            <span class="hljs-keyword">int</span> tmp = nums[j];<br>            nums[j] = nums[j - <span class="hljs-number">1</span>];<br>            nums[j - <span class="hljs-number">1</span>] = tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>希尔排序是把记录按下标的一定增量分组，对每组使用直接插入排序算法排序；随着增量逐渐减少，每组包含的关键词越来越多，当增量减至 1 时，整个文件恰被分成一组，算法便终止。</p><p>示例代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shellSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> gap = nums.length;&#123;<br>        <span class="hljs-keyword">while</span>(gap != <span class="hljs-number">1</span>)&#123;<br>            gap /= <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; gap; i++)&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + gap; j &lt; nums.length; j += gap)&#123;<br>                    <span class="hljs-keyword">int</span> k = j - gap;<br>                    <span class="hljs-keyword">while</span>(k &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[k] &gt; nums[k + gap])&#123;<br>                        <span class="hljs-keyword">int</span> tmp = nums[k];<br>                        nums[k] = nums[k + gap];<br>                        nums[k + gap] = tmp;<br>                        k -= gap;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">mergeSort</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] aux;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> mid, <span class="hljs-keyword">int</span> hi)</span></span>&#123;<br>        <span class="hljs-keyword">int</span> i = lo, j = mid + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = lo; k &lt;= hi; ++k)&#123;<br>            aux[k] = a[k];<br>        &#125;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = lo; k &lt;= hi; ++k)&#123;<br>            <span class="hljs-keyword">if</span>(i &gt; mid) a[k] = aux[j++];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j &gt; hi) a[k] = aux[i++];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(aux[i] &gt; aux[j])&#123;<br>                a[k] = aux[j++];<br>            &#125;<span class="hljs-keyword">else</span> a[k] = aux[i++];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span></span>&#123;<br>        aux = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>        sort(nums, <span class="hljs-number">0</span>, nums.length - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(lo &gt;= hi) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> mid = lo + (hi - lo) / <span class="hljs-number">2</span>;<br>        sort(nums, lo, mid);<br>        sort(nums, mid + <span class="hljs-number">1</span>, hi);<br>        merge(nums, lo, mid, hi);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(low &gt;= high) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">int</span> i = low, j = high;<br>        <span class="hljs-keyword">while</span>(i &lt; j)&#123;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[j] &gt; nums[low]) j--;<br>            <span class="hljs-keyword">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[low]) i++;<br>            <span class="hljs-keyword">int</span> tmp = nums[i];<br>            nums[i] = nums[j];<br>            nums[j] = tmp;<br>        &#125;<br>        <span class="hljs-keyword">int</span> tmp = nums[i];<br>        nums[i] = nums[low];<br>        nums[low] = tmp;<br>        quickSort(nums, low, i - <span class="hljs-number">1</span>);<br>        quickSort(nums, i + <span class="hljs-number">1</span>, high);<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
      <tag>排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka相关知识</title>
    <link href="/2021/04/24/Kafka%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/04/24/Kafka%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><h3 id="消息队列Kafka"><a href="#消息队列Kafka" class="headerlink" title="消息队列Kafka"></a>消息队列Kafka</h3><p>Kafka是一个消息队列，可以实现发布订阅模式，在异步通信或者生产者和消费者需要解耦合的场景中经常使用，可以对数据流进行处理等。</p><span id="more"></span><p><strong>Kafka的特性如下所示：</strong></p><ul><li>Kafka支持消息的快速持久化</li><li>支持批量读写消息</li><li>支持消息分区，并且支持在线增加分区，提高了并发能力</li><li>支持为每个分区创建多个副本</li></ul><p><strong>Kafka</strong>可以<strong>实现消息的快速持久化</strong>的原因：</p><ul><li>Kafka将消息保存在磁盘中，并且读写磁盘的方式是顺序读写，避免了随机读写磁盘（寻道时间过长）导致的性能瓶颈。</li><li>磁盘的顺序读写速度超过内存随机读写。</li></ul><h4 id="Kafka使用磁盘存储，为什么具有高性能的特点"><a href="#Kafka使用磁盘存储，为什么具有高性能的特点" class="headerlink" title="Kafka使用磁盘存储，为什么具有高性能的特点"></a>Kafka使用磁盘存储，为什么具有高性能的特点</h4><ul><li><strong>顺序读写磁盘：</strong></li></ul><p>消息在磁盘中的方式是顺序读写的，磁盘的顺序读写速度超过内存随机读写。</p><ul><li><strong>页缓存：</strong></li></ul><p>页缓存是操作系统实现的一种主要的磁盘缓存，以此用来减少对磁盘I/O 的操作。具体就是把磁盘中的数据缓存到内存中，把对磁盘的访问变为对内存的访问。当然，也会存在磁盘脏页，以及在合适的时机会进行刷盘操作。</p><ul><li><strong>零拷贝：</strong></li></ul><p>使用零拷贝（ Zero-Copy ）技术来进一步提升Kafka性能。零拷贝是指将数据直接从磁盘文件复制到网卡设备中，而不需要经由应用程序之手。零拷贝大大提高了应用程序的性能，减少了内核和用户模式之间的上下文切换。</p><h3 id="Kafka中的核心概念"><a href="#Kafka中的核心概念" class="headerlink" title="Kafka中的核心概念"></a>Kafka中的核心概念</h3><p>核心概念如下所示：</p><ul><li><p><strong>生产者（Producer）：</strong><br>生产消息，并且按照一定的规则（分区分配规则）推送到Topic的分区中。</p></li><li><p><strong>消费者（Consumer）：</strong><br>从Topic中拉取消息并且进行消费，消费者自行维护消费消息的位置（offset）。</p></li><li><p><strong>主题（Topic）：</strong><br>存储消息的逻辑概念，是一个消息集合，Kafka根据topic对消息进行归类，发布到Kafka集群的每条消息都需要指定一个topic。</p></li><li><p><strong>分区（partition）：</strong><br>每个Topic可以划分为多个分区，每个消息在分区中都会有一个唯一编号offset，kafka通过offset保证消息在分区中的顺序，同一Topic的不同分区可以分配在不同的Broker上，partition以文件的形式存储在文件系统中。</p></li><li><p><strong>副本（replica）：</strong><br>KafKa对消息进行了冗余备份，每个分区有多个副本，每个副本中包含的消息是“一样”的。每个副本中都会选举出一个Leader副本，其余为Follower副本，Follower副本仅仅是将数据从Leader副本拉到本地，然后同步到自己的Log中。</p></li><li><p><strong>消费者组（Consumer Group）：</strong><br>每个consumer都属于一个consumer group，每条消息只能被consumer group中的一个Consumer消费，但可以被多个consumer group消费。</p></li><li><p><strong>Broker：</strong><br>一个单独的server就是一个Broker，主要用来接收生产者发过来的消息，分配offset，并且保存到磁盘中。</p></li><li><p><strong>Cluster &amp; Controller：</strong><br>多个Broker可以组成一个Cluster集群，每个集群选举一个Broker来作为Controller，充当指挥中心。Controller负责管理分区的状态，管理每个分区的副本状态，监听ZooKeeper中数据的变化等工作。</p></li><li><p><strong>日志压缩与保留策略：</strong><br>不管消费者是否已经消费了消息，Kafka都会保存这些消息（持久化到磁盘），通过配置相应的保留策略，定时删除陈旧的消息。所谓日志压缩，就是定时进行相同key值的合并，只保留最新的Key-Value值。</p></li></ul><h3 id="Kafka中的副本机制"><a href="#Kafka中的副本机制" class="headerlink" title="Kafka中的副本机制"></a>Kafka中的副本机制</h3><p>在分布式的存储中，进行冗余备份是一种常见的设计，主要的设计方案有同步复制和异步复制。</p><p><strong>同步复制：</strong></p><p>当所有的Follower副本都将消息复制完成，这条消息才会被认为是提交完成，一旦有一个Follower副本出现故障，就会导致消息无法提交，极大的影响到了系统的性能。</p><p><strong>异步复制：</strong></p><p>当Leader副本接收到生产者发送的消息后就认为当前消息提交成功。Follower副本异步的从Leader副本同步消息，但是不可以保证同步速度，当Leader副本突然宕机的时候，可能Follower副本中的消息落后太多，导致消息的丢失。</p><p><strong>考虑到同步复制和异步复制的优缺点，Kafka引入了ISR集合。</strong></p><h3 id="ISR（In-Sync-Replica）集合："><a href="#ISR（In-Sync-Replica）集合：" class="headerlink" title="ISR（In-Sync-Replica）集合："></a>ISR（In-Sync-Replica）集合：</h3><p>可用副本集合，ISR集合表示<strong>当前“可用”</strong>且消息量与Leader<strong>相差不多</strong>的副本集合，需要满足如下条件：</p><ul><li>副本所在节点必须维持着与ZooKeeper的连接。</li><li>副本最后一条信息的offset与Leader副本的最后一条消息的offset之间的差值不能超过指定的阈值。</li></ul><p><strong>HW和LEO标志：</strong></p><ul><li><strong>HW（HighWatermark）</strong>表示高水位，标记了一个特殊的offset，当消费者处理消息的时候，只能拉取到HW之前的消息。HW也是由Leader副本管理的。</li><li><strong>LEO（Log End Offset）</strong>是所有副本都会有的一个offset标记。</li></ul><p><strong>ISR、HW和LEO的工作配合机制：</strong></p><ul><li>producer向此分区中推送消息</li><li>Leader副本将消息追加到Log中，并且递增其LEO</li><li>Follower副本从Leader副本中拉取消息进行同步</li><li>Follower副本将消息更新到本地Log中，并且递增其LEO</li><li>当ISR集合中的所有副本都完成了对offset的消息同步，Leader副本会递增其HW</li></ul><p><strong>优势：</strong></p><ul><li>同步复制会导致高延迟，异步复制可能会造成消息的丢失。</li><li>KafKa引入的ISR集合解决了同步复制和异步复制的缺点。</li><li>当Follower副本延迟过高时，将会被踢出ISR集合，避免了高延迟的Follower副本影响整个KafKa集群性能。</li><li>当Leader副本所在的Broker宕机，会优先将ISR集合中的Follower副本选举为Leader。</li></ul><h3 id="Kafka的文件存储机制"><a href="#Kafka的文件存储机制" class="headerlink" title="Kafka的文件存储机制"></a>Kafka的文件存储机制</h3><p>Kafka中消息是以topic进行分类的，生产者通过topic向Kafka broker发送消息，消费者通过topic读取数据。</p><p>然而topic在物理层面又能以partition为分组，一个topic可以分成若干个partition，partition还可以细分为segment，一个partition物理上由多个segment组成。</p><p>在Kafka文件存储中，同一个topic下有多个不同的partition，每个partiton为一个目录，partition的名称规则为：topic名称+有序序号，第一个序号从0开始计，最大的序号为partition数量减1。</p><h3 id="Topic和Partition"><a href="#Topic和Partition" class="headerlink" title="Topic和Partition"></a>Topic和Partition</h3><p>Kafka中的一个topic可以认为是一类消息，每个topic将被分成多个partition，每个partition在存储层面是append log文件。发布到此partition的消息都会被追加到log文件的尾部，<strong>每条消息在文件中的位置称为offset(偏移量)<strong>，offset为一个long型的数字，它唯一标记一条消息。每条消息都被append到partition中，是一种顺序写磁盘的方式，</strong>顺序写磁盘</strong>效率比随机写内存还要高，这也是Kafka高吞吐率的一个很重要的保证。</p><p>每一条消息被发送到broker中，会根据partition规则选择被存储到哪一个partition。如果partition规则设置的合理，所有消息可以均匀分布到不同的partition里。</p><h4 id="为什么Kafka中的分区只支持增长，不支持减小分区个数的操作"><a href="#为什么Kafka中的分区只支持增长，不支持减小分区个数的操作" class="headerlink" title="为什么Kafka中的分区只支持增长，不支持减小分区个数的操作"></a>为什么Kafka中的分区只支持增长，不支持减小分区个数的操作</h4><ul><li>删除掉的分区的消息不好处理，若丢弃则可靠性得不到保证</li><li>如果插入现有分区的尾部，则一些带时间戳的消息会对消费者有影响</li><li>如果消息量大的话，复制到其它分区也会很耗费资源</li></ul><h3 id="Kafka消息传输的三大语义"><a href="#Kafka消息传输的三大语义" class="headerlink" title="Kafka消息传输的三大语义"></a>Kafka消息传输的三大语义</h3><p>Kafka有以下三种可能的传输保障（delivery guarantee）:</p><ul><li><strong>At most once: 最多一次</strong>，消息可能会丢，但绝不会重复传输</li><li><strong>At least once：最少一次</strong>，消息绝不会丢，但可能会重复传输</li><li><strong>Exactly once：恰好一次</strong>，每条消息肯定会被传输一次且仅传输一次</li></ul><p><strong>At most once：</strong>最多消费一次，绝对不会重复消费。<strong>那么Kafka如何保证At most once语义呢？</strong></p><ul><li>生产者Producer来生产消息的时候，当写数据失败的时候，broker直接跳过该消息，导致消息丢失，消费者无法消费该消息。</li><li>消费者在拉取消息之后，直接提交消息位移offset，但是没有完全消费完拉取消息即发生故障，下次会直接从刚刚offset的位置进行消费，刚刚故障时刻-offset之间的消息丢失。</li></ul><p><strong>At least once：最少一次</strong>，消息绝不会丢。那么Kafka如何保证最少消费一次呢？</p><p>生产者在生产数据的时候，以及写入了broker中，但是由于broker上的异常，导致生产者并没有成功的收到ACK，之后会进行重试操作，导致消息被写入了多次。</p><p><strong>Exactly once：恰好消费一次，那么Kafka如何保证恰好一次的语义呢？</strong></p><ul><li><strong>生产者生产消息的时候保证幂等性。</strong>对于同一个数据无论操作多少次都只写入一条数据，如果重复写入，则执行不成功。</li><li><strong>跨partition的原子性写操作。</strong>broker写入数据的时候，保证原子性操作，要么写入成功，要么写入失败。（不成功不断进行重试）</li></ul><h3 id="Kafka中可靠性的配置"><a href="#Kafka中可靠性的配置" class="headerlink" title="Kafka中可靠性的配置"></a>Kafka中可靠性的配置</h3><p><strong>request.required.acks：</strong></p><p>当producer向leader发送数据时，可以通过request.required.acks参数来设置数据可靠性的级别：</p><ul><li><strong>1（默认）</strong>：这意味着producer在ISR中的leader已成功收到数据并得到确认。如果leader宕机了，则会丢失数据。</li><li><strong>0：</strong>这意味着producer无需等待来自broker的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li><li><strong>-1：</strong>producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高。但是这样也不能保证数据不丢失，比如当ISR中只有leader时（ISR中的成员由于某些情况会增加也会减少，最少就只剩一个leader），这样就变成了acks=1的情况。</li></ul><p><strong>min.insync.replicas（ISR集合中的最小副本个数）：</strong></p><p>为了提高数据的可靠性，在设置request.required.acks=-1的同时，也要设置ISR中的最小副本个数min.insync.replicas这个参数。</p><ul><li>min.insync.replicas这个参数设定ISR中的最小副本数是多少，默认值为1，当且仅当request.required.acks参数设置为-1时，此参数才生效。</li><li>如果ISR中的副本数少于min.insync.replicas配置的数量时，客户端会返回异常：org.apache.kafka.common.errors.NotEnoughReplicasExceptoin: Messages are rejected since there are fewer in-sync replicas than required</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis相关知识</title>
    <link href="/2021/04/24/Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/04/24/Redis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><h3 id="Redis有了解么"><a href="#Redis有了解么" class="headerlink" title="Redis有了解么"></a>Redis有了解么</h3><p><strong>redis（Remote Dictionary Server远程字典服务）</strong>，是一款高性能的(key/value)分布式<strong>内存数据库</strong>，基于<strong>内存运行</strong>并支持<strong>持久化</strong>的NoSQL数据库。因为数据都在内存中，所以运行速度快。redis支持丰富的数据类型并且支持事务，事务中的所有命令会被序列化、按顺序执行，在执行的过程中不会被其他客户端发送来的命令打断。</p><span id="more"></span><h4 id="redis相比memcached有什么优势？"><a href="#redis相比memcached有什么优势？" class="headerlink" title="redis相比memcached有什么优势？"></a>redis相比memcached有什么优势？</h4><ul><li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型。</li><li>redis的速度比memcached快很多，并且redis支持数据的持久化。</li><li>redis支持数据的备份，即master-slave模式的数据备份。</li><li>使用底层模型不同，它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。redis自己构建了VM 管理机制。</li><li>value大小不同，redis最大可以达到512MB，而memcache只有1MB。</li></ul><h4 id="redis都支持哪些数据类型？应用场景有哪些？"><a href="#redis都支持哪些数据类型？应用场景有哪些？" class="headerlink" title="redis都支持哪些数据类型？应用场景有哪些？"></a>redis都支持哪些数据类型？应用场景有哪些？</h4><p>redis支持五种数据类型作为其Value，redis的Key都是字符串类型的。</p><ul><li><strong>string：</strong>redis 中字符串 value 最大可为512M。可以用来做一些计数功能的缓存（也是实际工作中最常见的）。</li><li><strong>list：</strong>简单的字符串列表，按照插入顺序排序，可以添加一个元素到列表的头部（左边）或者尾部（右边），其底层实现是一个链表。可以实现一个简单消息队列功能，做基于redis的分页功能等。</li><li><strong>set：</strong>是一个字符串类型的无序集合。可以用来进行全局去重等。</li><li><strong>sorted set：</strong>是一个字符串类型的有序集合，给每一个元素一个固定的<strong>分数score</strong>来保持顺序。可以用来做排行榜应用或者进行范围查找等。</li><li><strong>hash：</strong>键值对集合，是一个字符串类型的 Key和 Value 的映射表，也就是说其存储的Value是一个键值对（Key- Value）。可以用来存放一些具有特定结构的信息。</li></ul><h3 id="redis是单线程的么？为什么执行速度这么快？"><a href="#redis是单线程的么？为什么执行速度这么快？" class="headerlink" title="redis是单线程的么？为什么执行速度这么快？"></a>redis是单线程的么？为什么执行速度这么快？</h3><p> redis是单线程的，redis的单线程是指网络请求模块使用了一个线程，所以不需考虑并发安全性。但是对于需要依赖多个操作的复合操作来说，还是需要锁的，而且有可能是分布式锁。</p><p><strong>那么单线程的redis为什么执行速度如此之快？</strong></p><ul><li>基于内存实现，完全内存计算</li><li>单线程操作，避免了线程上下文切换操作</li><li><strong>多路I/O复用的线程模型</strong>，实现了一个线程监控多个IO流，及时响应请求</li><li>redis对外部的依赖比较少，属于轻量级内存数据库</li></ul><p>redis的线程模型<strong>多路I/O复用机制</strong>是一个比较重要并且常见的考察点。目前支持I/O多路复用的系统调用有<strong>select，pselect，poll，epoll</strong>等函数。I/O多路复用就是通过一种机制<strong>一个进程可以监视多个描述符</strong>，一旦某个描述符读就绪或者写就绪，其能够通知应用程序进行相应的读写操作。</p><p><strong>多路I/O复用机制</strong>与多进程和多线程技术相比系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</p><h3 id="使用Redis可能出现的问题"><a href="#使用Redis可能出现的问题" class="headerlink" title="使用Redis可能出现的问题"></a>使用Redis可能出现的问题</h3><h4 id="缓存雪崩："><a href="#缓存雪崩：" class="headerlink" title="缓存雪崩："></a>缓存雪崩：</h4><p><strong>举例：</strong>缓存同一时间大面积的失效，这个时候又来的一波请求都到数据库上，导致数据库连接异常。</p><p><strong>解决办法：</strong>可以给缓存设置不同的缓存时间，更新数据使用互斥锁或者通过双缓存在避免缓存雪崩。</p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p><strong>举例：</strong>redis中存储的是热点数据，当高并发请求访问redis中热点数据的时候，如果redis中的数据过期了，会造成缓存击穿的现象，请求都打到了数据库上。</p><p><strong>解决办法：</strong>使用互斥锁，只让一个请求去load DB，成功之后重新写缓存，其余请求没有获取到互斥锁，可以尝试重新获取缓存中的数据。</p><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p><strong>举例：</strong>故意的去请求缓存中不存在的数据，导致请求都打到了数据库上，导致数据库异常。</p><p><strong>解决办法：</strong>可以使用互斥锁或者无论是否取到结果都将结果存入缓存，还可以使用有效的机制（比如布隆过滤器）来拦截不合法的key值等。</p><h4 id="数据库和缓存的双写一致性问题："><a href="#数据库和缓存的双写一致性问题：" class="headerlink" title="数据库和缓存的双写一致性问题："></a>数据库和缓存的双写一致性问题：</h4><p>在高并发请求下很容易导致数据不一致的问题，如果你的业务需要保证数据的强一致性，那么建议不要使用缓存。在数据库中和缓存数据的删除或者写入过程中，如果有失败的情况，会导致数据的不一致。</p><p><strong>解决办法：</strong></p><ul><li><strong>双删延时的解决办法。</strong>可以先删除缓存数据，然后再更新数据库数据，最后再隔固定的时间再次删除缓存。</li><li><strong>更新数据库产生的binlog订阅（使用canal）</strong>。将有变化的key记录下来，并且尝试去不断的去删除缓存（如果上次删除缓存失败）</li></ul><h3 id="Redis的持久化方法"><a href="#Redis的持久化方法" class="headerlink" title="Redis的持久化方法"></a>Redis的持久化方法</h3><p><strong>redis的持久化方式有两种，即RDB和AOF的方式</strong></p><h4 id="RDB（快照方式-snapshotting）（全量持久化）"><a href="#RDB（快照方式-snapshotting）（全量持久化）" class="headerlink" title="RDB（快照方式 snapshotting）（全量持久化）"></a>RDB（快照方式 snapshotting）（全量持久化）</h4><p>将当前内存中的数据集快照写入磁盘，实现数据的持久化，恢复时可以将快照重新载入内存。</p><p><strong>触发方式：</strong></p><ul><li><strong>自动触发：</strong>在配置文件中，可以配置执行了多少次save就自动触发自动持久化。</li><li><strong>手动触发：</strong>通过bgsave命令，在后台异步进行生成快照的操作，同时还可以响应客户端的请求。通过redis进程fork操作创建子进程，生成的快照由子进程负责，客户端请求只会在fork阶段被阻塞。</li></ul><p><strong>快照恢复：</strong>将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务，redis会自动加载快照文件数据到内存。但是，redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。</p><p><strong>优缺点分析：</strong></p><ul><li>RDB持久化方式存在数据的丢失，因为其没有办法实现实时持久化。因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高，会影响系统性能。自动触发也存在丢失部分数据的情况。</li><li>在恢复大数据集时候，RDB方式相对于AOF要快。</li></ul><h4 id="AOF（append-only-file）（增量持久化）："><a href="#AOF（append-only-file）（增量持久化）：" class="headerlink" title="AOF（append-only-file）（增量持久化）："></a>AOF（append-only-file）（增量持久化）：</h4><p>在 redis配置文件的 APPEND ONLY MODE 中，可以设置AOF持久化。通过记录redis服务器所执行的写命令来记录数据库状态。恢复时可以将AOF文件载入内存，并且可以通过<strong>redis-check-aof –fix</strong> 进行修复AOF文件。</p><p><strong>AOF日志重写：</strong></p><ul><li>AOF文件会随着服务器运行的时间越来越大，可以通过AOF重写来控制AOF文件的大小。</li><li>AOF重写会首先读取数据库中现有的键值对状态，然后根据类型使用一条命令来替代前面对键值对操作的多条命令。</li><li>使用命令 bgrewriteaof 来实现AOF重写</li></ul><p><strong>AOF重写缓存区：</strong></p><p>redis 是单线程工作，当AOF文件较大时重写时间会比较长，在重写 AOF 期间，redis将长时间无法处理客户端请求。为了解决这个问题，可以将 AOF 重写程序放到子进程中执行，好处如下：</p><ul><li>子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理其它客户端请求。</li><li>子进程带有父进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。</li></ul><p><strong>子进程中AOF重写导致的问题：</strong></p><ul><li>子进程在进行 AOF 重写期间，服务器进程依然可以处理其它客户端请求，这就会导致数据库状态已经发生了改变，使得当前数据库数据状态和重写后的 AOF 文件中的数据不一致。</li><li>也就是出现了AOF文件和数据库中数据不一致的问题。</li></ul><p><strong>数据状态不一致解决办法：</strong></p><ul><li>redis 服务器设置了一个 AOF 重写缓冲区。这个缓冲区在创建子进程后开始使用，当redis服务器执行一个客户端的写请求命令，之后将这个写命令也发送到 AOF 重写缓冲区。</li><li>当子进程完成 AOF 日志重写之后，给父进程发送信号，父进程接收此信号后，将 AOF 重写缓冲区的内容写到新的 AOF 文件中，保持数据的一致性。</li></ul><p><strong>优缺点分析：</strong></p><ul><li>AOF文件可以做到秒级持久化，使用追加写的方式来写入，可读性强并且可以使用命令进行文件修复。</li><li>相比于RDB文件，同样数据下AOF文件体积要大。在redis负载较高时，秒级更新AOF文件会影响性能</li></ul><h4 id="持久化策略的选择"><a href="#持久化策略的选择" class="headerlink" title="持久化策略的选择"></a>持久化策略的选择</h4><ul><li>AOF更安全，可将数据及时同步到文件中，但需要较多的磁盘IO，AOF文件尺寸较大，文件内容恢复相对较慢也更加完整。</li><li>RDB持久化，安全性较差，它是正常时期数据备份及 master-slave数据同步的最佳手段，文件尺寸较小并且恢复速度较快。</li></ul><h3 id="redis数据的过期回收策略与内存淘汰机制"><a href="#redis数据的过期回收策略与内存淘汰机制" class="headerlink" title="redis数据的过期回收策略与内存淘汰机制"></a>redis数据的过期回收策略与内存淘汰机制</h3><p>redis中的数据过期回收策略使用了定期删除和惰性删除相结合的方式。</p><ul><li><strong>定期删除：</strong></li></ul><p>redis会每隔一定的时间去抽查一定量的数据判断其是否过期，过期则进行删除。</p><ul><li><strong>惰性删除：</strong></li></ul><p>在获取一个key的时候，redis会检查这个key是否已经过期，若过期，则会进行删除操作。</p><p><strong>内存淘汰机制：</strong></p><p>在配置文件中，我们可以对内存淘汰机制进行配置。当内存使用达到最大值时，redis可以使用的<strong>清除策略</strong>如下：</p><ul><li><strong>volatile-lru</strong>：利用LRU算法移除设置过过期时间的key (LRU:最近使用 Least Recently Used )</li><li><strong>allkeys-lru</strong>：利用LRU算法移除任何key</li><li><strong>volatile-random</strong>：移除设置过过期时间的随机key</li><li><strong>allkeys-random</strong>：移除随机key</li><li><strong>volatile-ttl</strong>：移除即将过期的key(minor TTL)</li><li><strong>noeviction</strong> ：不移除任何key，只是返回一个写错误 ，默认选项</li></ul><h3 id="redis的主从复制机制"><a href="#redis的主从复制机制" class="headerlink" title="redis的主从复制机制"></a>redis的主从复制机制</h3><p>当项目比较大的时候，我们可以使用<strong>主从架构Master/Slave机制</strong>，Master 以写为主，Slave 以读为主，Master 主节点更新后根据配置，自动同步到从机Slave 节点。</p><p>主从复制的原理包括<strong>旧版同步</strong>和<strong>命令传播</strong>，主从复制的代价就是系统复制较重的时候会导致主从延迟，并且根据CAP理论，无法同时保证服务可用性和数据一致性。</p><h4 id="什么是CAP理论"><a href="#什么是CAP理论" class="headerlink" title="什么是CAP理论"></a>什么是CAP理论</h4><p><strong>CAP理论是指</strong> 当网络分区发生时，一致性和可用性不可能同时保证。</p><ul><li><strong>C：Consistent 一致性</strong></li><li><strong>A：Availability 可用性</strong></li><li><strong>P：Partition tolerance 分区容忍度</strong></li><li><strong>网络分区</strong>：分布式系统的节点往往都是分布在不同的机器上进行网络隔离开的，这意味着必然会有网络断开的风险，网络断开也就意味着发生了网络分区。</li><li><strong>最终一致性</strong>：Redis可以保证最终一致性，从节点会努力追赶主节点，最终从节点的状态会和主节点的状态将保持一致。</li></ul><h3 id="redis对事务的支持"><a href="#redis对事务的支持" class="headerlink" title="redis对事务的支持"></a>redis对事务的支持</h3><p> redis对事务的支持主要可以概括如下：</p><ul><li><strong>隔离性：</strong>redis 是单进程的程序，保证在执行事务时，不会对事务进行中断，事务可以运行直到执行完所有事务队列中的命令为止。所以redis的事务支持隔离性。</li><li><strong>redis会将一个事务中的所有命令序列化</strong>，然后按顺序执行。<strong>redis不可能在一个事务的执行过程中插入执行另一个客户端发出的请求</strong>。可以保证Redis将这些命令作为一个单独的隔离操作执行。</li></ul><p>redis操作事务的相关命令如下所示：</p><ul><li><strong>MULTI：</strong>标记一个事务块的开始。</li><li><strong>EXEC：</strong>执行所有事务块内的命令。</li><li><strong>DISCARD：</strong>取消事务，放弃执行事务块内的所有命令。</li><li><strong>UNWATCH：</strong>取消 WATCH 命令对所有 key 的监视。</li><li><strong>WATCH key [key …]：</strong>监视一个(或多个) key ，如果在事务执行之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</li></ul><p>需要注意的是<strong>redis的事务不支持回滚操作</strong>，redis以 MULTI 开始一个事务，然后将多个命令入队到事务中，最后由 EXEC 命令触发事务， 一并执行事务中的所有命令。只有当被调用的redis命令有语法错误时，这条命令才会执行失败，或者对某个键执行不符合其数据类型的操作，但是应该在将命令入队列的时候就应该并且能够发现这些问题，所以redis的事务不支持进行回滚操作。</p><h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><p>关于分布式锁，为了使得加锁操作具有原子性，不可以使用多条命令来完成，我们可以使用带多个参数的set命令来完成，如下所示：jedis.set(String key, String value, String nxxx, String expx, int time)</p><p>第一个为key，我们使用key来当锁，因为key是唯一的。</p><p>第二个为value，我们传的是requestId，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。</p><p>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</p><p>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</p><p>第五个为time，与第四个参数相呼应，代表key的过期时间。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MyBatis相关知识</title>
    <link href="/2021/04/24/MyBatis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/04/24/MyBatis%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="MyBatis"><a href="#MyBatis" class="headerlink" title="MyBatis"></a>MyBatis</h1><h3 id="MyBatis是什么"><a href="#MyBatis是什么" class="headerlink" title="MyBatis是什么"></a>MyBatis是什么</h3><p>MyBatis是一个<strong>半ORM（对象关系映射）框架</strong>，内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。通过直接编写原生态SQL，可以严格控制SQL语句的执行性能，灵活度高(<strong>支持动态SQL语句</strong>)。</p><p>MyBatis <strong>使用XML或注解来配置和映射原生信息</strong>，将 POJO映射成数据库中的记录，避免了JDBC代码手动设置参数以及获取结果集的繁琐步骤。</p><p>MyBatis<strong>通过xml文件或注解的方式将要执行的各种 statement 配置起来</strong>，并通过Java对象和 statement中SQL的动态参数进行映射生成最终执行的SQL语句，最后由MyBatis框架执行SQL语句，并将结果映射为Java对象并返回。</p><span id="more"></span><h4 id="MyBatis和Hibernate的区别"><a href="#MyBatis和Hibernate的区别" class="headerlink" title="MyBatis和Hibernate的区别"></a>MyBatis和Hibernate的区别</h4><ul><li><strong>MyBatis</strong>的优点是代码开发量少、简单易上手、SQL语句和代码分离（便于修改）、数据库可移植；但是，其缺点是SQL语句需要自己写，并且参数只能有一个。</li><li><strong>Hibernate</strong>的优点是进行了对象关系数据库映射、完全面向对象、提供缓存机制和HQL编程；但是，其缺点是不能灵活使用原生SQL、无法对SQL优化、全表映射效率。</li></ul><h4 id="JDBC、MyBatis和Hibernate的主要区别"><a href="#JDBC、MyBatis和Hibernate的主要区别" class="headerlink" title="JDBC、MyBatis和Hibernate的主要区别"></a>JDBC、MyBatis和Hibernate的主要区别</h4><p>JDBC更为灵活，更加有效率，系统运行速度快。但是代码繁琐复杂，如果使用了存储过程就不方便数据库移植了。</p><p>Hibernate和MyBatis是关系数据库框架，开发速度快，更加面向对象，可以移植更换数据库，但影响系统性能。</p><h3 id="MyBatis的核心组件"><a href="#MyBatis的核心组件" class="headerlink" title="MyBatis的核心组件"></a>MyBatis的核心组件</h3><p>MyBatis的核心组件包括<strong>SqlSessionFactoryBuilder，SqlSessionFactory，SqlSession和Mapper</strong>。</p><p><strong>SqlSessionFactoryBuilder</strong>是一个构建器，通过XML配置文件或者Java编码获得资源来构建SqlSessionFactory，通过Builder可以构建多个SessionFactory。其生命周期一般只存在于方法的局部，用完即可回收。</p><p><strong>SqlSessionFactory</strong>的作用就是创建SqlSession，也就是创建一个会话。每次程序需要访问数据库，就需要使用到SqlSession。所以SqlSessionFactory应该在MyBatis应用的整个生命周期中。为了减少每次都创建一个会话带来的资源消耗，一般情况下都会使用单例模式来创建SqlSession。</p><p><strong>SqlSession</strong>就是一个会话，相当于JDBC中的Connection对象，既可以发送SQL去执行并返回结果，也可以获取Mapper接口。SqlSession是一个线程不安全的对象，其生命周期应该是请求数据库处理事务的过程中。每次创建的SqlSession对象必须及时关闭，否则会使得数据库连接池的活动资源减少，影响系统性能。</p><p><strong>Mapper</strong>也叫做映射器，由Java接口和XML文件（或者是注解）共同组成，给出了对应的SQL和映射规则，主要负责发送SQL去执行，并且返回结果。通过下边的语句来获取Mapper，接下来就可以调用Mapper中的各个方法去获取数据库结果了。</p><h3 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h3><p>MyBatis动态SQL可以在XML映射文件内，以标签的形式编写动态SQL。动态SQL的执行原理是，<strong>根据表达式的值完成逻辑判断并动态拼接SQL语句。</strong></p><p>对动态SQL的支持是MyBatis的一大优点。MyBatis提供了9种动态SQL标签：</p><ul><li><strong>if：</strong>单条件分支的判断语句</li><li><strong>choose, when, otherwise：</strong>多条件的分支判断语句</li><li><strong>foreach：</strong>列举条件，遍历集合，实现循环语句</li><li><strong>trim,where,set：</strong>是一些辅助元素，可以对拼接的SQL进行处理</li><li><strong>bind：</strong>进行模糊匹配查询的时候使用，提高数据库的可移植性</li></ul><h3 id="MyBatis的Mapper中常见标签"><a href="#MyBatis的Mapper中常见标签" class="headerlink" title="MyBatis的Mapper中常见标签"></a>MyBatis的Mapper中常见标签</h3><p>Mapper中常见的标签如下：</p><ul><li>select | insert | updae | delete</li><li>resultMap | parameterMap | sql | include | selectKey</li><li>trim | where | set | foreach | if | choose | when | otherwise | bind</li></ul><h3 id="DAO接口"><a href="#DAO接口" class="headerlink" title="DAO接口"></a>DAO接口</h3><p><strong>Dao接口即Mapper接口</strong>。接口的全限名，就是映射文件中的namespace的值。接口的方法名，就是映射文件中Mapper的Statement的id值。接口方法内的参数，就是传递给SQL的参数。</p><p>Mapper接口是没有实现类的，当调用接口方法时，接口<strong>全限名+方法名</strong>拼接字符串作为key值，可唯一定位一个<strong>MapperStatement</strong>。在MyBatis中，每一个<code>&lt;select&gt;</code>、<code>&lt;insert&gt;</code>、<code>&lt;update&gt;</code>、<code>&lt;delete&gt;</code>标签，都会被解析为一个<strong>MapperStatement对象</strong>。</p><p>Mapper接口的工作原理<strong>是JDK动态代（dai）理</strong>，MyBatis运行时会使用JDK动态代（dai）理为Mapper接口生成代（dai）理对象proxy，代（dai）理对象会拦截接口方法，转而执行MapperStatement所代表的SQL，然后将SQL执行结果返回。</p><h4 id="Dao接口中的方法可以重载么？"><a href="#Dao接口中的方法可以重载么？" class="headerlink" title="Dao接口中的方法可以重载么？"></a>Dao接口中的方法可以重载么？</h4><p><strong>Mapper接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。</strong></p><h4 id="不同映射文件xml中的id值可以重复么"><a href="#不同映射文件xml中的id值可以重复么" class="headerlink" title="不同映射文件xml中的id值可以重复么"></a>不同映射文件xml中的id值可以重复么</h4><ul><li>不同的xml映射文件，如果配置了namespace，那么id可以重复</li><li>如果没有配置namespace，那么id不能重复</li></ul><h3 id="和-有什么区别"><a href="#和-有什么区别" class="headerlink" title="#和$有什么区别"></a><code>#</code>和<code>$</code>有什么区别</h3><p>myBatis中我们<strong>能用<code>#</code>号就尽量不要使用<code>$</code>符号</strong>，它们的区别主要体现在下边几点：</p><ul><li><code>#</code>符号将传入的数据都当做一个字符串，会对自动传入的数据加一个双引号</li><li><code>$</code>符号将传入的数据<strong>直接显示</strong>在生成的SQL语句中。</li><li><code>#</code>符号<strong>存在预编译的过程</strong>，对问号赋值，防止<strong>SQL注入</strong>。</li><li><code>$</code>符号是<strong>直译</strong>的方式，一般用在**order by ${列名}**语句中。</li></ul><h3 id="MyBatis的缓存机制"><a href="#MyBatis的缓存机制" class="headerlink" title="MyBatis的缓存机制"></a>MyBatis的缓存机制</h3><p>MyBatis的缓存机制分为一级和二级缓存，分别介绍如下：</p><ul><li><strong>一级缓存（同一个SqlSession）:</strong></li></ul><p>基于HashMap的本地缓存，其存储作用域为Session，当 Session flush 或 close 之后，该 Session 中的所有缓存就将清空，默认打开一级缓存。</p><ul><li><strong>二级缓存（同一个SqlSessionFactory）：</strong></li></ul><p>二级缓存与一级缓存其机制相同，默认也是采用HashMap的本地存储，不同在于其存储作用域为 Mapper(Namespace)，并且可自定义存储源。</p><h3 id="MyBatis的接口绑定"><a href="#MyBatis的接口绑定" class="headerlink" title="MyBatis的接口绑定"></a>MyBatis的接口绑定</h3><p>接口绑定就是在MyBatis中任意定义接口,然后把接口里面的方法和SQL语句绑定, 我们直接调用接口方法就可以。</p><p><strong>接口绑定有两种实现方式：</strong></p><ul><li>通过注解绑定，就是在接口的方法上面加上 @Select、@Update等注解，里面包含SQL语句来绑定</li><li>通过xml里面写SQL来绑定, 在这种情况下,要指定xml映射文件里面的namespace必须为接口的全路径名。</li></ul><p><strong>接口绑定方式的选择：</strong></p><p>当SQL语句比较简单时候，用注解绑定；当SQL语句比较复杂时候，用xml绑定；实际的开发中，我们一般都使用xml绑定方式。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>MyBatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring相关知识</title>
    <link href="/2021/04/23/Spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/04/23/Spring%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h3 id="Spring-的控制反转（IOC）"><a href="#Spring-的控制反转（IOC）" class="headerlink" title="Spring 的控制反转（IOC）"></a>Spring 的控制反转（IOC）</h3><p>IOC也叫<strong>控制反转，将对象间的依赖关系交给Spring容器</strong>，使用配置文件来创建所依赖的对象，由<strong>主动</strong>创建对象改为了<strong>被动</strong>方式，实现解耦合。</p><p>可以通过注解**@Autowired和@Resource**来注入对象，被注入的对象必须被下边的四个注解之一标注：</p><ul><li><strong>@Controller</strong></li><li><strong>@Service</strong></li><li><strong>@Repository</strong></li><li><strong>@Component</strong></li></ul><span id="more"></span><p>在Spring配置文件中配置 <code>&lt;context:annotation-config/&gt;</code>元素开启注解。还有一个概念是<strong>DI（依赖注入）</strong>，和控制反转是同一个概念的不同角度的描述，即应用程序在运行时依赖IOC容器来动态注入对象需要的外部资源（对象等）。</p><p>Spring是一个<strong>轻量级的IOC和AOP容器</strong>框架。是为Java应用程序提供基础服务的一套框架，目的是用于简化企业应用程序的开发，它使得开发者只需要关心业务需求。</p><p>Spring的<strong>核心模块</strong>如下所示：</p><ul><li><strong>Spring Core：</strong>是核心类库，提供IOC服务；</li><li><strong>Spring Context：</strong>提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）；</li><li><strong>Spring AOP：</strong>提供AOP服务；</li><li><strong>Spring DAO：</strong>对JDBC进行了抽象，简化了数据访问异常等处理；</li><li><strong>Spring ORM：</strong>对现有的ORM持久层框架进行了支持；</li><li><strong>Spring Web：</strong>提供了基本的面向Web的综合特性；</li><li><strong>Spring MVC：</strong>提供面向Web应用的Model-View-Controller实现。</li></ul><h3 id="Spring的优点有哪些呢？"><a href="#Spring的优点有哪些呢？" class="headerlink" title="Spring的优点有哪些呢？"></a>Spring的优点有哪些呢？</h3><ul><li>Spring的<strong>依赖注入</strong>将对象之间的依赖关系交给了框架来处理，减小了各个组件之间的耦合性；</li><li><strong>AOP面向切面编程</strong>，可以将通用的任务抽取出来，复用性更高；</li><li>Spring对于其余<strong>主流框架都提供了很好的支持</strong>，代码的侵入性很低。</li></ul><h3 id="Spring中的AOP面向切面编程"><a href="#Spring中的AOP面向切面编程" class="headerlink" title="Spring中的AOP面向切面编程"></a>Spring中的AOP面向切面编程</h3><p><strong>AOP，</strong>面向切面编程是指当需要在某一个方法之前或者之后做一些额外的操作，比如说日志记录，权限判断，异常统计等，可以利用AOP<strong>将功能代码从业务逻辑代码中分离出来。</strong></p><p><strong>AOP中有如下的操作术语：</strong></p><ul><li><strong>Joinpoint(连接点)：</strong> 类里面可以被增强的方法，这些方法称为连接点</li><li><strong>Pointcut(切入点)：</strong>所谓切入点是指我们要对哪些Joinpoint进行拦截的定义</li><li><strong>Advice(通知/增强)：</strong>所谓通知是指拦截到Joinpoint之后所要做的事情就是通知。</li><li><strong>Aspect(切面)：</strong>是切入点和通知（引介）的结合</li><li><strong>Introduction(引介)：</strong>引介是一种特殊的通知在不修改类代码的前提下，Introduction可以在运行期为类动态地添加一些方法或属性</li><li><strong>Target(目标对象)：</strong>代（dai）理的目标对象(要增强的类)</li><li><strong>Weaving(织入)：</strong>是把增强应用到目标的过程，把advice 应用到 target的过程</li><li><strong>Proxy（代(dai)理）：</strong>一个类被AOP织入增强后，就产生一个结果代（dai）理类</li></ul><p><strong>切入点就是在类里边可以有很多方法被增强</strong>，比如实际操作中，只是增强了个别方法，则定义实际被增强的某个方法为切入点；<strong>通知/增强 就是指增强的逻辑</strong>，比如扩展日志功能，这个日志功能称为增强；<strong>切面</strong>就是把增强应用到具体方法上面的过程称为切面。</p><h3 id="Spring中AOP主要有两种实现方式："><a href="#Spring中AOP主要有两种实现方式：" class="headerlink" title="Spring中AOP主要有两种实现方式："></a>Spring中AOP主要有两种实现方式：</h3><ul><li><strong>使用JDK动态代（dai）理实现</strong>，使用java.lang.reflection.Proxy类来处理</li><li><strong>使用cglib来实现</strong></li></ul><h4 id="两种实现方式的不同之处："><a href="#两种实现方式的不同之处：" class="headerlink" title="两种实现方式的不同之处："></a>两种实现方式的不同之处：</h4><p><strong>JDK动态代理</strong>，只能对实现了接口的类生成代理，而不是针对类，该目标类型实现的接口都将被代理。原理是通过在运行期间创建一个接口的实现类来完成对目标对象的代理。<strong>实现步骤大概如下：</strong></p><ul><li>定义一个实现接口InvocationHandler的类</li><li>通过构造函数，注入被代理类</li><li>实现invoke（ Object proxy, Method method, Object[ ] args）方法</li><li>在主函数中获得被代理类的类加载器</li><li>使用Proxy.newProxyInstance( )产生一个代理对象</li><li>通过代理对象调用各种方法</li></ul><p>JDK动态代理的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 秦海祺 &#123;2021/4/21&#125;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-comment">//定义一个People作为被代理的类</span><br>        IPeople ple = <span class="hljs-keyword">new</span> People();<br>        <span class="hljs-comment">//定义一个Handler</span><br>        InvocationHandler handler = <span class="hljs-keyword">new</span> MyHandle(ple);<br><br>        <span class="hljs-comment">//获得类加载器</span><br>        ClassLoader cl = ple.getClass().getClassLoader();<br><br>        <span class="hljs-comment">//动态产生一个代理，以下两种方法都可以</span><br>        IPeople p = (IPeople) Proxy.newProxyInstance(cl, ple.getClass().getInterfaces(), handler);<br>        <span class="hljs-comment">//或者 IPeople p = (IPeople) Proxy.newProxyInstance(cl, new Class[]&#123;IPeople.class&#125;, handler);</span><br><br>        <span class="hljs-comment">//执行被代理的方法</span><br>        p.func();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span></span>&#123;<br><br>    <span class="hljs-comment">//被代理的实例</span><br>    Object obj = <span class="hljs-keyword">null</span>;<br><br>    <span class="hljs-comment">//我要代理谁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyHandle</span><span class="hljs-params">(Object obj)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.obj = obj;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Object result = method.invoke(<span class="hljs-keyword">this</span>.obj, args);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IPeople</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">//实际被代理类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">People</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IPeople</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fun</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;这是fun方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;这是func方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>cglib主要针对类实现代理</strong>，<strong>对是否实现接口无要求</strong>。原理是对指定的类生成一个子类，覆盖其中的方法，因为是继承，所以被代理的类或方法不可以声明为final类型。<strong>实现步骤大概如下：</strong></p><ul><li>定义一个实现了MethodInterceptor接口的类</li><li>实现其 intercept()方法，在其中调用proxy.invokeSuper()</li></ul><h4 id="Spring-AOP对这两种代（dai）理方式的选择："><a href="#Spring-AOP对这两种代（dai）理方式的选择：" class="headerlink" title="Spring AOP对这两种代（dai）理方式的选择："></a>Spring AOP对这两种代（dai）理方式的选择：</h4><ul><li>如果目标对象实现了接口，默认情况下会采用JDK的动态代（dai）理实现AOP，也可以强制使用cglib实现AOP；</li><li>如果目标对象没有实现接口，必须采用cglib库，Spring会自动在JDK动态代（dai）理和cglib之间转换。</li></ul><h3 id="IOC容器的初始化过程"><a href="#IOC容器的初始化过程" class="headerlink" title="IOC容器的初始化过程"></a>IOC容器的初始化过程</h3><p>IOC容器的初始化主要包括<strong>Resource定位，载入和注册</strong>三个步骤，接下来我们依次介绍。</p><ul><li><strong>Resource资源定位：</strong><br>Resouce定位是指BeanDefinition的资源定位，也就是IOC容器找数据的过程。Spring中使用外部资源来描述一个Bean对象，IOC容器第一步就是需要定位Resource外部资源。由ResourceLoader通过统一的Resource接口来完成定位。</li><li><strong>BeanDefinition的载入：</strong><br>载入过程就是把定义好的Bean表示成IOC容器内部的数据结构，即BeanDefinition。在配置文件中每一个Bean都对应着一个BeanDefinition对象。<br>通过BeanDefinitionReader读取，解析Resource定位的资源，将用户定义好的Bean表示成IOC容器的内部数据结构BeanDefinition。<br>在IOC容器内部维护着一个BeanDefinitionMap的数据结构，通过BeanDefinitionMap，IOC容器可以对Bean进行更好的管理。</li><li><strong>BeanDefinition的注册：</strong><br>注册就是将前面的BeanDefition保存到Map中的过程，通过BeanDefinitionRegistry接口来实现注册。</li></ul><h4 id="依赖注入的发生时刻"><a href="#依赖注入的发生时刻" class="headerlink" title="依赖注入的发生时刻"></a>依赖注入的发生时刻</h4><p><strong>IOC容器的初始化过程就是对Bean定义资源的定位、载入和注册</strong>，此时容器对Bean的依赖注入并没有发生。接下来，我们看下<strong>依赖注入的发生时刻吧。</strong></p><p>ApplicationContext默认会在容器启动的时候创建我们配置好的各个Bean，我们的Bean配置如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;oneBean&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.nowcoder.oneBean&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p>这里边的隐藏属性是lazy-init，即上边的配置和下边的是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;oneBean&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.nowcoder.oneBean&quot;</span> lazy-init=<span class="hljs-string">&quot;false&quot;</span>&gt;<br></code></pre></td></tr></table></figure><p><strong>lazy-init=false</strong>表示不开启延迟加载，在容器启动的时候即创建该Bean。对应的，我们还可以配置lazy-init=true表示开启延迟加载，那么该Bean的创建发生在应用程序<strong>第一次向容器索取Bean</strong>时，通过getBean()方法的调用完成。</p><h4 id="BeanFactory和FactoryBean的区别"><a href="#BeanFactory和FactoryBean的区别" class="headerlink" title="BeanFactory和FactoryBean的区别"></a>BeanFactory和FactoryBean的区别</h4><ul><li><strong>BeanFactory</strong>：Bean工厂，是一个工厂(Factory)， 是Spring IOC容器的最顶层接口，它的作用是<strong>管理Bean，即实例化、定位、配置</strong>应用程序中的对象及建立这些对象间的依赖。</li><li><strong>FactoryBean</strong>：工厂Bean，<strong>是一个Bean，作用是产生其他Bean实例</strong>，需要提供一个工厂方法，该方法用来返回其他Bean实例。</li></ul><h4 id="BeanFactory和ApplicationContext有什么区别？"><a href="#BeanFactory和ApplicationContext有什么区别？" class="headerlink" title="BeanFactory和ApplicationContext有什么区别？"></a>BeanFactory和ApplicationContext有什么区别？</h4><p>BeanFactory是Spring里面最顶层的接口，包含了各种Bean的定义，读取Bean配置文档，管理Bean的加载、实例化，控制Bean的生命周期，维护Bean之间的依赖关系。</p><p><strong>ApplicationContext</strong>接口是BeanFactory的派生，除了提供BeanFactory所具有的功能外，还提供了更完整的框架功能：</p><ul><li>继承了MessageSource，支持国际化。</li><li>提供了统一的资源文件访问方式。</li><li>提供在Listener中注册Bean的事件。</li><li>提供同时加载多个配置文件的功能。</li><li>载入多个（有继承关系）上下文 ，使得每一个上下文都专注于一个特定的层次，比如应用的web层。</li></ul><p><strong>ApplicationContext 三种常见的实现方式:</strong></p><ul><li><strong>FileSystemXmlApplicationContext</strong>：此容器从一个XML文件中加载Bean的定义，XML Bean 配置文件的全路径名必须提供给它的构造函数。</li><li><strong>ClassPathXmlApplicationContext</strong>：此容器也从一个XML文件中加载Bean的定义，需要正确设置classpath因为这个容器将在classpath里找Bean配置。</li><li><strong>WebXmlApplicationContext</strong>：此容器加载一个XML文件，定义了一个WEB应用的所有Bean。</li></ul><p><strong>在创建Bean和内存占用方面的区别：</strong></p><ul><li><strong>BeanFactory采用的是延迟加载形式来注入Bean的</strong>，即只有在使用到某个Bean时(调用getBean())，才对该Bean进行加载实例化。这样，就不能发现一些存在于<strong>Spring配置</strong>中的问题。如果Bean的某一个属性没有注入，BeanFactory加载后，直至第一次使用调用getBean方法才会抛出异常。</li><li><strong>ApplicationContext，它是在容器启动时，一次性创建了所有的Bean</strong>。这样，在容器启动时，我们就可以发现Spring中存在的配置错误，这样有利于检查所依赖属性是否注入。 ApplicationContext启动后预载入所有的单实例Bean，通过预载入单实例Bean ,确保当需要的时候，可以直接获取。</li><li>相对于基本的BeanFactory，ApplicationContext不足之处是占用内存空间。当应用程序配置Bean较多时，程序启动较慢，因为其一次性创建了所有的Bean。</li></ul><h4 id="BeanFactory和ApplicationContext的优缺点："><a href="#BeanFactory和ApplicationContext的优缺点：" class="headerlink" title="BeanFactory和ApplicationContext的优缺点："></a>BeanFactory和ApplicationContext的优缺点：</h4><p><strong>BeanFactory的优缺点：</strong></p><p><strong>优点</strong>：应用启动的时候占用资源很少，对资源要求较高的应用，比较有优势；</p><p><strong>缺点</strong>：运行速度会相对来说慢一些。而且有可能会出现空指针异常的错误，而且通过Bean工厂创建的Bean生命周期会简单一些。</p><p><strong>ApplicationContext的优缺点：</strong></p><p><strong>优点</strong>：所有的Bean在启动的时候都进行了加载，系统运行的速度快；在系统启动的时候，可以发现系统中的配置问题。</p><p><strong>缺点</strong>：把费时的操作放到系统启动中完成，所有的对象都可以预加载，缺点就是内存占用较大。</p><h3 id="Spring中Bean的作用域"><a href="#Spring中Bean的作用域" class="headerlink" title="Spring中Bean的作用域"></a>Spring中Bean的作用域</h3><p>Spring框架支持以下五种Bean的作用域：</p><ul><li><strong>singleton</strong> : Bean在每个Spring IOC 容器中只有一个实例，默认作用域。</li><li><strong>prototype</strong>：一个Bean的定义可以有多个实例。</li><li><strong>request</strong>：每次http请求都会创建一个Bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li><strong>session</strong>：在一个HTTP Session中，一个Bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li><li><strong>global-session</strong>：在一个全局的HTTP Session中，一个Bean对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。</li></ul><h4 id="Spring中Bean的作用域常使用的是singleton，也就是单例作用域。那么单例Bean是线程安全的吗？"><a href="#Spring中Bean的作用域常使用的是singleton，也就是单例作用域。那么单例Bean是线程安全的吗？" class="headerlink" title="Spring中Bean的作用域常使用的是singleton，也就是单例作用域。那么单例Bean是线程安全的吗？"></a>Spring中Bean的作用域常使用的是singleton，也就是单例作用域。那么单例Bean是线程安全的吗？</h4><p><strong>单例Bean和线程安全与否没有必然的关系</strong>。多个线程在多个<strong>工作内存和主内存交互</strong>的时候会出现不一致的地方，那么就不是线程安全的。大部分的Spring Bean并<strong>没有可变的状态</strong>(比如Service类和DAO类)，所以一定程度上可以说Spring的单例Bean是线程安全的。如果你的Bean有多种状态的话（比如 View Model 对象），就需要自行保证线程安全。在一般情况下，<strong>只有无状态的Bean才可以在多线程环境下共享。</strong></p><h4 id="循环依赖："><a href="#循环依赖：" class="headerlink" title="循环依赖："></a>循环依赖：</h4><p>“<strong>如果A对象创建的过程需要使用到B对象，但是B对象创建的时候也需要A对象，也就是构成了循环依赖的现象，那么Spring会如何解决？</strong>”</p><p>这是一种<strong>构造器循环依赖，通过构造器注入构成的循环依赖，此依赖是无法解决的，只能抛出BeanCurrentlyInCreationException异常表示循环依赖。</strong></p><h4 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h4><p>Spring支持编程式事务管理和声明式事务管理两种方式：</p><ul><li><strong>编程式事务管理</strong>：使用TransactionTemplate实现。</li><li><strong>声明式事务管理</strong>：建立在AOP之上的。其本质是通过AOP功能，对方法前后进行拦截，将事务处理的功能编织到拦截的方法中，也就是在目标方法开始之前加入一个事务，在执行完目标方法之后根据执行情况提交或者回滚事务</li></ul><p><strong>声明式事务的优点：</strong></p><p>就是不需要在业务逻辑代码中掺杂事务管理的代码，只需在配置文件中做相关的事务规则声明或通过@Transactional注解的方式，便可以将事务规则应用到业务逻辑中。</p><p><strong>事务选择：</strong></p><p>声明式事务管理要优于编程式事务管理，这正是Spring倡导的<strong>非侵入式的开发</strong>方式，使业务代码不受污染，只要<strong>加上注解</strong>就可以获得完全的事务支持。唯一不足之处是声明式事务的最细粒度只能作用到方法级别，无法做到像编程式事务那样可以作用到代码块级别。</p><h4 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h4><ul><li><strong>PROPAGATION_REQUIRED</strong>：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，<strong>该设置是最常用的设置。</strong></li><li>PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</li><li>PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</li><li>PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。</li><li>PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</li><li>PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。</li><li>PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则按REQUIRED属性执行。</li></ul><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>串行（序列化）</li></ul><h3 id="SpringMVC的消息处理机制"><a href="#SpringMVC的消息处理机制" class="headerlink" title="SpringMVC的消息处理机制"></a>SpringMVC的消息处理机制</h3><p> SpringMVC是一种轻量级的Web层框架，是一个基于请求驱动的Web框架，使用了<strong>“前端控制器（DispatcherServlet）”模型</strong>来进行设计，再根据请求映射规则分发给相应的页面控制器进行处理。消息处理依次经过的组件如下：</p><p><strong>DispatcherServlet、HandlerMapping、HandlerAdapter，返回一个ModelAndView逻辑视图名、ViewResolver、View</strong></p><p><strong>具体流程可以概括为</strong>：通过前端控制器DispatcherServlet来接收并且分发请求，然后通过HandlerMapping和HandlerAdapter找到具体可以处理该请求的Handler，经过逻辑处理，返回一个ModelAndView，经过ViewResolver处理，最后生成了一个View视图返回给了客户端。可以参考如下的示意图：</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210424084138.png" alt="图片说明"></p><h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><p>Spring Boot 是 Spring 开源组织下的子项目，是 Spring 组件<strong>一站式解决方案</strong>，主要是简化了使用 Spring 的难度，简省了繁重的配置，提供了<strong>各种启动器starter</strong>，开发者能快速上手。</p><p>SpringBoot的优点包括可以独立运行，简化了配置，可以实现<strong>自动配置</strong>，无代码生成以及XML配置，并且可以进行应用监控。</p><p><strong>注解 @EnableAutoConfiguration, @Configuration, @ConditionalOnClass 就是自动配置</strong>的核心，实现了SpringBoot项目的自动配置。</p><h4 id="SpringBoot的核心注解"><a href="#SpringBoot的核心注解" class="headerlink" title="SpringBoot的核心注解"></a>SpringBoot的核心注解</h4><p>启动类上面的注解是@SpringBootApplication，它也是 Spring Boot 的核心注解，主要组合包含了以下 3 个注解：</p><ul><li>@<strong>SpringBootConfiguration</strong>：组合了 @Configuration 注解，实现配置文件的功能。</li><li>@<strong>EnableAutoConfiguration</strong>：打开自动配置的功能，也可以关闭某个自动配置的选项。如关闭数据源自动配置功能： @SpringBootApplication(exclude = { DataSourceAutoConfiguration.class })。</li><li>@<strong>ComponentScan</strong>：Spring组件扫描。</li></ul><h4 id="SpringBoot项目启动分析"><a href="#SpringBoot项目启动分析" class="headerlink" title="SpringBoot项目启动分析"></a>SpringBoot项目启动分析</h4><p>Application类是通过<strong>SpringApplication</strong>类的静态run方法来启动应用的。打开这个静态方法，该静态方法真正执行的是两部分：<strong>new SpringApplication( )并且执行对象run()方法。</strong></p><h4 id="轻量级和重量级的划分"><a href="#轻量级和重量级的划分" class="headerlink" title="轻量级和重量级的划分"></a>轻量级和重量级的划分</h4><ol><li>   主要看它使用了多少服务，使用的服务越多，容器为普通的java对象做的工作就越多，必然会影响到应用的发布时间，或者运行性能。</li><li>   对于spring容器，他提供了很多服务，但默认是关闭的，应用需要某种服务，需要指明使用服务，如果服务很少，如只使用了spring核心服务，就认为此时应用属于轻量级的，如果使用了大部分的服务，这时就属于重量级的。</li><li>   目前EJB容器就重量级。因为他默认为应用提供了Ejb规范中的所有功能，所以属于重量级。</li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式相关知识</title>
    <link href="/2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/04/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h3 id="设计模式的六大原则："><a href="#设计模式的六大原则：" class="headerlink" title="设计模式的六大原则："></a>设计模式的六大原则：</h3><span id="more"></span><h4 id="单一职责原则（Single-responsibility，-SRP）："><a href="#单一职责原则（Single-responsibility，-SRP）：" class="headerlink" title="单一职责原则（Single responsibility， SRP）："></a>单一职责原则（Single responsibility， SRP）：</h4><p>单一职责规定了一个类应该只有一个发生变化的原因。如果一个类承担了多个职责，则会导致多个职责耦合在一起。但部分职责发生变化的时候，可能会导致其余职责跟着受到影响，也就是说我们的程序耦合性太强，不利于变化。</p><p><strong>那么，单一职责有哪些优点呢？</strong></p><ul><li>降低了类的复杂度，每一个类都有清晰明确的职责。</li><li>程序的可读性和可维护性都得到了提高。</li><li>降低业务逻辑变化导致的风险，一个接口的修改只对相应的实现类有影响，对其他接口无影响。</li></ul><h4 id="里氏替换原则（Liskov-Substitution-Principle，LSP）："><a href="#里氏替换原则（Liskov-Substitution-Principle，LSP）：" class="headerlink" title="里氏替换原则（Liskov Substitution Principle，LSP）："></a>里氏替换原则（Liskov Substitution Principle，LSP）：</h4><p>里氏替换是指所有父类可以出现的地方，子类就都可以出现，使用子类来替换父类，调用方不需要关心目前传递的父类还是子类。</p><p>通过里氏替换原则，我们可以将子类对象做为父类对象来使用，屏蔽了不同子类对象之间的差异，写出通用的代码，做出通用的编程，以适应需求的不断变化。里氏替换之后，父类的对象就可以根据当前赋值给它的子类对象的特性以不同的方式运作。</p><p><strong>那么，里氏替换原则有哪些优点呢？</strong></p><p>里氏替换原则可以增强程序的健壮性，子类可以任意增加和缩减，我们都不需要修改接口参数。在实际开发中，实现了传递不同的子类来完成不同的业务逻辑。</p><h4 id="依赖倒置原则（Dependence-Inversion-Principle，DIP）"><a href="#依赖倒置原则（Dependence-Inversion-Principle，DIP）" class="headerlink" title="依赖倒置原则（Dependence Inversion Principle，DIP）"></a>依赖倒置原则（Dependence Inversion Principle，DIP）</h4><p>依赖倒置原则是指高层模块不应该依赖于底层模块，抽象不应该依赖细节，细节应该依赖抽象。在Java中，接口和抽象类都是抽象，而其实现类就是细节。也就是说，我们应该做到面向接口编程，而非面向实现编程。</p><p><strong>那么，依赖导致原则的好处有哪些呢？</strong></p><ul><li>依赖倒置通过抽象(接口或抽象类)使各个类或模块的独立，实现模块间的松耦合。</li><li>面向接口编程可以使得当需求变化的时候，程序改动的工作量不至于太大。</li></ul><h4 id="接口隔离原则-Interface-Segregation-Principle-ISP-："><a href="#接口隔离原则-Interface-Segregation-Principle-ISP-：" class="headerlink" title="接口隔离原则(Interface Segregation Principle, ISP)："></a>接口隔离原则(Interface Segregation Principle, ISP)：</h4><p>接口隔离原则是指客户端不应该依赖它不需要的接口，一个类对另一个类的依赖应该建立在最小的接口上。</p><p><strong>接口隔离原则的使用原则：</strong></p><ul><li>根据接口隔离原则拆分接口时，首先必须满足单一职责原则。</li><li>接口需要高内聚，提高接口，类和模块的处理能力，减少对外的交互。</li><li>定制服务，单独为一个个体提供优良服务(只提供访问者需要的方法)。</li><li>接口设计要有限度，接口设计的太小，容易造成开发难度增加或者可维护性降低。</li></ul><h4 id="迪米特法则-Law-of-Demeter，LoD-："><a href="#迪米特法则-Law-of-Demeter，LoD-：" class="headerlink" title="迪米特法则(Law of Demeter，LoD)："></a>迪米特法则(Law of Demeter，LoD)：</h4><p>迪米特法则也叫最少知识原则，是指一个对象应该对其依赖的对象有最少的了解。该类不需要知道其依赖类的具体实现，只需要依赖类给其提供一个公开对外的public方法即可，其余一概不需要了解。</p><p>迪米特法则的核心就是解耦合，减弱类间的各个耦合，提高类的复用率。</p><h4 id="开闭原则（Open-Close-Principle，OCP）："><a href="#开闭原则（Open-Close-Principle，OCP）：" class="headerlink" title="开闭原则（Open Close Principle，OCP）："></a>开闭原则（Open Close Principle，OCP）：</h4><p>开闭原则是指一个软件实体如类，模块和函数应该对扩展开放，对修改关闭。也就是说，通过开闭原则，我们可以通过扩展行为来实现新的功能，而不是通过修改已有的代码。开闭原则可以帮助我们构建一个稳定，灵活的软件系统。</p><h4 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h4><ul><li><strong>单一职责原则：类或者接口要实现职责单一</strong></li><li><strong>里氏替换原则：使用子类来替换父类，做出通用的编程</strong></li><li><strong>依赖倒置原则：面向接口编程</strong></li><li><strong>接口隔离原则：接口的设计需要精简单一</strong></li><li><strong>迪米特法则：降低依赖之间耦合</strong></li><li><strong>开闭原则：对扩展开放，对修改关闭</strong></li></ul><h3 id="单例模式（创建型模式）"><a href="#单例模式（创建型模式）" class="headerlink" title="单例模式（创建型模式）"></a>单例模式（创建型模式）</h3><p>单例模式是指在一个系统中，一个类有且只有一个对象实例。</p><p><strong>单例模式的实现：</strong>单例模式从创建方式上又分为饿汉式和懒汉式两种。</p><p>饿汉式的单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 秦海祺 &#123;2021/4/23&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Single</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Single s = <span class="hljs-keyword">new</span> Single();<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Single</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>饿汉式的单例模式在程序初始化的时候即创建了对象，在需要的时候可以直接返回该对象实例。</p><p>懒汉式的单例模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 秦海祺 &#123;2021/4/23&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Single</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Single s = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Single</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == s)&#123;<br>            s = <span class="hljs-keyword">new</span> Single();<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>加入synchronized内部锁来解决多线程环境下的线程安全问题，代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Single</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Single s = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Single</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> ==s)&#123;<br>            <span class="hljs-keyword">synchronized</span> (Single.class)&#123;&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == s)&#123;<br>                    s = <span class="hljs-keyword">new</span> Single();<br>                &#125;<br>            &#125;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Instance instance = new Instance()都发生了啥？</strong></p><p>具体步骤如下三步所示：</p><ul><li>在堆内存上分配对象的内存空间</li><li>在堆内存上初始化对象</li><li>设置instance指向刚分配的内存地址</li></ul><p>第二步和第三步可能会发生重排序，导致引用型变量指向了一个不为null但是也不完整的对象。所以，在多线程下上述的代码会返回一个不完整的对象。我们需要加入一个<strong>volatile</strong>关键字来禁止指令重排序。</p><p><strong>完整的多线程环境下的单例模式的实现代码如下</strong>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 秦海祺 &#123;2021/4/23&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Single</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Single s = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Single</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Single <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == s)&#123;<br>            <span class="hljs-keyword">synchronized</span> (Single.class)&#123;&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == s)&#123;<br>                    s = <span class="hljs-keyword">new</span> Single();<br>                &#125;<br>            &#125;&#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>单例模式的优点：</strong>单例模式保证了一个类在一个系统中有且只有一个对象实例，减少了系统内存和性能的开销。</p><p><strong>单例模式的使用场景：</strong>创建一个对象需要消耗太多的资源或者在一个系统中不适合创建多个对象实例的情况下，我们可以采用单例模式设计实现。</p><h3 id="工厂方法模式（创建型模式）"><a href="#工厂方法模式（创建型模式）" class="headerlink" title="工厂方法模式（创建型模式）"></a>工厂方法模式（创建型模式）</h3><p>工厂方法模式是一种常见的设计模式。工厂方法模式定义了一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法模式使一个类的实例化延迟到其子类。</p><p><strong>工厂方法模式的类图：</strong></p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210423193638.png" alt="图片说明"></p><p>其中，Product和ConcreteProduct分别表示抽象产品类和具体产品类。Creator和ConcreteCreator则分别表示抽象创建类和具体创建类。抽象创建类Creator中定义了创建产品的方法createProduct。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 秦海祺 &#123;2021/4/21&#125;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        Creator creator = <span class="hljs-keyword">new</span> ConcreteCreator();<br><br>        Product product = creator.createProduct(ConcreteProduct.class);<br><br>        product.method1();<br>        product.method2();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProduct</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Product</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Creator</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> &lt;T extends Product&gt; <span class="hljs-function">T <span class="hljs-title">createProduct</span><span class="hljs-params">(Class&lt;T&gt; c)</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteCreator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Creator</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T extends Product&gt; <span class="hljs-function">T <span class="hljs-title">createProduct</span><span class="hljs-params">(Class&lt;T&gt; c)</span> </span>&#123;<br>        Product product = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            product = (Product) Class.forName(c.getName()).newInstance();<br>        &#125;<span class="hljs-keyword">catch</span> (ClassNotFoundException | InstantiationException | IllegalAccessException e)&#123;<br><br>        &#125;<br>        <span class="hljs-keyword">return</span> (T)product;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>那么，工厂方法模式的优点有哪些呢？</strong></p><ul><li>工厂方法模式具有很好的封装性。客户端不需要知道创建对象的过程，只需要知道要创建的是哪个具体的产品即可。</li><li>工厂方法模式对扩展开放。当新增一个产品种类的时候，我们只需要传入新增产品类对象给具体工厂，即可返回新增的产品对象。</li></ul><p><strong>工厂方法模式的使用场景：</strong></p><ul><li>工厂方法模式的作用就是创建指定的对象，可以做为new一个对象的替代方式。但是需要考虑是否有必要使用工厂方法模式来创建对象。</li><li>当需要灵活，可扩展的创建多个对象的场景时，可以使用工厂方法模式。</li></ul><h3 id="模板方法模式（行为型模式）"><a href="#模板方法模式（行为型模式）" class="headerlink" title="模板方法模式（行为型模式）"></a>模板方法模式（行为型模式）</h3><p>模板方法模式也是一个常见的模式。模板方法模式定义了一个框架，将一些步骤延迟到其子类中实现，子类可以在不改变框架的前提下重新定义某些特定的执行步骤。</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210423195257.png" alt="图片说明"></p><p>AbstractClass是一个抽象模板，它的方法分为模板方法和基本方法。</p><ul><li>基本方法：是抽象方法，由子类实现，并且在模板方法中被调用。</li><li>模板方法：可以有一个或者几个，一般是具体的方法，实现对基本方法的调度，完成确定的业务逻辑，确定一个框架。</li></ul><p>ConcreteClass1和ConcreteClass2属于具体模板类，实现抽象模板所定义的抽象方法，并且拥有父类模板中的模板方法。</p><p>接下来，我们给出一个模板方法模式的Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 秦海祺 &#123;2021/4/21&#125;</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        Dog dog = <span class="hljs-keyword">new</span> Dog();<br>        Cat cat = <span class="hljs-keyword">new</span> Cat();<br><br>        dog.start();<br>        cat.start();<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        eat();<br>        run();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是小狗，我在吃东西...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是小狗，我在跑步...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span> </span>&#123;<br>        washHand();<br>        System.out.println(<span class="hljs-string">&quot;我是小猫，我在吃东西...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是小猫，我在跑步...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">washHand</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;我是小猫，我在洗手...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>那么，模板方法模式的优点有哪些呢？</strong></p><ul><li>封装不变部分，扩展可变部分</li><li>提取公共部分代码，便于维护</li><li>行为由父类控制，子类实现</li></ul><p>模板方法模式就是在模板方法中调用基本方法来确定整个算法的执行框架。</p><h3 id="抽象工厂模式（创建型模式）"><a href="#抽象工厂模式（创建型模式）" class="headerlink" title="抽象工厂模式（创建型模式）"></a>抽象工厂模式（创建型模式）</h3><p>抽象工厂模式为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。抽象工厂模式是工厂方法模式的升级版本，在有多个业务品种、业务分类时，通过抽象工厂模式产生需要的对象是一种非常好的解决方式。</p><p><strong>抽象工厂模式和工厂方法模式的区别：</strong></p><p>如果产品单一，适合使用工厂模式。但是如果有多个业务品种、业务分类时，需要使用抽象工厂模式。也就是说，工厂模式针对的是一个产品等级结构 ，抽象工厂模式针对的是面向多个产品等级结构的。</p><h3 id="代理模式（结构型模式）"><a href="#代理模式（结构型模式）" class="headerlink" title="代理模式（结构型模式）"></a>代理模式（结构型模式）</h3><p>代理模式为其他对象提供一种代理以控制对这个对象的访问。将原类进行封装，客户端不能直接找到原类，必须通过代理角色。即代理是原类的一个替身，客户端要找原类，必须找代理才可以搞定。明星和经纪人的关系就是一种代理模式。</p><p>代理模式又分为静态代理和动态代理。动态代理在实现阶段不用关心代理谁，而在运行阶段才指定代理哪一个对象。相对来说，自己写代理类的方式就是静态代理。</p><h3 id="策略模式（行为型模式）"><a href="#策略模式（行为型模式）" class="headerlink" title="策略模式（行为型模式）"></a>策略模式（行为型模式）</h3><p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的 context 对象。策略对象改变 context 对象的执行算法。</p><p><strong>意图：</strong>定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。</p><p><strong>主要解决：</strong>在有多种算法相似的情况下，使用 if…else 所带来的复杂和难以维护。</p><p><strong>何时使用：</strong>一个系统有许多许多类，而区分它们的只是他们直接的行为。</p><p><strong>如何解决：</strong>将这些算法封装成一个一个的类，任意地替换。</p><p><strong>关键代码：</strong>实现同一个接口。</p><p><strong>优点：</strong> 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。</p><p><strong>缺点：</strong> 1、策略类会增多。 2、所有策略类都需要对外暴露。</p><p><strong>注意事项：</strong>如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。</p><p>类图如下：</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210423201323.jpeg" alt="策略模式的 UML 图"></p><h3 id="责任链模式（行为型模式）"><a href="#责任链模式（行为型模式）" class="headerlink" title="责任链模式（行为型模式）"></a>责任链模式（行为型模式）</h3><p>责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><p><strong>意图：</strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p><strong>主要解决：</strong>职责链上的处理者负责处理请求，客户只需要将请求发送到职责链上即可，无须关心请求的处理细节和请求的传递，所以职责链将请求的发送者和请求的处理者解耦了。</p><p><strong>何时使用：</strong>在处理消息的时候以过滤很多道。</p><p><strong>如何解决：</strong>拦截的类都实现统一接口。</p><p><strong>关键代码：</strong>Handler 里面聚合它自己，在 HandlerRequest 里判断是否合适，如果没达到条件则向下传递，向谁传递之前 set 进去。</p><p><strong>优点：</strong> 1、降低耦合度。它将请求的发送者和接收者解耦。 2、简化了对象。使得对象不需要知道链的结构。 3、增强给对象指派职责的灵活性。通过改变链内的成员或者调动它们的次序，允许动态地新增或者删除责任。 4、增加新的请求处理类很方便。</p><p><strong>缺点：</strong> 1、不能保证请求一定被接收。 2、系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。 3、可能不容易观察运行时的特征，有碍于除错。</p><h3 id="观察者模式（行为型模式）"><a href="#观察者模式（行为型模式）" class="headerlink" title="观察者模式（行为型模式）"></a>观察者模式（行为型模式）</h3><p>当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知依赖它的对象。观察者模式属于行为型模式。</p><p><strong>意图：</strong>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><p><strong>主要解决：</strong>一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。</p><p><strong>何时使用：</strong>一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。</p><p><strong>如何解决：</strong>使用面向对象技术，可以将这种依赖关系弱化。</p><p><strong>关键代码：</strong>在抽象类里有一个 ArrayList 存放观察者们。</p><p><strong>优点：</strong> 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。</p><p><strong>缺点：</strong> 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</p><p><strong>注意事项：</strong> 1、JAVA 中已经有了对观察者模式的支持类。 2、避免循环引用。 3、如果顺序执行，某一观察者错误会导致系统卡壳，一般采用异步方式。</p><h3 id="适配器模式（结构型模式）"><a href="#适配器模式（结构型模式）" class="headerlink" title="适配器模式（结构型模式）"></a>适配器模式（结构型模式）</h3><p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁，它结合了两个独立接口的功能。</p><p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。举个真实的例子，读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡。</p><p><strong>意图：</strong>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p><strong>主要解决：</strong>主要解决在软件系统中，常常要将一些”现存的对象”放到新的环境中，而新环境要求的接口是现对象不能满足的。</p><p><strong>何时使用：</strong> 1、系统需要使用现有的类，而此类的接口不符合系统的需要。 2、想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。 3、通过接口转换，将一个类插入另一个类系中。（比如老虎和飞禽，现在多了一个飞虎，在不增加实体的需求下，增加一个适配器，在里面包容一个虎对象，实现飞的接口。）</p><p><strong>如何解决：</strong>继承或依赖（推荐）。</p><p><strong>关键代码：</strong>适配器继承或依赖已有的对象，实现想要的目标接口。</p><p><strong>优点：</strong> 1、可以让任何两个没有关联的类一起运行。 2、提高了类的复用。 3、增加了类的透明度。 4、灵活性好。</p><p><strong>缺点：</strong> 1、过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。 2.由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</p><h3 id="装饰器模式（结构型模式）"><a href="#装饰器模式（结构型模式）" class="headerlink" title="装饰器模式（结构型模式）"></a>装饰器模式（结构型模式）</h3><p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p><strong>意图：</strong>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><p><strong>主要解决：</strong>一般的，我们为了扩展一个类经常使用继承方式实现，由于继承为类引入静态特征，并且随着扩展功能的增多，子类会很膨胀。</p><p><strong>何时使用：</strong>在不想增加很多子类的情况下扩展类。</p><p><strong>如何解决：</strong>将具体功能职责划分，同时继承装饰者模式。</p><p><strong>关键代码：</strong> 1、Component 类充当抽象角色，不应该具体实现。 2、修饰类引用和继承 Component 类，具体扩展类重写父类方法。</p><p><strong>优点：</strong>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p><p><strong>缺点：</strong>多层装饰比较复杂。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mysql相关知识</title>
    <link href="/2021/04/23/mysql%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/04/23/mysql%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><h3 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h3><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可<strong>快速访问数据库表</strong>中的特定信息，就像一本书的目录一样，可以加快查询速度。InnoDB 存储引擎的索引模型底层实现<strong>数据结构为B+树</strong>，所有数据都是存储在 B+ 树中的。</p><span id="more"></span><h4 id="为什么底层数据结构使用B-树，而不是B树"><a href="#为什么底层数据结构使用B-树，而不是B树" class="headerlink" title="为什么底层数据结构使用B+树，而不是B树"></a>为什么底层数据结构使用B+树，而不是B树</h4><ul><li>B+树是B树的变种，B+树的非叶子节点只用来保存索引，不存储数据，所有的数据都保存在叶子节点；而B树的非叶子节点也会保存数据。这样就使得B+树的查询效率更加稳定，均为从根节点到叶子节点的路径。</li><li>B+树的内部结点并没有指向关键字具体信息的指针，因此其内部结点相对B 树更小，同样空间可以读入更多的节点，所以B+树的磁盘读写代价更低。</li></ul><h4 id="聚簇索引和非聚簇索引"><a href="#聚簇索引和非聚簇索引" class="headerlink" title="聚簇索引和非聚簇索引"></a>聚簇索引和非聚簇索引</h4><p><strong>主键索引</strong>就是一种聚簇索引，其索引树的叶子节点中存的是<strong>整行数据</strong>，表中行的物理顺序与键值的逻辑（索引）顺序相同。一个表只能包含一个聚集索引。因为索引（目录）只能按照一种方法进行排序。</p><p><strong>非聚簇索引（普通索引</strong>）的叶子节点内容是<strong>主键的值</strong>。在 InnoDB 里，非主键索引也被称为二级索引（secondary index）。</p><h4 id="MySQL回表"><a href="#MySQL回表" class="headerlink" title="MySQL回表"></a>MySQL回表</h4><ul><li>如果语句是 select * from User where id=3，即主键查询方式，则只需要搜索 主键索引树。</li><li>如果语句是 select * from User where uid=23，即普通索引查询方式，则需要先搜索 普通索引树，得到其对应的主键值为 3，再到主键索引树搜索一次。这个过程称为<strong>回表。</strong></li></ul><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果在普通索引树上的查询已经直接提供了结果，不需要回表操作，这样的普通索引叫做覆盖索引。覆盖索引的使用可以显著提高查询效率，是常见的MySQL性能优化手段。</p><h4 id="索引的最左前缀原则"><a href="#索引的最左前缀原则" class="headerlink" title="索引的最左前缀原则"></a>索引的最左前缀原则</h4><p>在联合索引的情况下，不需要索引的全部定义，只要满足最左前缀，就可以利用索引来加快查询速度。这个最左前缀可以是联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符。最左前缀原则的利用也可以显著提高查询效率，是常见的MySQL性能优化手段。</p><h4 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h4><p>在MySQL5.6之前，只能从根据最左前缀查询到ID开始一个个回表。到主键索引上找出数据行，再对比字段值。MySQL5.6引入的索引下推优化，（联合索引前提）可以在索引遍历过程中，对索引中包含的其余字段先做判断，直接过滤掉不满足条件的记录，减少回表次数，提升查询效率。</p><h3 id="哪些列上适合创建索引？创建索引有哪些开销？"><a href="#哪些列上适合创建索引？创建索引有哪些开销？" class="headerlink" title="哪些列上适合创建索引？创建索引有哪些开销？"></a>哪些列上适合创建索引？创建索引有哪些开销？</h3><p>经常需要作为条件查询的列上适合创建索引，并且该列上的数据也必须有一定的区分度。创建索引需要维护，在插入数据的时候会重新维护各个索引树（<strong>数据页的分裂与合并</strong>），对性能造成影响。</p><h4 id="自增主键："><a href="#自增主键：" class="headerlink" title="自增主键："></a>自增主键：</h4><p>为了在插入数据的时候不需要调整主键索引树的结构，强烈建议在建立表的时候使用自增主键。主键的顺序按照数据记录的插入顺序排列，自动有序。</p><h3 id="MySQL常见的存储引擎"><a href="#MySQL常见的存储引擎" class="headerlink" title="MySQL常见的存储引擎"></a>MySQL常见的存储引擎</h3><p>MySQL中最常见的存储引擎有InnoDB和MyISAM，它们的主要区别如下：</p><ul><li>MyISAM不支持事务；InnoDB是事务类型的存储引擎。</li><li>MyISAM只支持表级锁；InnoDB支持行级锁和表级锁，默认为行级锁。</li><li>MyISAM引擎不支持外键；InnoDB支持外键。</li><li>对于count(*)查询来说MyISAM更有优势，因为其保存了行数。</li><li>InnoDB是为处理巨大数据量时的最大性能设计的存储引擎。</li><li>MyISAM支持全文索引（FULLTEXT）；InnoDB不支持。</li></ul><p>最主要的区别就是MyISAM表不支持事务、不支持行级锁、不支持外键。 InnoDB表支持事务、支持行级锁、支持外键。</p><p>MySQL的基本逻辑架构图:</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210423144917.png" alt="图片说明"></p><p>由MySQL的逻辑架构图我们可以看出，逻辑架构包括<strong>Server层和存储引擎层</strong>。其中Server层包括连接器，分析器，优化器以及执行器；存储引擎层包括多种支持的存储引擎。各个逻辑部件的作用如下：</p><ul><li><strong>连接器：</strong>验证客户端权限，建立和断开MySQL连接</li><li><strong>分析器：</strong>进行SQL语句的语法分析</li><li><strong>优化器：</strong>选择索引，生成具体的SQL语句执行计划</li><li><strong>执行器：</strong>操作存储引擎，执行SQL，返回执行结果</li><li><strong>存储引擎层：</strong>各个不同的存储引擎都提供了一些读写接口来操作数据库</li></ul><p>在MySQL5.5.5版本之后，<strong>InnoDB已经成为了其默认的存储引擎</strong>。</p><p>除了InnoDB以及MyISAM存储引擎外，常见的考察存储引擎还有<strong>Memory，使用Memory作为存储引擎的表也可以叫做内存表</strong>，将数据存储在了内存中，所以适合做临时表来使用，在索引结构上支持B+树索引和Hash索引。</p><h3 id="MySQL中的where、group-by、having关键字"><a href="#MySQL中的where、group-by、having关键字" class="headerlink" title="MySQL中的where、group by、having关键字"></a>MySQL中的where、group by、having关键字</h3><ul><li>where子句用来筛选from子句中指定的操作所产生的的行</li><li>group by 子句用来分组where子句的输出</li><li>having子句用来从分组的结果中筛选行</li></ul><p><strong>having和where的区别：</strong></p><ul><li>语法类似，where搜索条件在进行分组操作之前应用；having搜索条件在进行分组操作之后应用</li><li>having可以包含聚合函数sum、avg、max等</li><li>having子句限制的是组，而不是行</li></ul><p><strong>当同时含有where子句、group by 子句 、having子句及聚集函数时，执行顺序如下：</strong></p><ul><li>执行where子句查找符合条件的数据</li><li>使用group by子句对数据进行分组</li><li>对group by子句形成的组运行聚集函数计算每一组的值</li><li>最后用having子句去掉不符合条件的组</li></ul><h3 id="MySQL的日志模块binlog和redo-log"><a href="#MySQL的日志模块binlog和redo-log" class="headerlink" title="MySQL的日志模块binlog和redo log"></a>MySQL的日志模块binlog和redo log</h3><p>在MySQL的使用中，更新操作也是很频繁的，如果每一次更新操作都根据条件找到对应的记录，然后将记录更新，再写回磁盘，那么<strong>IO成本以及查找记录的成本</strong>都很高。所以，出现了日志模块，即我们的update更新操作是<strong>先写日志，在合适的时间才会去写磁盘</strong>，日志更新完毕就将执行结果返回给了客户端。</p><p>MySQL中的日志模块主要有<strong>redo log（重做日志）和binlog（归档日志）。</strong></p><h4 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h4><p>redo log是<strong>InnoDB引擎特有</strong>的日志模块，redo log是物理日志，记录了某个数据页上做了哪些修改。InnoDB的redo log是固定大小的，比如可以配置为一组4个文件，每个文件的大小是1GB，那么redo log总共就可以记录 4GB的操作。从头开始写，写到末尾就又回到开头循环写。</p><p>InnoDB的redo log保证了数据库发生异常重启之后，之前提交的记录不会丢失，这个能力称为crash-safe。</p><h4 id="binlog"><a href="#binlog" class="headerlink" title="binlog"></a>binlog</h4><p>binlog是<strong>Server层自带</strong>的日志模块，binlog是逻辑日志，记录本次修改的原始逻辑，说白了就是SQL语句。binlog是追加写的形式，可以写多个文件，不会覆盖之前的日志。通过mysqlbinlog可以解析查看binlog日志。binlog日志文件的格式：statement，row，mixed。</p><ul><li><strong>statement格式</strong>的binlog记录的是完整的SQL语句，优点是日志文件小，性能较好，缺点也很明显，那就是准确性差，遇到SQL语句中有now()等函数会导致不准确</li><li><strong>row格式</strong>的binlog中记录的是数据行的实际数据的变更，优点就是数据记录准确，缺点就是日志文件较大。</li><li><strong>mixed格式</strong>的binlog是前面两者的混合模式</li></ul><p>业界目前推荐使用的是 row 模式，因为很多情况下对准确性的要求是排在第一位的。</p><p>在更新数据库的时候，通过redo log和binlog的<strong>两阶段提交</strong>，可以确保数据库异常崩溃之后数据的正确恢复。</p><p>在对数据库误操作之后，可以通过<strong>备份库+binlog</strong>将数据库状态恢复到“任意“时刻。</p><h4 id="为什么MySQL会突然变慢一下"><a href="#为什么MySQL会突然变慢一下" class="headerlink" title="为什么MySQL会突然变慢一下"></a>为什么MySQL会突然变慢一下</h4><p>当内存数据页和磁盘数据页内容不一致的时候，这个内存页就是“脏页”。内存数据写入到磁盘后，内存和磁盘上的数据页的内容就一致了，这个时候的内存页就是”干净页“。</p><p>前面我们介绍了更新数据库的时候是<strong>先写日志</strong>，当合适的机会（空闲）出现的时候才会<strong>更新磁盘</strong>。但是<strong>当redo log 写满了，要 flush 脏页</strong>，也就是把内存里的数据写入磁盘，会导致MySQL执行速度突然变慢一瞬间。</p><h3 id="MySQL事务的特性"><a href="#MySQL事务的特性" class="headerlink" title="MySQL事务的特性"></a>MySQL事务的特性</h3><p>事务是单个逻辑工作单元执行的<strong>一系列操作</strong>，是一个不可分割的工作单位。满足如下的四大特性：</p><ul><li><strong>原子性（Atomicity）：</strong>事务作为一个整体被执行 ，要么全部执行，要么全部不执行；</li><li><strong>一致性（Consistency）：</strong>保证数据库状态从一个一致状态转变为另一个一致状态；</li><li><strong>隔离性（Isolation）：</strong>多个事务并发执行时，一个事务的执行不应影响其他事务的执行；</li><li><strong>持久性（Durability）：</strong>一个事务一旦提交，对数据库的修改应该永久保存</li></ul><h4 id="不做控制的话，多个事务并发操作数据库会产生哪些问题？"><a href="#不做控制的话，多个事务并发操作数据库会产生哪些问题？" class="headerlink" title="不做控制的话，多个事务并发操作数据库会产生哪些问题？"></a>不做控制的话，多个事务并发操作数据库会产生哪些问题？</h4><ul><li><p><strong>丢失更新：</strong><br>两个不同事务同时获得相同数据，然后在各自事务中同时修改了该数据，那么先提交的事务更新会被后提交事务的更新给覆盖掉，这种情况先提交的事务所做的更新就被覆盖，导致数据更新丢失。</p></li><li><p><strong>脏读：</strong><br>事务A读取了事务B未提交的数据，由于事务B回滚，导致了事务A的数据不一致，结果事务A出现了脏读；</p></li><li><p><strong>不可重复读：</strong><br>一个事务在自己没有更新数据库数据的情况，同一个查询操作执行两次或多次得到的结果数值不同，因为别的事务更新了该数据，并且提交了事务。</p></li><li><p><strong>幻读：</strong><br>事务A读的时候读出了N条记录，事务B在事务A执行的过程中增加 了1条，事务A再读的时候就变成了N+1条，这种情况就叫做幻读。</p></li></ul><p><strong>注意：</strong>幻读是指一种结构上的改变，比如说条数发生了改变；不可重复读是指读出的数值发生了改变。</p><h4 id="MySQL数据库事务的隔离级别"><a href="#MySQL数据库事务的隔离级别" class="headerlink" title="MySQL数据库事务的隔离级别"></a>MySQL数据库事务的隔离级别</h4><p>为了避免数据库事务操作中的问题，MySQL定义了4个事务隔离级别，不同的隔离级别对事务的处理不同。</p><ul><li><p><strong>读未提交(Read Uncommitted)：</strong><br>允许脏读取。如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。</p></li><li><p><strong>读已提交(Read Committed)：</strong><br>允许不可重复读取，但不允许脏读取。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。</p></li><li><p><strong>可重复读(Repeatable Read)：</strong><br>禁止不可重复读取和脏读取，但是有时可能出现幻读。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务。</p></li><li><p><strong>序列化(Serializable)：</strong><br>提供严格的事务隔离。它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。</p></li></ul><p>事务的隔离级别越高，对数据的完整性和一致性保证越佳，但是对并发操作的影响也越大。MySQL事务默认隔离级别是可重复读。</p><h3 id="MySQL中的锁机制"><a href="#MySQL中的锁机制" class="headerlink" title="MySQL中的锁机制"></a>MySQL中的锁机制</h3><p>MySQL数据库的锁分为<strong>表级锁和行级锁</strong>。从数据库的角度看，行级锁又可以分为<strong>独占锁和共享锁</strong>。</p><p><strong>独占锁（排他锁），也称X锁（Exclusive Lock）：</strong></p><p>独占锁锁定的资源只允许进行锁定操作的程序使用，其它任何对它的操作均不会被接受。执行数据更新命令，<strong>即INSERT、UPDATE 或DELETE 命令时，MySQL会自动使用独占锁</strong>。但当对象上有其它锁存在时，无法对其加独占锁。独占锁一直到事务结束才能被释放。</p><p>在select命令中使用独占锁的SQL语句为：<strong>select … for update;</strong></p><p><strong>共享锁，也叫S锁（Shared Lock）：</strong></p><p>共享锁顾名思义，那就是其锁定的资源可以被其它用户读取，但其它用户不能修改。如果在select查询语句中要手动加入共享锁，那么对应的SQL语句为：<strong>select … lock in share mode</strong></p><p>一个事务在一行数据上加入了独占锁，那么其余事务不可以在该数据行上加入任何锁。也就是说加过排他锁的数据行在其他事务中是不能修改数据的，也不能通过<strong>for update和lock in share mode锁</strong>的方式查询数据，但<strong>可以直接通过select …from…查询数据</strong>，因为普通查询没有任何锁机制。</p><h4 id="MySQL中的死锁"><a href="#MySQL中的死锁" class="headerlink" title="MySQL中的死锁"></a>MySQL中的死锁</h4><p>MySQL中的死锁主要是<strong>多个事务使用行级锁对某行数据加锁造成的</strong>，上一小节说了MyISAM不支持行级锁，所以MySQL中的死锁主要是在说InnoDB存储引擎的死锁。</p><h4 id="如何解决死锁"><a href="#如何解决死锁" class="headerlink" title="如何解决死锁"></a>如何解决死锁</h4><p>我们可以在业务上和数据库设置上来解决MySQL死锁。分别介绍如下：</p><p><strong>业务逻辑上的死锁解决方案：</strong></p><ul><li>指定锁的获取顺序</li><li>大事务拆分成各个小事务</li><li>在同一个事务中，一次锁定尽量多的资源，减少死锁概率</li><li>给表建立合适的索引以及降低事务的隔离级别等</li></ul><p><strong>数据库的设置来解决死锁：</strong></p><ul><li>通过参数 innodb_lock_wait_timeout 根据实际业务场景来<strong>设置超时时间</strong>，InnoDB引擎默认值是50s。</li><li><strong>发起死锁检测</strong>，发现死锁后，<strong>主动回滚</strong>死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑（默认是开启状态）。</li></ul><h4 id="行级锁什么时候会锁住整个表"><a href="#行级锁什么时候会锁住整个表" class="headerlink" title="行级锁什么时候会锁住整个表"></a>行级锁什么时候会锁住整个表</h4><p>InnoDB行级锁是通过锁索引记录实现的，如果更新的列没建索引是会锁住整个表的。</p><h4 id="悲观锁与乐观锁："><a href="#悲观锁与乐观锁：" class="headerlink" title="悲观锁与乐观锁："></a>悲观锁与乐观锁：</h4><p><strong>悲观锁：</strong>利用数据库的锁机制实现，在整个数据处理过程中都加入了锁，以保持排他性。</p><p><strong>乐观锁：</strong>乐观锁可以利用CAS实现，在<strong>操作数据</strong>的时候进行一个比较，按照<strong>当前事务中的数据和数据库表中的该数据是否一致</strong>来决定是否要执行本次操作。</p><h4 id="乐观锁的ABA问题及如何解决"><a href="#乐观锁的ABA问题及如何解决" class="headerlink" title="乐观锁的ABA问题及如何解决"></a>乐观锁的ABA问题及如何解决</h4><p>ABA问题是指在当前事务读取该行数据时是A，经过别的事务修改成B，但是在当前事务要更新数据的时候，该行数据又被别的事务修改为A，事实上数据行是发生过改变的，存在并发问题。</p><p>ABA问题可以通过<strong>基于数据版本（Version）记录机制</strong>来解决。也就是为数据增加一个版本标识。读取出数据时，将此版本号一同读出，之后更新时，对此版本号加一。根据当前事务的数据版本号和数据库中数据的版本号对比来决定是否更新数据。</p><p>与给当前数据增加一个数据版本类似，我们也可以增加基于时间戳机制来解决ABA问题，通过时间戳来记录当前数据行变化。</p><h3 id="SQL优化或者MySQL故障排查"><a href="#SQL优化或者MySQL故障排查" class="headerlink" title="SQL优化或者MySQL故障排查"></a>SQL优化或者MySQL故障排查</h3><p>一般情况下，我们遇到一个SQL异常的时候，比如说执行时间超时等，可以通过<strong>explain</strong>查看当前SQL语句的执行情况。explain +SQL语句可以查看当前的SQL语句使用的索引以及其扫描了多少行数据。也可以使用下边的语句来查看数据表的一些信息：</p><ul><li><strong>show create table TableXX；</strong>查看当前表TableXX的建表语句</li><li><strong>show index from TableXX；</strong>查看当前表TableXX上的索引</li></ul><p>查看了数据表的信息，一般情况下我们可以通过建立索引来提高查询速度，或者修改SQL语句，利用索引下推或者最左前缀原则等来加快查询速度。</p><h3 id="MySQL建表的约束条件有哪些"><a href="#MySQL建表的约束条件有哪些" class="headerlink" title="MySQL建表的约束条件有哪些"></a>MySQL建表的约束条件有哪些</h3><p>约束条件是我们建表的时候对数据库表做的一个限制条件。MySQL建表时候一般有如下的五个约束条件：</p><ul><li><strong>主键约束</strong>（Primary Key Constraint） 唯一性，非空性</li><li><strong>唯一约束</strong> （Unique Constraint）唯一性，可以空，但只能有一个</li><li><strong>检查约束</strong> (Check Constraint) 对该列数据的范围、格式的限制</li><li><strong>默认约束</strong> (Default Constraint) 该数据的默认值</li><li><strong>外键约束</strong> (Foreign Key Constraint) 需要建立两表间的关系并引用主表的列</li></ul><h3 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h3><p>回滚日志（undo log）：在 MySQL 中，实际上每条记录在更新的时候都会同时记录一条回滚操作。记录上的最新值，通过回滚操作，都可以得到前一个状态的值。</p><h3 id="MVCC的实现方式"><a href="#MVCC的实现方式" class="headerlink" title="MVCC的实现方式"></a>MVCC的实现方式</h3><ol><li>InnoDB实现MVCC，多个版本的数据可以共存，主要是依靠数据的隐藏列(也可以称之为标记位)和undo log。 </li><li>其中数据的隐藏列包括了该行数据的版本号、删除时间、指向undo log的指针等等；</li><li>当读取数据时，MySQL可以通过隐藏列判断是否需要回滚并找到回滚需要的undo log，从而实现MVCC</li></ol><h3 id="事务如何实现MVCC"><a href="#事务如何实现MVCC" class="headerlink" title="事务如何实现MVCC"></a>事务如何实现MVCC</h3><ol><li>事务是如何实现的MVCC呢?   1. 每个事务都有一个事务ID，叫做transaction id(严格递增)  。</li><li>事务在启动时，找到已提交的最大事务ID记为up_limit_id。   </li><li>事务在更新一条语句时，比如id=1改为了id=2。会把id=1和该行之前的row trx_id写到undo log里，并且在数据页上把id的值改为2,并且把修改这条语句的transaction id记在该行行头。</li></ol><h3 id="limit分页查询"><a href="#limit分页查询" class="headerlink" title="limit分页查询"></a>limit分页查询</h3><p>分页sql格式是：<em><em>select * from table limit (start-1)<em>pageSize, pageSize;</em></em> 其中</em>*start<strong>是页码，</strong>pageSize**是每页显示的条数。</p><h3 id="order-by是怎么工作的"><a href="#order-by是怎么工作的" class="headerlink" title="order by是怎么工作的"></a>order by是怎么工作的</h3>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jvm内存机制</title>
    <link href="/2021/04/22/jvm%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/04/22/jvm%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="JVM内存机制"><a href="#JVM内存机制" class="headerlink" title="JVM内存机制"></a>JVM内存机制</h1><h3 id="JVM中的内存是怎么划分的？"><a href="#JVM中的内存是怎么划分的？" class="headerlink" title="JVM中的内存是怎么划分的？"></a>JVM中的内存是怎么划分的？</h3><p>JVM中的内存主要划分为5个区域，即<strong>方法区，堆内存，程序计数器，虚拟机栈以及本地方法栈</strong>。下边是Java虚拟机运行时数据区示意图：</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422155921.png" alt="图片说明"></p><span id="more"></span><p><strong>方法区：</strong>方法区是一个<strong>线程之间共享</strong>的区域。<strong>常量，静态变量以及JIT编译后的代码都在方法区。主要用于存储已被虚拟机加载的类信息</strong>，也可以称为“永久代”，垃圾回收效果一般，通过-XX：MaxPermSize控制上限。</p><p><strong>堆内存：</strong>堆内存是<strong>垃圾回收</strong>的主要场所，也是线程之间共享的区域，主要用来<strong>存储创建的对象实例</strong>，通过-Xmx 和-Xms 可以控制大小。</p><p><strong>虚拟机栈（栈内存）：</strong>栈内存中主要保存<strong>局部变量、基本数据类型变量</strong>以及<strong>堆内存中某个对象的引用变量</strong>。每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表，操作数栈，动态链接，方法出口等信息。栈中的栈帧随着方法的进入和退出有条不紊的执行着出栈和入栈的操作。</p><p><strong>程序计数器：</strong> 程序计数器是当前线程执行的<strong>字节码的位置指示器</strong>。字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，是内存区域中唯一一个在虚拟机规范中<strong>没有规定任何OutOfMemoryError情况</strong>的区域。</p><p><strong>本地方法栈：</strong> 主要是为JVM提供使用native方法的服务。</p><h3 id="对象创建过程中的内存分配"><a href="#对象创建过程中的内存分配" class="headerlink" title="对象创建过程中的内存分配"></a>对象创建过程中的内存分配</h3><p>一般情况下我们通过new指令来创建对象，当虚拟机遇到一条new指令的时候，会去检查这个指令的参数是否能在常量池中定位到某个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化。如果没有，那么会执行类加载过程。</p><p>通过执行类的加载，验证，准备，解析，初始化步骤，完成了类的加载，这个时候会为该对象进行内存分配，也就是把一块确定大小的内存从Java堆中划分出来，在<strong>分配的内存</strong>上完成对象的创建工作。</p><p><strong>对象的内存分配有两种方式，即指针碰撞和空闲列表方式。</strong></p><p><strong>指针碰撞方式：</strong></p><p>假设Java堆中的内存是绝对规整的，用过的内存在一边，未使用的内存在另一边，中间有一个指示指针，那么所有的内存分配就是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。</p><p><strong>空闲列表方式：</strong></p><p>如果Java堆内存中不是规整的，已使用和未使用的内存相互交错，那么虚拟机就必须维护一个列表用来记录哪块内存是可用的，在分配的时候找到一块足够大的空间分配对象实例，并且需要更新列表上的记录。</p><p>Java <strong>堆内存是否规整</strong>是由所使用的垃圾收集器<strong>是否拥有压缩整理功能来决定</strong>的</p><h4 id="内存分配是如何保证线程安全的"><a href="#内存分配是如何保证线程安全的" class="headerlink" title="内存分配是如何保证线程安全的"></a>内存分配是如何保证线程安全的</h4><ul><li>对分配内存空间的动作进行同步处理，通过“<strong>CAS + 失败重试</strong>”的方式保证更新指针操作的原子性</li><li>把分配内存的动作按照线程划分在不同的空间之中，即给每一个线程都预先分配一小段的内存，称为<strong>本地线程分配缓存（TLAB）</strong>，只有TLAB用完并分配新的TLAB时，才需要进行同步锁定。 虚拟机是否使用TLAB，可以通过**-XX: +/-UserTLAB**参数来设定</li></ul><h3 id="对象被访问时是如何找到的"><a href="#对象被访问时是如何找到的" class="headerlink" title="对象被访问时是如何找到的"></a>对象被访问时是如何找到的</h3><p>当创建一个对象的时候，在栈内存中会有一个引用变量，指向堆内存中的某个具体的对象实例。</p><p>Java虚拟机规范中并<strong>没有规定这个引用变量应该以何种方式去定位和访问堆内存中的具体对象</strong>。目前常见的对象访问方式有两种，即句柄访问方式和直接指针访问方式，分别介绍如下。</p><p><strong>句柄访问方式：</strong></p><p>在JVM的堆内存中划分出一块内存来作为句柄池，引用变量中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息。在内存垃圾收集之后，对象会移动，但是引用reference中存储的是稳定的句柄地址，但是句柄地址方式不直接，访问速度较慢。</p><p><strong>直接指针访问方式：</strong></p><p>引用变量中存储的就是对象的直接地址，通过指针直接访问对象。直接指针的访问方式节省了一次指针定位的时间开销，速度较快。Sun HotSpot使用了直接指针方式进行对象的访问。</p><h3 id="内存分配和垃圾回收"><a href="#内存分配和垃圾回收" class="headerlink" title="内存分配和垃圾回收"></a>内存分配和垃圾回收</h3><p>JVM的内存可以分为<strong>堆内存和非堆内存</strong>。堆内存分为<strong>年轻代和老年代</strong>。年轻代又可以进一步划分为<strong>一个Eden（伊甸）区和两个Survivor（幸存）区</strong>组成。如下图所示：</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422170158.png" alt="图片说明"></p><h4 id="JVM堆内存的分配："><a href="#JVM堆内存的分配：" class="headerlink" title="JVM堆内存的分配："></a>JVM堆内存的分配：</h4><p>JVM初始分配的堆内存由**-Xms<strong>指定，默认是物理内存的1/64。JVM最大分配的堆内存由</strong>-Xmx**指定，默认是物理内存的1/4。</p><p>默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制。空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。因此我们一般设置-Xms和-Xmx相等以避免在每次GC 后调整堆的大小。</p><p>通过参数**-Xmn2G** 可以设置年轻代大小为2G。通过**-XX:SurvivorRatio**可以设置年轻代中Eden区与Survivor区的比值，设置为8，则表示年轻代中Eden区与一块Survivor的比例为8：1。注意年轻代中有两块Survivor区域。</p><h4 id="JVM非堆内存的分配："><a href="#JVM非堆内存的分配：" class="headerlink" title="JVM非堆内存的分配："></a>JVM非堆内存的分配：</h4><p>JVM使用**-XX:PermSize** 设置非堆内存初始值，默认是物理内存的1/64。由**-XX:MaxPermSize**设置最大非堆内存的大小，默认是物理内存的1/4。</p><h4 id="堆内存上对象的分配与回收"><a href="#堆内存上对象的分配与回收" class="headerlink" title="堆内存上对象的分配与回收"></a>堆内存上对象的分配与回收</h4><p>我们创建的对象会优先在Eden分配，如果是大对象（很长的字符串数组）则可以直接进入老年代。虚拟机提供一个**-XX:PretenureSizeThreshold参数**，令大于这个参数值的对象直接在老年代中分配，避免在Eden区和两个Survivor区发生大量的内存拷贝。</p><p>另外，<strong>长期存活的对象将进入老年代</strong>，每一次<strong>MinorGC（年轻代GC）</strong>，对象年龄就大一岁，默认15岁晋升到老年代，通过**-XX:MaxTenuringThreshold设置晋升年龄。**</p><p><strong>堆内存上的对象回收也叫做垃圾回收，那么垃圾回收什么时候开始呢？</strong></p><p>垃圾回收主要是完成<strong>清理对象，整理内存</strong>的工作。上面说到GC经常发生的区域是堆区，堆区还可以细分为新生代、老年代。新生代还分为一个Eden区和两个Survivor区。垃圾回收分为年轻代区域发生的Minor GC和老年代区域发生的Full GC，分别介绍如下。</p><p><strong>Minor GC（年轻代GC）:</strong><br>对象优先在Eden中分配，当Eden中没有足够空间时，虚拟机将发生一次Minor GC，因为Java大多数对象都是朝生夕灭，所以Minor GC非常频繁，而且速度也很快。</p><p><strong>Full GC（老年代GC）:</strong><br>Full GC是指发生在老年代的GC，当老年代没有足够的空间时即发生Full GC，发生Full GC一般都会有一次Minor GC。</p><p><strong>动态对象年龄判定：</strong></p><p>如果Survivor空间中相同年龄所有对象的大小总和大于Survivor空间的一半，那么<strong>年龄大于等于该对象年龄的对象即可晋升</strong>到老年代，不必要等到-XX:MaxTenuringThreshold。</p><p><strong>空间分配担保：</strong></p><p>发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小。如果大于，则进行一次<strong>Full GC（老年代GC）</strong>，如果小于，则查看<strong>HandlePromotionFailure设置是否允许担保失败</strong>，如果允许，那只会进行一次<strong>Minor GC</strong>，如果不允许，则改为进行一次<strong>Full GC</strong>。</p><h3 id="JVM如何判定一个对象是否应该被回收"><a href="#JVM如何判定一个对象是否应该被回收" class="headerlink" title="JVM如何判定一个对象是否应该被回收"></a>JVM如何判定一个对象是否应该被回收</h3><p>判断一个对象是否应该被回收，主要是看其是否还有引用。判断对象是否存在引用关系的方法包括<strong>引用计数法以及root根搜索方法</strong>。</p><p><strong>引用计数法：</strong></p><p>是一种比较古老的回收算法。原理是此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数。垃圾回收时，只需要收集计数为0的对象。此算法最致命的是<strong>无法处理循环引用</strong>的问题。</p><p><strong>root根搜索方法：</strong></p><p>root搜索方法的基本思路就是通过一系列可以做为root的对象作为起始点，从这些节点开始向下搜索。当一个对象到root节点没有任何引用链接时，则证明此对象是可以被回收的。以下对象会被认为是root对象：</p><ul><li><strong>栈内存中引用的对象</strong></li><li><strong>方法区中静态引用和常量引用指向的对象</strong></li><li>被启动类（bootstrap加载器）加载的类和创建的对象</li><li>Native方法中JNI引用的对象。</li></ul><h4 id="什么是对象的引用？"><a href="#什么是对象的引用？" class="headerlink" title="什么是对象的引用？"></a>什么是对象的引用？</h4><p>如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称为<strong>这块内存代表一个引用</strong>。JDK1.2以后将引用分为<strong>强引用，软引用，弱引用和虚引用四种。</strong></p><ul><li><strong>强引用：</strong>普通存在， P p = new P()，只要强引用存在，垃圾收集器永远不会回收掉被引用的对象。</li><li><strong>软引用：</strong>通过SoftReference类来实现软引用，在内存不足的时候会将这些软引用回收掉。</li><li><strong>弱引用：</strong>通过WeakReference类来实现弱引用，每次垃圾回收的时候肯定会回收掉弱引用。</li><li><strong>虚引用：</strong>也称为幽灵引用或者幻影引用，通过PhantomReference类实现。设置虚引用只是为了对象被回收时候收到一个系统通知。</li></ul><h3 id="JVM垃圾回收算法有哪些？"><a href="#JVM垃圾回收算法有哪些？" class="headerlink" title="JVM垃圾回收算法有哪些？"></a>JVM垃圾回收算法有哪些？</h3><p>HotSpot 虚拟机采用了<strong>root根搜索方法</strong>来进行内存回收，常见的回收算法有<strong>标记-清除算法，复制算法和标记整理算法。</strong></p><p><strong>标记-清除算法（Mark-Sweep）：</strong></p><p>标记-清除算法执行分两阶段。第一阶段从引用根节点开始标记所有被引用的对象，第二阶段遍历整个堆，把未标记的对象清除。此算法需要暂停整个应用，并且会产生内存碎片。</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422175509.png" alt="图片说明"></p><p><strong>复制算法：</strong></p><p>复制算法把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾回收时，遍历当前使用区域，把正在使用中的对象复制到另外一个区域中。复制算法每次只处理正在使用中的对象，因此复制成本比较小，同时复制过去以后还能进行相应的内存整理，不会出现“碎片”问题。当然，此算法的缺点也是很明显的，就是需要两倍内存空间。</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422175610.png" alt="图片说明"></p><p><strong>标记-整理算法：</strong></p><p>标记-整理算法结合了<strong>“标记-清除”和“复制”</strong>两个算法的优点。也是分两阶段，第一阶段从根节点开始标记所有被引用对象，第二阶段遍历整个堆，清除未标记对象并且把存活对象“压缩”到堆的其中一块，按顺序排放。此算法避免了“标记-清除”的碎片问题，同时也避免了“复制”算法的空间问题。</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422180817.png" alt="图片说明"></p><p>年轻代垃圾回收一般采用复制算法，老年代垃圾回收一般采用标记-清除和标记-整理算法</p><h3 id="JVM中的垃圾收集器"><a href="#JVM中的垃圾收集器" class="headerlink" title="JVM中的垃圾收集器"></a>JVM中的垃圾收集器</h3><p>JVM中的垃圾收集器主要包括7种，即<strong>Serial，Serial Old，ParNew，Parallel Scavenge，Parallel Old以及CMS，G1收集器</strong>。如下图所示：</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422182047.png" alt="图片说明"></p><p><strong>Serial收集器：</strong></p><p>Serial收集器是<strong>一个单线程的垃圾收集器</strong>，并且在执行垃圾回收的时候需要 <strong>Stop The World</strong>。虚拟机运行在<strong>Client模式</strong>下的默认新生代收集器。Serial收集器的优点是简单高效，对于限定在单个CPU环境来说，Serial收集器没有多线程交互的开销。</p><p><strong>Serial Old收集器：</strong></p><p>Serial Old是Serial收集器的老年代版本，也是<strong>一个单线程收集器</strong>。主要也是给在Client模式下的虚拟机使用。在Server模式下存在主要是做为CMS垃圾收集器的后备预案，<strong>当CMS并发收集发生Concurrent Mode Failure时使用。</strong></p><p><strong>ParNew收集器：</strong></p><p>ParNew是Serial收集器的<strong>多线程</strong>版本，新生代是并行的（多线程的），老年代是串行的（单线程的），新生代采用复制算法，老年代采用标记整理算法。可以使用参数：**-XX：UseParNewGC使用该收集器，使用 -XX：ParallelGCThreads可以限制线程数量。**</p><p><strong>Parallel Scavenge垃圾收集器：</strong></p><p>Parallel Scavenge是一种新生代收集器，使用复制算法的收集器，而且是<strong>并行的多线程收集器。</strong>Parallel收集器特点是更加关注吞吐量（吞吐量就是cpu用于运行用户代码的时间与cpu总消耗时间的比值）。可以通过**-XX:MaxGCPauseMillis参数控制最大垃圾收集停顿时间；通过-XX:GCTimeRatio参数直接设置吞吐量大小；通过-XX:+UseAdaptiveSizePolicy参数可以打开GC自适应调节策略，<strong>该参数打开之后虚拟机会根据系统的运行情况收集性能监控信息，动态调整虚拟机参数以提供最合适的停顿时间或者最大的吞吐量。</strong>自适应调节策略**是Parallel Scavenge收集器和ParNew的主要区别之一。</p><p><strong>Parallel Old收集器：</strong></p><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。</p><p><strong>CMS（Concurrent Mark Sweep）收集器</strong>：</p><p>CMS收集器是<strong>一种以获取最短回收停顿时间为目标</strong>的收集器。CMS收集器是基于<strong>标记-清除算法</strong>实现的，是一种老年代收集器，通常与<strong>ParNew</strong>一起使用。</p><p><strong>CMS的垃圾收集过程分为4步：</strong></p><ul><li><strong>初始标记</strong>：需要“Stop the World”，初始标记仅仅只是标记一下GC Root能直接关联到的对象，速度很快。</li><li><strong>并发标记</strong>：是主要标记过程，这个标记过程是和用户线程并发执行的。</li><li><strong>重新标记</strong>：需要“Stop the World”，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录（停顿时间比初始标记长，但比并发标记短得多）。</li><li><strong>并发清除</strong>：和用户线程并发执行的，基于标记结果来清理对象。</li></ul><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422193203.png" alt="图片说明"></p><p><strong>如果在重新标记之前刚好发生了一次MinorGC，会不会导致重新标记阶段Stop the World时间太长？</strong></p><p>不会的，在并发标记阶段其实还包括了一次并发的<strong>预清理阶段</strong>，虚拟机会主动<strong>等待年轻代发生垃圾回收</strong>，这样可以将重新标记对象引用关系的步骤放在并发标记阶段，有效降低重新标记阶段Stop The World的时间。</p><h4 id="CMS垃圾回收器的优点："><a href="#CMS垃圾回收器的优点：" class="headerlink" title="CMS垃圾回收器的优点："></a>CMS垃圾回收器的优点：</h4><p>CMS以降低垃圾回收的停顿时间为目的，很显然其具有并发收集、停顿时间低的优点。</p><h4 id="CMS垃圾回收器的缺点："><a href="#CMS垃圾回收器的缺点：" class="headerlink" title="CMS垃圾回收器的缺点："></a>CMS垃圾回收器的缺点：</h4><ul><li><strong>对CPU资源非常敏感</strong>，因为并发标记和并发清理阶段和用户线程一起运行，当CPU数变小时，性能容易出现问题。</li><li>收集过程中会产生<strong>浮动垃圾</strong>，所以不可以在老年代内存不够用了才进行垃圾回收，必须提前进行垃圾收集。通过参数**-XX:CMSInitiatingOccupancyFraction<strong>的值来控制内存使用百分比。如果该值设置的太高，那么在CMS运行期间预留的内存可能无法满足程序所需，会出现</strong>Concurrent Mode Failure失败，之后会临时使用Serial Old收集器做为老年代收集器**，会产生更长时间的停顿。</li><li><strong>标记-清除方式会产生内存碎片</strong>，可以使用参数**-XX：UseCMSCompactAtFullCollection<strong>来控制是否开启内存整理（无法并发，默认是开启的）。参数</strong>-XX:CMSFullGCsBeforeCompaction**用于设置执行多少次不压缩的Full GC后进行一次带压缩的内存碎片整理（默认值是0）。</li></ul><p><strong>浮动垃圾：</strong></p><p>由于在应用运行的同时进行垃圾回收，所以有些垃圾可能在垃圾回收进行完成时产生，这样就造成了<strong>“Floating Garbage（浮动垃圾）”</strong>，这些垃圾需要在下次垃圾回收周期时才能回收掉。所以，<strong>并发收集器一般需要20%的预留空间</strong>用于这些浮动垃圾。</p><p><strong>G1（Garbage-First）收集器：</strong></p><p>G1收集器将新生代和老年代取消了，取而代之的是<strong>将堆划分为若干的区域</strong>，仍然属于分代收集器，区域的一部分包含新生代，新生代采用复制算法，老年代采用标记-整理算法。</p><p>通过<strong>将JVM堆分为一个个的区域（region）</strong>,G1收集器可以避免在Java堆中进行全区域的垃圾收集。G1跟踪各个region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的比值），在后台维护一个优先列表，每次<strong>根据回收时间来优先回收价值最大的region。</strong></p><p><strong>G1收集器的特点：</strong></p><ul><li><strong>并行与并发</strong>：G1能充分利用多CPU，多核环境下的硬件优势，来缩短Stop the World，是并发的收集器。</li><li><strong>分代收集</strong>：G1不需要其他收集器就能独立管理整个GC堆，能够采用不同的方式去处理新建对象、存活一段时间的对象和熬过多次GC的对象。</li><li><strong>空间整合</strong>：G1从整体来看是基于标记-整理算法，从局部（两个Region）上看基于复制算法实现，G1运作期间不会产生内存空间碎片。</li><li><strong>可预测的停顿</strong>：能够建立可以预测的停顿时间模型，预测停顿时间。</li></ul><p><strong>和CMS收集器类似，G1收集器的垃圾回收工作也分为了四个阶段：</strong></p><ul><li>初始标记</li><li>并发标记</li><li>最终标记</li><li>筛选回收</li></ul><p>其中，筛选回收阶段首先对各个Region的回收价值和成本进行计算，根据用户期望的GC停顿时间来制定回收计划。</p><p><strong>CMS也确实是我们服务中最常使用的垃圾收集器</strong>。利用CMS并发标记和清理的特性，<strong>可以有效降低用户的停顿时间，对于服务的稳定性有一个非常显著的提升</strong>。</p><h3 id="JVM常用内存调优命令："><a href="#JVM常用内存调优命令：" class="headerlink" title="JVM常用内存调优命令："></a>JVM常用内存调优命令：</h3><p>JVM在内存调优方面，提供了几个常用的命令，分别为<strong>jps，jinfo，jstack，jmap以及jstat命令</strong>。分别介绍如下：</p><ul><li><strong>jps：</strong>主要用来输出JVM中运行的进程状态信息，一般使用jps命令来查看进程的状态信息，包括JVM启动参数等。</li><li><strong>jinfo：</strong>主要用来观察进程运行环境参数等信息。</li><li><strong>jstack：</strong>主要用来查看某个Java进程内的线程堆栈信息。jstack pid 可以看到当前进程中各个线程的状态信息，包括其持有的锁和等待的锁。</li><li><strong>jmap：</strong>用来查看堆内存使用状况。jmap -heap pid可以看到当前进程的堆信息和使用的GC收集器，包括年轻代和老年代的大小分配等</li><li><strong>jstat：</strong>进行实时命令行的监控，包括堆信息以及实时GC信息等。可以使用jstat -gcutil pid1000来每隔一秒来查看当前的GC信息。</li></ul><p><strong>jps</strong> 用于显示当前所有java进程pid，jps经常使用的参数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">-q：仅输出VM标识符，不包括<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">name</span>,<span class="hljs-title">jar</span> <span class="hljs-title">name</span>,<span class="hljs-title">arguments</span> <span class="hljs-title">in</span> <span class="hljs-title">main</span> <span class="hljs-title">method</span> </span><br><span class="hljs-class">-<span class="hljs-title">m</span>：输出<span class="hljs-title">main</span> <span class="hljs-title">method</span>的参数 </span><br><span class="hljs-class">-<span class="hljs-title">l</span>：输出完全的包名，应用主类名，<span class="hljs-title">jar</span>的完全路径名 </span><br><span class="hljs-class">-<span class="hljs-title">v</span>：输出<span class="hljs-title">jvm</span>参数 </span><br></code></pre></td></tr></table></figure><p><strong>jinfo</strong> 可以观察进程运行环境参数，通过jinfo pid可以查看指定进程的运行环境参数.</p><p><strong>jstack</strong> 用于显示jvm中当前所有线程的运行情况和线程当前状态，一般使用的参数为-l，表示长列表，并且打印锁的相关附加信息。jstack的输出中还可以看到每一个线程当前所处的状态以及其当前所占用的锁和等待的锁，还可以检测是否存在死锁。</p><p><strong>jmap</strong> 用来打印内存映射以及查看堆内存细节等，一般情况下使用-heap参数来打印堆内存的概要信息，GC使用的算法以及堆的一些配置等信息。</p><p><strong>jstat</strong> 一般用来观察GC情况，并且进行实时的分析与监控，可以使用的参数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">-<span class="hljs-class"><span class="hljs-keyword">class</span> 显示<span class="hljs-title">ClassLoad</span>的相关信息</span><br><span class="hljs-class">-<span class="hljs-title">compiler</span> 显示<span class="hljs-title">JIT</span>编译的相关信息</span><br><span class="hljs-class">-<span class="hljs-title">gc</span> 显示和<span class="hljs-title">gc</span>相关的堆信息</span><br><span class="hljs-class">-<span class="hljs-title">gccapacity</span> 显示各个代的容量以及使用情况</span><br><span class="hljs-class">-<span class="hljs-title">gcmetacapacity</span> 显示<span class="hljs-title">metaspace</span>的大小</span><br><span class="hljs-class">-<span class="hljs-title">gcnew</span> 显示新生代信息</span><br><span class="hljs-class">-<span class="hljs-title">gcnewcapacity</span> 显示新生代大小和使用情况</span><br><span class="hljs-class">-<span class="hljs-title">gcold</span> 显示老年代和永久代的信息</span><br><span class="hljs-class">-<span class="hljs-title">gcoldcapacity</span> 显示老年代的大小</span><br><span class="hljs-class">-<span class="hljs-title">gcutil</span>　　 显示垃圾收集信息</span><br><span class="hljs-class">-<span class="hljs-title">gccause</span> 显示垃圾回收的相关信息（通-<span class="hljs-title">gcutil</span>）,同时显示最后一次或当前正在发生的垃圾回收的诱因</span><br><span class="hljs-class">-<span class="hljs-title">printcompilation</span> 输出<span class="hljs-title">JIT</span>编译的方法信息</span><br></code></pre></td></tr></table></figure><h4 id="如何排查一个线上的服务异常？"><a href="#如何排查一个线上的服务异常？" class="headerlink" title="如何排查一个线上的服务异常？"></a>如何排查一个线上的服务异常？</h4><ul><li>首先查看当前进程的JVM启动参数，查看内存设置是否存在明显问题。</li><li>查看GC日志，看GC频率和时间是否明显异常。</li><li>查看当前进程的状态信息top -Hp pid，包括线程个数等信息。</li><li>jstack pid查看当前的线程状态，是否存在死锁等关键信息。</li><li>jstat -gcutil pid查看当前进程的GC情况。</li><li>jmap -heap pid查看当前进程的堆信息，包括使用的垃圾收集器等信息。</li><li>用jvisiual工具打开dump二进制文件，分析是什么对象导致了内存泄漏，定位到代码处，进行code review。</li></ul><p>一般情况下，我们在测试环境上线新服务的时候，应该重点关注并且查看当前新服务的内存使用以及回收情况，避免新服务中出现内存异常导致服务崩溃的现象发生。</p><h3 id="JDK8中在内存管理上的变化"><a href="#JDK8中在内存管理上的变化" class="headerlink" title="JDK8中在内存管理上的变化"></a>JDK8中在内存管理上的变化</h3><p>JDK8中出现了<strong>元空间代替了永久代</strong>。元空间和永久代类似，都是对JVM规范中方法区的实现。区别在于元空间并不在虚拟机中，而是使用<strong>本地内存，</strong>默认情况下元空间的大小仅受本地内存限制，也可以通过**-XX：MetaspaceSize指定元空间大小。**</p><h4 id="为什么要使用元空间代替永久代"><a href="#为什么要使用元空间代替永久代" class="headerlink" title="为什么要使用元空间代替永久代"></a>为什么要使用元空间代替永久代</h4><p>类和方法的信息等比较难确定大小，因此对于永久代的大小指定比较困难，指定的太小容易出现永久代溢出的问题。而使用元空间则使用了本地内存，减少了这种情况。</p><h3 id="JAVA中的类加载机制"><a href="#JAVA中的类加载机制" class="headerlink" title="JAVA中的类加载机制"></a>JAVA中的类加载机制</h3><p>Java中的类加载机制指虚拟机<strong>把描述类的数据从 Class 文件加载到内存</strong>，并对数据进行<strong>校验、转换、解析和初始化</strong>，最终形成可以被虚拟机直接使用的 Java 类型。</p><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括了：<strong>加载、验证、准备、解析、初始化、使用、卸载七个阶段</strong>。类加载机制的保持则包括前面五个阶段。</p><ul><li><strong>加载：</strong></li></ul><p>加载是指<strong>将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个java.lang.Class对象，用来封装类在方法区内的数据结构。</strong></p><ul><li><strong>验证：</strong></li></ul><p>验证的作用是确保被加载的类的正确性，包括文件格式验证，元数据验证，字节码验证以及符号引用验证。</p><ul><li><strong>准备：</strong></li></ul><p>准备阶段为类的静态变量分配内存，并将其初始化为默认值。假设一个类变量的定义为public static int val = 3;那么变量val在准备阶段过后的初始值不是3而是0。</p><ul><li><strong>解析：</strong></li></ul><p>解析阶段将类中<strong>符号引用转换为直接引用</strong>。符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。</p><ul><li><strong>初始化：</strong></li></ul><p>初始化阶段<strong>为类的静态变量赋予正确的初始值</strong>，JVM负责对类进行初始化，主要对类变量进行初始化。</p><h4 id="类加载器的分类"><a href="#类加载器的分类" class="headerlink" title="类加载器的分类"></a>类加载器的分类</h4><ul><li><strong>启动类加载器（Bootstrap ClassLoader）：</strong></li></ul><p>启动类加载器负责加载存放在JDK\jre\lib(JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的类。</p><ul><li><strong>扩展类加载器（ExtClassLoader）：</strong></li></ul><p>扩展类加载器负责加载JDK\jre\lib\ext目录中，或者由java.ext.dirs系统变量指定的路径中的所有类库（如javax.*开头的类）。</p><ul><li><strong>应用类加载器（AppClassLoader）：</strong></li></ul><p>应用类加载器负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器。</p><h4 id="类加载器的职责："><a href="#类加载器的职责：" class="headerlink" title="类加载器的职责："></a>类加载器的职责：</h4><ul><li><strong>全盘负责：</strong></li></ul><p>当一个类加载器负责加载某个Class时，该Class所依赖的和引用的其他Class也将由该类加载器负责载入，除非显式使用另外一个类加载器来载入。</p><ul><li><strong>父类委托：</strong></li></ul><p>类加载机制会先让父类加载器试图加载该类，只有在父类加载器无法加载该类时才尝试从自己的类路径中加载该类。</p><p>父类委托机制是为了<strong>防止内存中出现多份同样的字节码，</strong>保证java程序安全稳定运行。</p><ul><li><strong>缓存机制：</strong></li></ul><p>缓存机制将会保证所有加载过的Class都会被缓存，当程序中需要使用某个Class时，先从缓存区寻找该Class，只有缓存区不存在，系统才会读取该类对应的二进制数据，并将其转换成Class对象，存入缓存区。这就是为什么修改了Class后，必须重启JVM，程序的修改才会生效。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java</tag>
      
      <tag>Jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java进阶部分</title>
    <link href="/2021/04/22/Java%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/"/>
    <url>/2021/04/22/Java%E8%BF%9B%E9%98%B6%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="Java进阶"><a href="#Java进阶" class="headerlink" title="Java进阶"></a>Java进阶</h3><p>从Java5.0开始，JDK中提供了<strong>java.util.concurrent（简称JUC ）包</strong>，在此包中增加了并发编程中常用的工具类，用于定义线程的自定义子系统，包括线程池、异步IO 和轻量级任务框架等。</p><span id="more"></span><h4 id="进程和线程的区别：（重点掌握）"><a href="#进程和线程的区别：（重点掌握）" class="headerlink" title="进程和线程的区别：（重点掌握）"></a>进程和线程的区别：（重点掌握）</h4><ul><li>进程是资源分配的基本单位；线程是程序执行的基本单位</li><li>进程是一个“执行中的程序”，是系统进行<strong>资源分配和调度</strong>的一个独立单位</li><li>线程是进程的一个实体，一个进程中一般拥有多个线程。线程之间<strong>共享地址空间</strong>和其它资源（所以通信和同步等操作,线程比进程更加容易）</li><li>线程一般不拥有系统资源，但是也有一些必不可少的资源（使用ThreadLocal存储）</li><li>线程上下文的切换比进程上下文切换要快很多。</li></ul><h5 id="线程上下文切换比进程上下文切换快的原因"><a href="#线程上下文切换比进程上下文切换快的原因" class="headerlink" title="线程上下文切换比进程上下文切换快的原因"></a>线程上下文切换比进程上下文切换快的原因</h5><ul><li><strong>进程切换时</strong>，涉及到当前进程的CPU环境的保存和新被调度运行进程的CPU环境的设置</li><li><strong>线程切换时</strong>，仅需要保存和设置少量的寄存器内容，不涉及存储管理方面的操作</li></ul><h5 id="线程可以拥有自己的资源嘛"><a href="#线程可以拥有自己的资源嘛" class="headerlink" title="线程可以拥有自己的资源嘛"></a>线程可以拥有自己的资源嘛</h5><p>可以的，通过ThreadLocal可以存储线程的特有对象，也就是属于当前线程的资源。</p><h5 id="进程之间常见的通信方式"><a href="#进程之间常见的通信方式" class="headerlink" title="进程之间常见的通信方式"></a>进程之间常见的通信方式</h5><ul><li>通过使用套接字Socket来实现不同机器间的进程通信</li><li>通过映射一段可以被多个进程访问的共享内存来进行通信</li><li>通过写进程和读进程利用管道进行通信</li></ul><h4 id="多线程和单线程的关系"><a href="#多线程和单线程的关系" class="headerlink" title="多线程和单线程的关系"></a>多线程和单线程的关系</h4><ul><li>多线程是指在<strong>一个进程中，并发执行了多个线程</strong>，每个线程都实现了不同的功能</li><li>在单核CPU中，将CPU分为很小的时间片，在每一时刻只能有一个线程在执行，是一种微观上轮流占用CPU的机制。由于<strong>CPU轮询</strong>的速度非常快，所以看起来像是“同时”在执行一样</li><li>多线程会存在<strong>线程上下文切换</strong>，会导致程序执行速度变慢</li><li>多线程不会提高程序的执行速度，反而会降低速度。但是对于用户来说，可以<strong>减少用户的等待响应时间，提高了资源的利用效率</strong></li></ul><p><strong>多线程并发利用了CPU轮询时间片的特点</strong>，在一个线程进入阻塞状态时，可以快速切换到其余线程执行其余操作，这有利于<strong>提高资源的利用率，最大限度的利用系统提供的处理能力</strong>，<strong>有效减少了用户的等待响应时间</strong>。</p><p>但是，多线程并发编程也会带来数据的安全问题，线程之间的竞争也会导致线程死锁和锁死等<strong>活性故障</strong>。线程之间的上下文切换也会带来<strong>额外的开销</strong>等问题。</p><h4 id="线程的状态有哪些？"><a href="#线程的状态有哪些？" class="headerlink" title="线程的状态有哪些？"></a>线程的状态有哪些？</h4><p>线程的状态包括 <strong>新建状态，运行状态，阻塞等待状态和消亡状态。</strong>其中阻塞等待状态又分为<strong>BLOCKED, WAITING和TIMED_WAITING</strong>状态。</p><p>JDK8中对于Thread状态的枚举定义，所有的状态如下所示：</p><ol><li><p>NEW：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421211812.png" alt="图片说明"><br>这是属于一个已经创建的线程，但是还没有调用start方法启动的线程所处的状态。</p></li><li><p>RUNNABLE：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421211901.png" alt="图片说明"><br>该状态包含两种可能。有可能正在运行，或者正在等待CPU资源。总体上就是当我们创建线程并且启动之后，就属于Runnable状态。</p></li><li><p>BLOCKED：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421212003.png" alt="图片说明"><br>阻塞状态，当线程准备进入synchronized同步块或同步方法的时候，需要申请一个监视器锁而进行的等待，会使线程进入BLOCKED状态。</p></li><li><p>WAITING<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421212118.png" alt="图片说明"><br>该状态的出现是因为调用了**Object.wait()或者Thread.join()或者LockSupport.park()**。处于该状态下的线程在等待另一个线程 执行一些其余action来将其唤醒。</p></li><li><p>TIMED_WAITING:<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421212700.png" alt="图片说明"><br>该状态和上一个状态其实是一样的，只不过其等待的时间是明确的。</p></li><li><p>TERMINATED：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421212745.png" alt="图片说明"></p><p>消亡状态比较容易理解，那就是线程执行结束了，run方法执行结束表示线程处于消亡状态了。</p></li></ol><h4 id="多线程编程中常用的函数比较："><a href="#多线程编程中常用的函数比较：" class="headerlink" title="多线程编程中常用的函数比较："></a>多线程编程中常用的函数比较：</h4><p><strong>sleep和wait的区别：</strong></p><ul><li><strong>sleep方法：</strong>是Thread类的静态方法，当前线程将睡眠n毫秒，线程进入阻塞状态。当睡眠时间到了，会解除阻塞，进入可运行状态，等待CPU的到来。睡眠不释放锁（如果有的话）。</li><li><strong>wait方法：</strong>是Object的方法，必须与synchronized关键字一起使用，线程进入阻塞状态，当notify或者notifyall被调用后，会解除阻塞。但是，只有<strong>重新占用互斥锁</strong>之后才会进入可运行状态。睡眠时，会释放互斥锁。</li></ul><p><strong>join 方法：</strong>当前线程调用，则其它线程全部停止，等待当前线程执行完毕，接着执行。</p><p><strong>yield 方法：</strong>该方法使得线程放弃当前分得的 CPU 时间。但是不使线程阻塞，即线程仍处于可执行状态，随时可能再次分得 CPU 时间。</p><h4 id="线程活性障碍有哪些？"><a href="#线程活性障碍有哪些？" class="headerlink" title="线程活性障碍有哪些？"></a>线程活性障碍有哪些？</h4><p>由于资源的稀缺性或者程序自身的问题导致线程<strong>一直处于非Runnable状态</strong>，并且其处理的任务<strong>一直无法完成的现象</strong>被称为是线程活性故障。常见的线程活性故障包括<strong>死锁，锁死，活锁与线程饥饿</strong>。</p><p>每一个线程都有其特定的任务处理逻辑。由于资源的稀缺性或者资源本身的一些特性，导致多个线程需要共享一些排他性资源，比如说处理器，数据库连接等。当出现资源争用的时候，部分线程会进入等待状态。</p><h5 id="线程死锁："><a href="#线程死锁：" class="headerlink" title="线程死锁："></a>线程死锁：</h5><p>死锁是最常见的一种线程活性故障。死锁的起因是多个线程之间相互等待对方而被永远暂停（处于非Runnable）。死锁的产生必须满足如下<strong>四个必要条件：</strong></p><ul><li><strong>资源互斥</strong>：一个资源每次只能被一个线程使用</li><li><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放</li><li><strong>不剥夺条件</strong>：线程已经获得的资源，在未使用完之前，不能被强行剥夺</li><li><strong>循环等待条件</strong>：若干线程之间形成一种头尾相接的循环等待资源关系</li></ul><h5 id="如何避免死锁的发生？"><a href="#如何避免死锁的发生？" class="headerlink" title="如何避免死锁的发生？"></a>如何避免死锁的发生？</h5><ul><li><p><strong>粗锁法：</strong>使用一个粒度粗的锁来消除“请求与保持条件”，缺点是会明显降低程序的并发性能并且会导致资源的浪费。</p></li><li><p><strong>锁排序法：（必须回答出来的点）</strong><br><strong>指定获取锁的顺序</strong>，比如某个线程只有获得A锁和B锁，才能对某资源进行操作，在多线程条件下，如何避免死锁？</p><p>通过指定锁的获取顺序，比如规定，只有获得A锁的线程才有资格获取B锁，按顺序获取锁就可以避免死锁。这通常被认为是解决死锁很好的一种方法。</p><ul><li>使用<strong>显式锁</strong>中的**ReentrantLock.try(long,TimeUnit)**来申请锁</li></ul></li></ul><h5 id="线程锁死"><a href="#线程锁死" class="headerlink" title="线程锁死"></a>线程锁死</h5><p>线程锁死是另一种常见的线程活性故障，与线程死锁不可以混为一谈。</p><p><strong>线程锁死的定义如下：</strong></p><p>线程锁死是指等待线程由于唤醒其所需的条件永远无法成立，或者其他线程无法唤醒这个线程而一直处于非运行状态（线程并未终止）导致其任务一直无法进展。</p><p>线程死锁和线程锁死的外部表现是一致的，即故障线程一直处于非运行状态使得其所执行的任务没有进展。但是锁死的产生条件和线程死锁不一样，即使产生死锁的4个必要条件都没有发生，线程锁死仍然可能已经发生。</p><h5 id="线程锁死的种类："><a href="#线程锁死的种类：" class="headerlink" title="线程锁死的种类："></a>线程锁死的种类：</h5><ul><li><p><strong>信号丢失锁死：</strong><br>信号丢失锁死是因为没有对应的通知线程来将等待线程唤醒，导致等待线程一直处于等待状态。</p><p><strong>典型例子</strong>是等待线程在执行Object.wait( )/Condition.await( )前<strong>没有对保护条件进行判断，而此时保护条件实际上可能已经成立</strong>，此后可能并无其他线程更新相应保护条件涉及的共享变量使其成立并通知等待线程，这就使得等待线程一直处于等待状态，从而使其任务一直无法进展。</p></li><li><p><strong>嵌套监视器锁死：</strong>嵌套监视器锁死是由于嵌套锁导致等待线程永远无法被唤醒的一种故障。</p><p>比如一个线程，只释放了内层锁Y.wait()，但是没有释放外层锁X; 但是通知线程必须先获得外层锁X，才可以通过 Y.notifyAll()来唤醒等待线程，这就导致出现了嵌套等待现象。</p></li></ul><h5 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h5><p>活锁是一种特殊的线程活性故障。当一个线程一直处于运行状态，但是其所执行的任务却没有任何进展称为活锁。比如，一个线程一直在申请其所需要的资源，但是却无法申请成功。</p><h5 id="线程饥饿"><a href="#线程饥饿" class="headerlink" title="线程饥饿"></a>线程饥饿</h5><p>线程饥饿是指线程一直无法获得其所需的资源导致任务一直无法运行的情况。线程调度模式有公平调度和非公平调度两种模式。<strong>在线程的非公平调度模式下</strong>，就可能出现线程饥饿的情况。</p><h5 id="线程活性故障总结"><a href="#线程活性故障总结" class="headerlink" title="线程活性故障总结"></a>线程活性故障总结</h5><ul><li>线程饥饿发生时，如果线程处于可运行状态，也就是其一直在申请资源，那么就会转变为活锁</li><li>只要存在一个或多个线程因为获取不到其所需的资源而无法进展就是线程饥饿，所以线程死锁其实也算是线程饥饿</li></ul><h4 id="原子性，可见性与有序性"><a href="#原子性，可见性与有序性" class="headerlink" title="原子性，可见性与有序性"></a>原子性，可见性与有序性</h4><h5 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h5><p>对于涉及到共享变量访问的操作，若该操作从执行线程以外的任意线程来看是不可分割的，那么该操作就是原子操作，该操作具有原子性。即，其它线程不会“看到”该操作执行了部分的中间结果。</p><h5 id="原子性的实现方式"><a href="#原子性的实现方式" class="headerlink" title="原子性的实现方式"></a>原子性的实现方式</h5><ul><li>利用<strong>锁的排他性</strong>，保证同一时刻只有一个线程在操作一个共享变量</li><li>利用<strong>CAS（Compare And Swap）</strong>保证</li><li>Java<strong>语言规范中</strong>，保证了除long和double型以外的任何变量的写操作都是原子操作</li><li>Java<strong>语言规范</strong>中又规定，volatile关键字修饰的变量可以保证其写操作的原子性</li></ul><h5 id="原子性相关的问题"><a href="#原子性相关的问题" class="headerlink" title="原子性相关的问题"></a>原子性相关的问题</h5><ul><li>原子性针对的是多个线程的共享变量，所以对于局部变量来说不存在共享问题，也就无所谓是否是原子操作</li><li>单线程环境下讨论是否是原子操作没有意义</li><li>volatile关键字仅仅能保证变量写操作的原子性，不保证复合操作，比如说读写操作的原子性</li></ul><h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>可见性是指一个线程对于共享变量的更新，对于后续访问该变量的线程是否可见的问题。</p><p>为了阐述可见性问题，我们先来简单介绍<strong>处理器缓存</strong>的概念。</p><p>现代处理器处理速度远大于主内存的处理速度，所以在主内存和处理器之间加入了寄存器，高速缓存，写缓冲器以及无效化队列等部件来加速内存的读写操作。也就是说，我们的处理器可以和这些部件进行读写操作的交互，这些部件可以称为处理器缓存。</p><p>处理器对内存的读写操作，其实仅仅是与处理器缓存进行了交互。一个处理器的缓存上的内容无法被另外一个处理器读取，所以另外一个处理器必须通过缓存一致性协议来读取的其他处理器缓存中的数据，并且同步到自己的处理器缓存中，这样保证了其余处理器对该变量的更新对于另外处理器是可见的。</p><h5 id="单处理器中，为什么也会出现可见性的问题"><a href="#单处理器中，为什么也会出现可见性的问题" class="headerlink" title="单处理器中，为什么也会出现可见性的问题"></a>单处理器中，为什么也会出现可见性的问题</h5><p>单处理器中，由于是多线程并发编程，所以会存在线程的上下文切换，线程会将对变量的更新当作上下文存储起来，导致其余线程无法看到该变量的更新。所以单处理器下的多线程并发编程也会出现可见性问题的。</p><h5 id="可见性如何保证"><a href="#可见性如何保证" class="headerlink" title="可见性如何保证"></a>可见性如何保证</h5><ul><li>当前处理器需要<strong>刷新处理器缓存</strong>，使得其余处理器对变量所做的更新可以同步到当前的处理器缓存中</li><li>当前处理器对共享变量更新之后，需要<strong>冲刷处理器缓存</strong>，使得该更新可以被写入处理器缓存中</li></ul><h5 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h5><p>有序性是指一个处理器上运行的线程所执行的内存访问操作在另外一个处理器上运行的线程来看是否有序的问题。</p><h5 id="重排序"><a href="#重排序" class="headerlink" title="重排序"></a>重排序</h5><p>为了提高程序执行的性能，Java编译器在其认为不影响程序正确性的前提下，可能会对源代码顺序进行一定的调整，导致程序运行顺序与源代码顺序不一致。</p><p>重排序是对内存读写操作的一种优化，在单线程环境下不会导致程序的正确性问题，但是多线程环境下可能会影响程序的正确性。</p><h5 id="重排序举例"><a href="#重排序举例" class="headerlink" title="重排序举例"></a>重排序举例</h5><p><strong>Instance instance = new Instance()都发生了啥？</strong></p><p><strong>具体步骤如下所示三步：</strong></p><ul><li>在堆内存上分配对象的内存空间</li><li>在堆内存上初始化对象</li><li>设置instance指向刚分配的内存地址</li></ul><p>第二步和第三步可能会发生重排序，导致引用型变量指向了一个不为null但是也不完整的对象。（<strong>在多线程下的单例模式中，我们必须通过volatile来禁止指令重排序</strong>）</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><ul><li><strong>原子性</strong>是一组操作要么完全发生，要么没有发生，其余线程不会看到中间过程的存在。注意，<strong>原子操作+原子操作不一定还是原子操作。</strong></li><li><strong>可见性</strong>是指一个线程对共享变量的更新<strong>对于另外一个线程是否可见</strong>的问题。</li><li><strong>有序性</strong>是指一个线程对共享变量的更新在其余线程看起来是<strong>按照什么顺序执行</strong>的问题。</li><li>可以这么认为，<strong>原子性 + 可见性 -&gt; 有序性</strong></li></ul><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><p><strong>synchronized是Java中的一个关键字，是一个内部锁</strong>。它可以使用在方法上和方法块上，表示同步方法和同步代码块。在多线程环境下，同步方法或者同步代码块在同一时刻只允许有一个线程在执行，其余线程都在等待获取锁，也就是实现了整体并发中的局部串行。</p><h5 id="内部锁底层实现"><a href="#内部锁底层实现" class="headerlink" title="内部锁底层实现"></a>内部锁底层实现</h5><ul><li>进入时，执行<strong>monitorenter</strong>，将计数器+1，释放锁<strong>monitorexit</strong>时，计数器-1</li><li>当一个线程判断到计数器为0时，则当前锁空闲，可以占用；反之，当前线程进入等待状态</li></ul><h5 id="synchronized内部锁对原子性的保证："><a href="#synchronized内部锁对原子性的保证：" class="headerlink" title="synchronized内部锁对原子性的保证："></a>synchronized内部锁对原子性的保证：</h5><p>锁通过互斥来保障原子性，互斥是指一个锁一次只能被一个线程所持有，所以，临界区代码只能被一个线程执行，即保障了原子性。</p><h5 id="synchronized内部锁对可见性的保证："><a href="#synchronized内部锁对可见性的保证：" class="headerlink" title="synchronized内部锁对可见性的保证："></a>synchronized内部锁对可见性的保证：</h5><p>synchronized内部锁通过写线程<strong>冲刷处理器缓存</strong>和读线程<strong>刷新处理器缓存</strong>保证可见性。</p><ul><li>获得锁之后，需要<strong>刷新处理器缓存</strong>，使得前面写线程所做的更新可以同步到本线程。</li><li>释放锁需要<strong>冲刷处理器缓存</strong>，使得当前线程对共享数据的改变可以被推送到下一个线程处理器的高速缓冲中。</li></ul><h5 id="synchronized内部锁对有序性的保证："><a href="#synchronized内部锁对有序性的保证：" class="headerlink" title="synchronized内部锁对有序性的保证："></a>synchronized内部锁对有序性的保证：</h5><p>由于原子性和可见性的保证，使得写线程<strong>在临界区中</strong>所执行的一系列操作在读线程所执行的临界区<strong>看起来像是完全按照源代码顺序执行的</strong>，即保证了有序性。</p><h5 id="synchronized内部锁使用样例"><a href="#synchronized内部锁使用样例" class="headerlink" title="synchronized内部锁使用样例"></a>synchronized内部锁使用样例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> niuke;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SynchronizedTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-keyword">synchronized</span> (SynchronizedTest.class)&#123;<br>            System.out.println(<span class="hljs-string">&quot;这是一个同步方法块&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;这是一个同步方法，因为在方法上使用了synchronized关键字&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="JVM对资源的调度方式"><a href="#JVM对资源的调度方式" class="headerlink" title="JVM对资源的调度方式"></a>JVM对资源的调度方式</h5><p><strong>JVM对资源的调度分为公平调度和非公平调度方式</strong>。</p><p><strong>公平调度方式：</strong></p><p>按照<strong>申请的先后顺序</strong>授予资源的独占权。</p><p><strong>非公平调度方式：</strong></p><p>在该策略中，资源的持有线程释放该资源的时候，等待队列中一个线程会被唤醒，而该线程从被唤醒到其继续执行可能需要一段时间。在该段时间内，<strong>新来的线程（活跃线程）</strong>可以先被授予该资源的独占权。</p><p>如果新来的线程占用该资源的时间不长，那么它完全有可能在被唤醒的线程继续执行前释放相应的资源，从而不影响该被唤醒的线程申请资源。</p><h5 id="公平调度和非公平调度的优缺点分析"><a href="#公平调度和非公平调度的优缺点分析" class="headerlink" title="公平调度和非公平调度的优缺点分析"></a>公平调度和非公平调度的优缺点分析</h5><p><strong>非公平调度策略：</strong></p><ul><li>优点：吞吐率较高，单位时间内可以为更多的申请者调配资源</li><li>缺点：资源申请者申请资源所需的时间偏差可能较大，并可能出现线程饥饿的现象</li></ul><p><strong>公平调度策略：</strong></p><ul><li>优点：线程申请资源所需的时间偏差较小；不会出现线程饥饿的现象；适合在资源的持有线程占用资源的时间相对长或者资源的平均申请时间间隔相对长的情况下，或者对资源申请所需的时间偏差有所要求的情况下使用；</li><li>缺点：吞吐率较小</li></ul><h5 id="JVM对synchronized内部锁的调度："><a href="#JVM对synchronized内部锁的调度：" class="headerlink" title="JVM对synchronized内部锁的调度："></a>JVM对synchronized内部锁的调度：</h5><p>JVM对内部锁的调度是一种<strong>非公平的调度方式</strong>，JVM会给每个内部锁分配一个<strong>入口集（Entry Set）</strong>，用于记录等待获得相应内部锁的线程。当锁被持有的线程释放的时候，该锁的入口集中的任意一个线程将会被唤醒，从而得到再次申请锁的机会。被唤醒的线程等待占用处理器运行时可能还有其他新的活跃线程与该线程抢占这个被释放的锁。</p><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>volatile关键字是一个轻量级的锁，<strong>可以保证可见性和有序性，但是不保证原子性。</strong></p><ul><li>volatile 可以保证<strong>主内存和工作内存直接产生交互</strong>，进行读写操作，保证可见性</li><li>volatile 仅能保证变量<strong>写操作的原子性</strong>，不能保证读写操作的原子性。</li><li>volatile可以<strong>禁止指令重排序</strong>（通过插入内存屏障），典型案例是在单例模式中使用。</li></ul><h5 id="volatile的开销"><a href="#volatile的开销" class="headerlink" title="volatile的开销"></a>volatile的开销</h5><p>volatile不会导致线程上下文切换，但是其读取变量的成本较高，因为其每次都需要从高速缓存或者主内存中读取，无法直接从寄存器中读取变量。</p><h5 id="volatile在什么情况下可以替代锁"><a href="#volatile在什么情况下可以替代锁" class="headerlink" title="volatile在什么情况下可以替代锁"></a>volatile在什么情况下可以替代锁</h5><p>volatile是一个轻量级的锁，适合多个线程<strong>共享一个状态变量</strong>，而锁适合多个线程<strong>共享一组状态变量</strong>。可以<strong>将多个线程共享的一组状态变量合并成一个对象</strong>，用一个volatile变量来引用该对象，从而替代锁。</p><h4 id="ReentrantLock和synchronized的区别"><a href="#ReentrantLock和synchronized的区别" class="headerlink" title="ReentrantLock和synchronized的区别"></a>ReentrantLock和synchronized的区别</h4><p>ReentrantLock<strong>是显示锁</strong>，其提供了一些内部锁不具备的特性，但并不是内部锁的替代品。<strong>显式锁支持公平和非公平的调度方式</strong>，默认采用非公平调度。</p><p>synchronized 内部锁简单，但是不灵活。显示锁支持在一个方法内申请锁，并且在另一个方法里释放锁。<strong>显示锁定义了一个tryLock()方法，尝试去获取锁</strong>，成功返回true，失败并不会导致其执行的线程被暂停而是直接返回false，即可以<strong>避免死锁</strong>。</p><h4 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h4><p>java.util.concurrent.ThreadPoolExecutor类就是一个线程池。客户端调用ThreadPoolExecutor.submit(Runnable task)提交任务，线程池内部维护的工作者线程的数量就是该线程池的线程池大小，有3种形态：</p><ul><li><strong>当前线程池大小</strong>：表示线程池中实际工作者线程的数量</li><li><strong>最大线程池大小（maxinumPoolSize）</strong>：表示线程池中允许存在的工作者线程的数量上限</li><li><strong>核心线程大小（corePoolSize ）</strong>：表示一个不大于最大线程池大小的工作者线程数量上限</li></ul><p><strong>线程池的优势体现如下：</strong></p><ul><li>线程池可以重复利用已创建的线程，一次创建可以执行多次任务，有效降低线程创建和销毁所造成的资源消耗；</li><li>线程池技术使得请求可以快速得到响应，节约了创建线程的时间；</li><li>线程的创建需要占用系统内存，消耗系统资源，使用线程池可以更好的管理线程，做到统一分配、调优和监控线程，提高系统的稳定性。</li></ul><p>创建线程是有开销的，为了重复利用已创建的线程降低线程创建和销毁的消耗，提高资源的利用效率，所以出现了线程池。线程池的参数字段如下所示：</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422111547.png" alt="图片说明"></p><ul><li><strong>corePoolSize：核心线程数</strong></li><li><strong>maximumPoolSize：最大线程数</strong></li><li><strong>keepAliveTime ：线程空闲但是保持不被回收的时间</strong></li><li><strong>unit：时间单位</strong></li><li><strong>workQueue：存储线程的队列</strong></li><li><strong>threadFactory：创建线程的工厂</strong></li><li><strong>handler：拒绝策略</strong></li></ul><h5 id="线程池的排队策略"><a href="#线程池的排队策略" class="headerlink" title="线程池的排队策略"></a>线程池的排队策略</h5><p>当我们向线程池提交任务的时候，需要遵循一定的排队策略，具体策略如下：</p><ul><li>如果运行的线程少于corePoolSize，则Executor始终首选添加新的线程，而不进行排队</li><li>如果运行的线程等于或者多于corePoolSize，则Executor始终首选将请求加入队列，而不是添加新线程</li><li>如果无法将请求加入队列，即队列已经满了，则创建新的线程，除非创建此线程超出maxinumPoolSize，在这种情况下，任务默认将被拒绝。</li></ul><h5 id="常见的线程池类型："><a href="#常见的线程池类型：" class="headerlink" title="常见的线程池类型："></a>常见的线程池类型：</h5><p><strong>newCachedThreadPool( )</strong></p><ul><li>核心线程池大小为0，最大线程池大小不受限，来一个创建一个线程</li><li>适合用来执行大量耗时较短且提交频率较高的任务</li></ul><p><strong>newFixedThreadPool( )</strong></p><ul><li>固定大小的线程池</li><li>当线程池大小达到核心线程池大小，就不会增加也不会减小工作者线程的固定大小的线程池</li></ul><p><strong>newSingleThreadExecutor( )</strong></p><ul><li>便于实现单（多）生产者-消费者模式</li></ul><h5 id="常见的阻塞队列"><a href="#常见的阻塞队列" class="headerlink" title="常见的阻塞队列"></a>常见的阻塞队列</h5><p>前面我们介绍了线程池内部有一个排队策略，任务可能需要在队列中进行排队等候。常见的阻塞队列包括如下的三种，接下来我们一起来看看吧。</p><p><strong>ArrayBlockingQueue:</strong></p><ul><li>内部使用一个<strong>数组</strong>作为其存储空间，数组的存储空间是<strong>预先分配</strong>的</li><li><strong>优点是</strong> put 和 take操作不会增加GC的负担（因为空间是预先分配的）</li><li><strong>缺点是</strong> put 和 take操作使用同一个锁，可能导致锁争用，导致较多的上下文切换。</li><li>ArrayBlockingQueue适合在生产者线程和消费者线程之间的<strong>并发程序较低</strong>的情况下使用。</li></ul><p><strong>LinkedBlockingQueue：</strong></p><ul><li>是一个无界队列（其实队列长度是Integer.MAX_VALUE）</li><li>内部存储空间是一个<strong>链表</strong>，并且链表节点所需的<strong>存储空间是动态分配</strong>的</li><li><strong>优点是</strong> put 和 take 操作使用两个显式锁（putLock和takeLock）</li><li><strong>缺点是</strong>增加了GC的负担，因为空间是动态分配的。</li><li>LinkedBlockingQueue适合在生产者线程和消费者线程之间的并发程序较高的情况下使用。</li></ul><p><strong>SynchronousQueue：</strong></p><ul><li>SynchronousQueue可以被看做一种特殊的有界队列。生产者线程生产一个产品之后，会等待消费者线程来取走这个产品，才会接着生产下一个产品，适合在生产者线程和消费者线程之间的处理能力相差不大的情况下使用。</li></ul><p>我们前边介绍<strong>newCachedThreadPool时候说，这个线程池来一个线程就创建一个，这是因为其内部队列使用了SynchronousQueue，所以不存在排队。</strong></p><h5 id="关于线程池，应该知道的事："><a href="#关于线程池，应该知道的事：" class="headerlink" title="关于线程池，应该知道的事："></a>关于线程池，应该知道的事：</h5><ul><li>使用JDK提供的<strong>快捷方式</strong>创建线程池，比如说newCachedThreadPool会出现一些内存溢出的问题，因为<strong>队列可以被塞入很多任务</strong>。所以，大多数情况下，我们<strong>都应该自定义线程池。</strong></li><li>线程池提供了一些<strong>监控API</strong>，可以很方便的监控当前以及塞进队列的任务数以及当前线程池已经完成的任务数等。</li></ul><h4 id="CountDownLatch和CyclicBarrier"><a href="#CountDownLatch和CyclicBarrier" class="headerlink" title="CountDownLatch和CyclicBarrier"></a>CountDownLatch和CyclicBarrier</h4><p><strong>CountDownLatch</strong>是一个<strong>倒计时协调器</strong>，它可以实现一个或者多个线程等待其余线程完成一组特定的操作之后，继续运行。</p><p><strong>CountDownLatch的内部实现如下：</strong></p><ul><li><strong>CountDownLatch</strong>内部维护一个计数器，CountDownLatch.countDown()每被执行一次都会使计数器值减少1。</li><li><strong>当计数器不为0时</strong>，CountDownLatch.await()方法的调用将会导致执行线程被暂停，这些线程就叫做该CountDownLatch上的等待线程。</li><li>CountDownLatch.countDown()相当于一个通知方法，<strong>当计数器值达到0时</strong>，唤醒所有等待线程。当然对应还有指定等待时间长度的CountDownLatch.await(long , TimeUnit)方法。</li></ul><p><strong>CyclicBarrier</strong>是<strong>一个栅栏</strong>，可以实现多个线程相互等待执行到指定的地点，这时候这些线程会再接着执行，在实际工作中可以用来<strong>模拟高并发请求测试</strong>。</p><p><strong>可以认为是这样的</strong>，当我们爬山的时候，到了一个平坦处，前面队伍会稍作休息，等待后边队伍跟上来，当最后一个爬山伙伴也达到该休息地点时，所有人同时开始从该地点出发，继续爬山。</p><p><strong>CyclicBarrier的内部实现如下：</strong></p><ul><li>使用CyclicBarrier实现等待的线程被称为<strong>参与方（Party）</strong>，参与方只需要执行CyclicBarrier.await（）就可以实现等待，<strong>该栅栏维护了一个显示锁</strong>，可以识别出最后一个参与方，<strong>当最后一个参与方调用await（）方法时</strong>，前面等待的参与方都会被唤醒，并且该最后一个参与方也不会被暂停。</li><li><strong>CyclicBarrier内部维护了一个计数器变量count = 参与方的个数</strong>，调用await方法可以使得count -1。<strong>当判断到是最后一个参与方时</strong>，调用singalAll唤醒所有线程。</li></ul><h4 id="TreadLocal"><a href="#TreadLocal" class="headerlink" title="TreadLocal"></a>TreadLocal</h4><p>使用ThreadLocal维护变量时，其为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。</p><p><strong>ThreadLocal内部实现机制：</strong></p><ul><li>每个线程内部都会维护一个类似HashMap的对象，称为<strong>ThreadLocalMap</strong>，里边会包含若干了<strong>Entry（K-V键值对）</strong>，相应的线程被称为这些Entry的属主线程</li><li><strong>Entry的Key是一个ThreadLocal实例，Value是一个线程特有对象</strong>。Entry的作用是为其属主线程建立起一个ThreadLocal实例与一个线程特有对象之间的对应关系</li><li>Entry对Key的引用是弱引用；Entry对Value的引用是强引用。</li></ul><h4 id="Atmoic"><a href="#Atmoic" class="headerlink" title="Atmoic"></a>Atmoic</h4><h5 id="i-操作是线程安全的吗？"><a href="#i-操作是线程安全的吗？" class="headerlink" title="i++操作是线程安全的吗？"></a>i++操作是线程安全的吗？</h5><p>i++操作并不是线程安全的，它是一个复合操作，包含三个步骤：</p><ul><li><strong>拷贝i的值到临时变量</strong></li><li><strong>临时变量++操作</strong></li><li><strong>拷贝回原始变量i</strong></li></ul><p>这是一个<strong>复合操作，不能保证原子性</strong>，所以这不是线程安全的操作。<strong>那么如何实现原子自增等操作呢？</strong></p><p>这里就用到了JDK在java.util.concurrent.atomic包下的AtomicInteger等原子类了。<strong>AtomicInteger类提供了getAndIncrement和incrementAndGet等原子性的自增自减等操作</strong>。<strong>Atomic等原子类内部使用了CAS来保证原子性。</strong></p><p>接下来，我们来看代码吧，首先是使用变量i的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; <span class="hljs-number">1000000</span>; m++) &#123;<br>                i++;<br>            &#125;<br>        &#125;<br>&#125;;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ThreadTest mt = <span class="hljs-keyword">new</span> ThreadTest();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(mt);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(mt);<br>        t1.start();<br>        t2.start();<br>        <span class="hljs-comment">// 休眠一下，让线程执行完毕。</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        System.out.println(ThreadTest.i);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该程序的输出是不确定的，比如输出1933446，也就是线程不安全，发生了竟态导致计算结果有误。</p><p>当我们使用了<strong>Atomic等原子类</strong>时，会发现每次输出结果都是2000000，符合我们的程序设计要求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> AtomicInteger i = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> m = <span class="hljs-number">0</span>; m &lt; <span class="hljs-number">1000000</span>; m++) &#123;<br>            i.getAndIncrement();<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ThreadTest mt = <span class="hljs-keyword">new</span> ThreadTest();<br><br>        Thread t1 = <span class="hljs-keyword">new</span> Thread(mt);<br>        Thread t2 = <span class="hljs-keyword">new</span> Thread(mt);<br>        t1.start();<br>        t2.start();<br>        <span class="hljs-comment">// 休眠一下，让线程执行完毕。</span><br>        Thread.sleep(<span class="hljs-number">500</span>);<br>        System.out.println(ThreadTest.i.get());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="happened-before原则"><a href="#happened-before原则" class="headerlink" title="happened-before原则"></a>happened-before原则</h4><p>前一个操作的执行结果必须对后一个操作可见。</p><p>这里的happened-before并不是前一个操作必须早于后一个操作，而是前一个操作必须对后一个操作可见，否则不能重排序。</p><p>具体的八个hb原则：</p><ol><li><p>单线程happen-before原则：在同一个线程中，书写在前面的操作happen-before后面的操作。<br>首先是单线程的 HB ，前面的操作产生的结果必须对后面的操作可见。而不是前面的操作必须先于后面的操作执行，比如按照 as-if-serial 语义，没有数据依赖的两条指令是可以进行重排序的。而这种情况对于 HB 原则来说，因为两条指令都没有产生对方需要的结果，而不需要对对方可见，及时执行顺序被调转也是符合 HB 原则的。</p></li><li><p>锁的happen-before原则：同一个锁的unlock操作happen-before此锁的lock操作。<br>个人理解强调的是解锁操作在多线程环境的可见性。一个线程进行了解锁操作，对于晚于该操作的加锁操作必须能够及时感应到锁的状态变化。解锁操作的结果对后面的加锁操作一定是可见的，无论两个是否在一个线程。</p></li><li><p>volatile的happen-before原则： 对一个volatile变量的写操作happen-before对此变量的任意操作。<br>对 volatile 变量的写操作的结果对于发生于其后的任何操作的结果都是可见的。x86 架构下volatile 通过内存屏障和缓存一致性协议实现了变量在多核心之间的一致性。</p></li><li><p>happen-before的传递性原则：  如果A操作 happen-before B操作，B操作happen-before C操作，那么A操作happen-before C操作。<br>HB 可以说是两项操作之间的<strong>偏序关系</strong>，满足偏序关系的各项性质，我们都知道偏序关系中有一条很重要的性质：传递性，所以Happens-Before也满足传递性。这个性质非常重要，通过这个性质可以推导出两个没有直接联系的操作之间存在Happens-Before关系</p></li><li><p>线程启动的happen-before原则：同一个线程的start方法happen-before此线程的其它方法。<br>start 放法与其它方法可能并没有数据依赖关系，但是显而易见的，为了程序的正确性，我们必须做到这一点。start 方法造成的函数副作用必须对其它方法可见。</p></li><li><p>线程中断的happen-before原则：对线程interrupt方法的调用happen-before被中断线程的检测到中断发送的代码。<br>interrupt 方法改变的状态必须对后续执行的检测方法可见。</p></li><li><p>线程终结的happen-before原则：线程中的所有操作都happen-before线程的终止检测。<br>为了安全的关闭线程，线程中的方法造成的函数副作用必须对线程关闭方法可见。</p></li><li><p>对象创建的happen-before原则：一个对象的初始化完成先于他的finalize方法调用。<br>单线程下对象的创建于销毁存在数据依赖，该条原则强调的是多线程情况下对象初始化的结果必须对发生于其后的对象销毁方法可见。</p></li></ol><h4 id="JVM对内部锁有哪些优化"><a href="#JVM对内部锁有哪些优化" class="headerlink" title="JVM对内部锁有哪些优化"></a>JVM对内部锁有哪些优化</h4><p>优化主要包括锁消除（Lock Elision）、锁粗化（Lock Coarsening）、偏向锁（Biased Locking）以及适应性锁（Adaptive Locking）。</p><h5 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h5><p>锁消除（Lock Elision）是JIT编译器对内部锁的具体实现所做的一种优化。</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422145850.png" alt="face/TF2SkMAAKFfj7TSWrrC5QaiDSaCswn6T.png"></p><p>在动态编译同步块的时候，JIT编译器可以借助一种被称为逃逸分析（Escape Analysis）的技术来判断同步块所使用的锁对象是否只能够被一个线程访问而没有被发布到其他线程。如果同步块所使用的锁对象通过这种分析被证实只能够被一个线程访问，那么JIT编译器在编译这个同步块的时候并不生成synchronized所表示的锁的申请与释放对应的机器码，而仅生成原临界区代码对应的机器码，这就造成了被动态编译的字节码就像是不包含monitorenter（申请锁）和monitorexit（释放锁）这两个字节码指令一样，即消除了锁的使用。这种编译器优化就被称为锁消除（Lock Elision），它使得特定情况下我们可以完全消除锁的开销。</p><p>锁消除优化能否被实施还取决于被调用的同步方法（或者带同步块的方法）是否能够被内联。</p><p>因为锁消除是JIT编译器而不是javac所做的一种优化，而一段代码只有在其被执行的频率足够大的情况下才有可能会被JIT编译器优化。也就是说在JIT编译器优化介入之前，只要源代码中使用了内部锁，那么这个锁的开销就会存在。另外，JIT编译器所执行的内联优化、逃逸分析以及锁消除优化本身都是有其开销的。</p><p>在锁消除的作用下，利用ThreadLocal将一个线程安全的对象（比如Random）作为一个线程特有对象来使用，不仅仅可以避免锁的争用，还可以彻底消除这些对象内部所使用的锁的开销。</p><h5 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h5><p>锁粗化（Lock Coarsening/Lock Merging）是JIT编译器对内部锁的具体实现所做的一种优化。</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422150246.png" alt="face/ENSjarckiW474mpxyhEjFNsRAR2XNtm4.png"></p><p>对于相邻的几个同步块，如果这些同步块使用的是同一个锁实例，那么JIT编译器会将这些同步块合并为一个大同步块，从而避免了一个线程反复申请、释放同一个锁所导致的开销。然而，锁粗化可能导致一个线程持续持有一个锁的时间变长，从而使得同步在该锁之上的其他线程在申请锁时的等待时间变长。例如上图中，第1个同步块结束和第2个同步块开始之间的时间间隙中，其他线程本来是有机会获得monitorX的，但是经过锁粗化之后由于临界区的长度变长，这些线程在申请monitorX时所需的等待时间也相应变长了。因此，锁粗化不会被应用到循环体内的相邻同步块。</p><p>相邻的两个同步块之间如果存在其他语句，也不一定就会阻碍JIT编译器执行锁粗化优化，这是因为JIT编译器可能在执行锁粗化优化前将这些语句挪到（即指令重排序）后一个同步块的临界区之中（当然，JIT编译器并不会将临界区内的代码挪到临界区之外）。</p><p>实际上，我们写的代码中可能很少会出现上图中那种连续的同步块。这种同一个锁实例引导的相邻同步块往往是JIT编译器编译之后形成的。</p><p>锁粗化默认是开启的。</p><h5 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h5><p>偏向锁（Biased Locking）是Java虚拟机对锁的实现所做的一种优化。这种优化基于这样的观测结果（Observation）：大多数锁并没有被争用（Contented），并且这些锁在其整个生命周期内至多只会被一个线程持有。然而，Java虚拟机在实现monitorenter字节码（申请锁）和monitorexit字节码（释放锁）时需要借助一个原子操作（CAS操作），这个操作代价相对来说比较昂贵。因此，Java虚拟机会为每个对象维护一个偏好（Bias），即一个对象对应的内部锁第1次被一个线程获得，那么这个线程就会被记录为该对象的偏好线程（Biased Thread）。这个线程后续无论是再次申请该锁还是释放该锁，都无须借助原先（指未实施偏向锁优化前）昂贵的原子操作，从而减少了锁的申请与释放的开销。</p><p>然而，一个锁没有被争用并不代表仅仅只有一个线程访问该锁，当一个对象的偏好线程以外的其他线程申请该对象的内部锁时，Java虚拟机需要收回（Revoke）该对象对原偏好线程的“偏好”并重新设置该对象的偏好线程。这个偏好收回和重新分配过程的代价也是比较昂贵的，因此如果程序运行过程中存在比较多的锁争用的情况，那么这种偏好收回和重新分配的代价便会被放大。有鉴于此，偏向锁优化只适合于存在相当大一部分锁并没有被争用的系统之中。如果系统中存在大量被争用的锁而没有被争用的锁仅占极小的部分，那么我们可以考虑关闭偏向锁优化。</p><p>偏向锁优化默认是开启的。</p><h5 id="适应性锁"><a href="#适应性锁" class="headerlink" title="适应性锁"></a>适应性锁</h5><p>适应性锁（Adaptive Locking，也被称为 Adaptive Spinning ）是JIT编译器对内部锁实现所做的一种优化。</p><p>存在锁争用的情况下，一个线程申请一个锁的时候如果这个锁恰好被其他线程持有，那么这个线程就需要等待该锁被其持有线程释放。实现这种等待的一种保守方法——将这个线程暂停（线程的生命周期状态变为非Runnable状态）。由于暂停线程会导致上下文切换，因此对于一个具体锁实例来说，这种实现策略比较适合于系统中绝大多数线程对该锁的持有时间较长的场景，这样才能够抵消上下文切换的开销。另外一种实现方法就是采用忙等（Busy Wait）。所谓忙等相当于如下代码所示的一个循环体为空的循环语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当锁被其他线程持有时一直循环 </span><br><span class="hljs-keyword">while</span> (lockIsHeldByOtherThread)&#123;&#125;<br></code></pre></td></tr></table></figure><p>可见，忙等是通过反复执行空操作（什么也不做）直到所需的条件成立为止而实现等待的。这种策略的好处是不会导致上下文切换，缺点是比较耗费处理器资源——如果所需的条件在相当长时间内未能成立，那么忙等的循环就会一直被执行。因此，对于一个具体的锁实例来说，忙等策略比较适合于绝大多数线程对该锁的持有时间较短的场景，这样能够避免过多的处理器时间开销。</p><p>事实上，Java虚拟机也不是非要在上述两种实现策略之中择其一 ——它可以综合使用上述两种策略。对于一个具体的锁实例，Java虚拟机会根据其运行过程中收集到的信息来判断这个锁是属于被线程持有时间“较长”的还是“较短”的。对于被线程持有时间“较长”的锁，Java虚拟机会选用暂停等待策略；而对于被线程持有时间“较短”的锁，Java虚拟机会选用忙等等待策略。Java虚拟机也可能先采用忙等等待策略，在忙等失败的情况下再采用暂停等待策略。Java虚拟机的这种优化就被称为适应性锁（Adaptive Locking），这种优化同样也需要JIT编译器介入。</p><p>适应性锁优化可以是以具体的一个锁实例为基础的。也就是说，Java虚拟机可能对一个锁实例采用忙等等待策略，而对另外一个锁实例采用暂停等待策略。</p><h4 id="如何进行无锁化编程"><a href="#如何进行无锁化编程" class="headerlink" title="如何进行无锁化编程"></a>如何进行无锁化编程</h4><h5 id="无锁的特点"><a href="#无锁的特点" class="headerlink" title="无锁的特点"></a>无锁的特点</h5><ol><li>无障碍的；</li><li>保证有一个线程胜出；</li><li>如果临界区的某个线程在每次竞争中都无法胜出那么该线程即将被饿死。</li></ol><h5 id="CAS-Compare-And-Swap-Set-比较交换算法"><a href="#CAS-Compare-And-Swap-Set-比较交换算法" class="headerlink" title="CAS(Compare And Swap/Set)比较交换算法"></a>CAS(Compare And Swap/Set)比较交换算法</h5><p>CAS 操作包含三个操作数 —— 内存位置（V）、预期原值（A）和新值(B)。 如果内存位置的值与预期原值相匹配，那么处理器会自动将该位置值更新为新值 。否则，处理器不做任何操作。无论如何，CAS最后会返回当前V的真实值。CAS操作是抱着乐观的态度进行的(乐观锁)，它总是认为自己可以成功完成操作。当多个线程同时使用CAS操作一个变量时，只有一个会胜出，并成功更新，其余均会失败。失败的线程不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作。</p><p>CAS是一条CPU的原子指令，不会造成所谓的数据不一致问题。</p><h5 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h5><p>sun.misc.Unsafe是JDK内部用的工具类。它通过暴露一些Java意义上说“不安全”的功能给Java层代码，来让JDK能够更多的使用Java代码来实现一些原本是平台相关的、需要使用native语言（例如C或C++）才可以实现的功能。该类不应该在JDK核心类库之外使用。</p><h5 id="Java中的无锁类"><a href="#Java中的无锁类" class="headerlink" title="Java中的无锁类"></a>Java中的无锁类</h5><ul><li>AtomicInteger<br>AtomicInteger和Integer一样，都继承与Number类。当然还有AtomicBoolean，AtomicLong等等，都大同小异。</li><li>AtomicReference<br>AtomicReference是一种模板类，它可以用来封装任意类型的数据。</li><li>AtomicStampedReference<br>CAS操作带来的ABA问题。ABA在一些敏感的场合是不适合的，比如个一个账户充了10块钱，又消费了10元，随后又充值了10元，虽然该账户最余额是10元但不能说该账户没有消费。因为CAS在比操作值得时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，中间变成B，最后又变成A，那么使用CAS进行检查时会发现值没有发生变化，但是实际上是变化了的。解决思路就是添加版本号。 JDK1.5之后，Atomic包提供了一个类AtomicStampedReference来解决ABA问题。这个类的compareAndSet方法先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。其内部实现一个Pair类来封装值和时间戳。<br>这个类的主要思想是加入时间戳来标识每一次改变。当期望值等于当前值，并且期望时间戳等于现在的时间戳时，才写入新值，并且更新新的时间戳。</li></ul><h5 id="CAS的缺点"><a href="#CAS的缺点" class="headerlink" title="CAS的缺点"></a>CAS的缺点</h5><ol><li>CPU开销过大<br>在并发量比较高的时候，如果许多线程都尝试去更新一个变量的值，却又一直比较失败，导致提交失败，产生自旋，循环往复，会对CPU造成很大的压力和开销。</li><li>不能确保代码块的原子性（注意是代码块）<br>CAS机制所确保的是一个变量的原子性操作，而不能保证整个代码块的原子性，比如需要保证3个变量共同进行原子性的更新，就不得不使用synchronized或者lock了。</li><li>ABA问题</li></ol><h5 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h5><p>AQS又称为队列同步器，用来构建锁或其他同步组件的基础框架。 内部通过一个int成员变量state来控制同步状态，当state = 0时，说明没有任何线程占有共享资源的锁； state = 1时，则说明有线程目前正在使用共享变量，其他线程必须加入同步队列进行等待，当然state也可以继续执行+1操作，比如可重入锁。AQS同步器的实现依赖于内部的同步队列(FIFO的双向链表队列)完成对同步状态(state)的管理，当前线程获取锁(同步状态)失败时，AQS会将该线程以及相关等待信息包装成 一个节点(Node)并将其加入同步队列，同时会阻塞当前线程，当同步状态释放时，会将头结点head中的线 程唤醒，让其尝试获取同步状态。简单来说，就是同步状态state和同步队列。ReentrantLock锁就是使用了AQS 来控制同步状态。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础部分</title>
    <link href="/2021/04/22/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/"/>
    <url>/2021/04/22/Java%E5%9F%BA%E7%A1%80%E9%83%A8%E5%88%86/</url>
    
    <content type="html"><![CDATA[<h3 id="JAVA基础"><a href="#JAVA基础" class="headerlink" title="JAVA基础"></a>JAVA基础</h3><h4 id="面向对象的特性"><a href="#面向对象的特性" class="headerlink" title="面向对象的特性"></a>面向对象的特性</h4><ol><li><p>封装：将事物封装成一个类，<strong>减少耦合，隐藏细节</strong>。保留特定的接口与外界联系，当接口内部发生改变时，不会影响外部调用。<br>比如将类的属性私有化，只有<strong>通过公共的get/set方法才能进行访问</strong>，在get/set方法中我们可以对<strong>内部逻辑进行封装处理</strong>，外部的调用方法不必关心我们的处理逻辑。</p></li><li><p>继承：从一个已知的类中<strong>派生出一个新的类</strong>（子类），新的类可以使用已知类（即父类）的行为和属性，并且可以<strong>通过覆盖/重写</strong>来增强已知类的能力。<br>JAVA不支持多继承，并且JAVA的构造函数不可以被继承。<br>构造函数被private修饰的话，其就是不明确的构造函数，该类不可以被其他类继承。<br>JAVA中类的初始化顺序：</p><ol><li>初始化<strong>父类</strong>中的<strong>静态成员变量和静态代码块</strong></li><li>初始化<strong>子类</strong>中的<strong>静态成员变量和静态代码块</strong></li><li>初始化<strong>父类</strong>中的普通成员变量和代码块，再<strong>执行父类的构造方法</strong></li><li>初始化<strong>子类</strong>中的普通成员变量和代码块，再<strong>执行子类的构造方法</strong></li></ol><p>子类的特点：</p><ol><li>子类<strong>拥有</strong>父类非private的属性和方法</li><li>子类可以添加自己的方法和属性，即<strong>对父类进行扩展</strong></li><li>子类可以重新定义父类的方法，即<strong>方法的覆盖/重写</strong></li></ol></li><li><p>多态：多态的本质是一个程序中存在多个同名的不同方法，主要通过三种方式来实现</p><ol><li>通过子类对父类的<strong>覆盖（重写）</strong>来实现</li><li>通过在一个类中对方法的<strong>重载</strong>来实现</li><li>通过将<strong>子类对象作为父类对象</strong>使用来实现</li></ol></li></ol><span id="more"></span><h5 id="覆盖（-Override）"><a href="#覆盖（-Override）" class="headerlink" title="覆盖（@Override）"></a>覆盖（@Override）</h5><p><strong>覆盖也叫重写</strong>，是指<strong>子类和父类</strong>的方法之间的一种关系，比如父类拥有方法A，子类扩展了方法A并添加了丰富的功能。那么我们就说子类覆盖或重写了方法A，也就是说子类中的方法与父类中继承的方法有完全相同的返回值类型、方法名、参数个数及参数类型。</p><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p><strong>重载是指在一个类中（包括父类）存在多个同名的不同方法</strong>，这些方法的<strong>参数个数、顺序及类型不同</strong>均可以构成方法的重载。如果仅仅是修饰符、返回值、抛出异常不同，那么是两个相同的方法。</p><p>如果只有返回值不同，可以构成重载吗？</p><p>不可以。因为我们调用某个方法的时候，不一定关心返回值，此时编译器无法根据方法名和参数确定我们调用的是哪个方法。</p><h5 id="向上转型"><a href="#向上转型" class="headerlink" title="向上转型"></a>向上转型</h5><p>子类对象转为父类，父类可以是接口。</p><p>公式：Father f = new Son();Father是父类或接口，Son是子类。</p><h5 id="向下转型"><a href="#向下转型" class="headerlink" title="向下转型"></a>向下转型</h5><p>父类对象转为子类。公式：Son s = (Son) f；</p><p>向上转型时可以直接转，但是向下转型时必须进行强制类型转换。<strong>该父类对象必须实际指向了一个子类对象才可强制类型向下转型。</strong></p><h4 id="JDK，JRE和JVM的区别和联系有哪些？"><a href="#JDK，JRE和JVM的区别和联系有哪些？" class="headerlink" title="JDK，JRE和JVM的区别和联系有哪些？"></a>JDK，JRE和JVM的区别和联系有哪些？</h4><ul><li><strong>JDK（Java Development Kit）</strong>是一个开发工具包，是Java开发环境的核心组件，并且提供编译、调试和运行一个Java程序所需要的所有工具、可执行文件和二进制文件，是一个平台特定的软件。</li><li><strong>JRE（Java Runtime Environment）</strong>是指Java运行时环境，是JVM的实现，提供了运行Java程序的平台。JRE包含了JVM，但是不包含Java编译器/调试器之类的开发工具</li><li><strong>JVM（Java Virtual Machine）</strong>是指Java虚拟机，当我们运行一个程序时，JVM负责将字节码转换为特定的机器代码，JVM提供了内存管理/垃圾回收和安全机制等</li></ul><p>区别和联系：</p><ul><li>JDK是开发工具包，用来开发Java程序，而JRE是Java的运行时环境</li><li>JDK和JRE中都包含了JVM</li><li>JVM是Java编程的核心，独立于硬件和操作系统，具有平台无关性，而这也是Java程序可以一次编写，多处执行的原因</li></ul><h5 id="Java语言的平台无关性是如何实现的？"><a href="#Java语言的平台无关性是如何实现的？" class="headerlink" title="Java语言的平台无关性是如何实现的？"></a>Java语言的平台无关性是如何实现的？</h5><ul><li>JVM屏蔽了操作系统和底层硬件的差异</li><li>Java面向JVM编程，先编译生成字节码文件，然后交给JVM解释成机器码执行</li><li>通过规定基本数据类型的取值范围和行为，在各个平台上保持一致</li></ul><h5 id="Java语言是编译型还是解释型语言？"><a href="#Java语言是编译型还是解释型语言？" class="headerlink" title="Java语言是编译型还是解释型语言？"></a>Java语言是编译型还是解释型语言？</h5><p>Java的执行经历了编译和解释的过程，是一种<strong>先编译、后解释</strong>执行的语言，不可以单纯归到解释性或编译性语言的类别中。</p><h4 id="抽象类和接口有什么区别？"><a href="#抽象类和接口有什么区别？" class="headerlink" title="抽象类和接口有什么区别？"></a>抽象类和接口有什么区别？</h4><ul><li>抽象类中可以没有抽象方法，也可以抽象方法和非抽象方法共存</li><li>接口中的方法在JDK8之前只能是抽象的，从JDK8版本开始提供了接口中方法的default实现</li><li>抽象类和类一样是单继承的；接口可以实现多个父接口</li><li>抽象类中可以存在普通的成员变量；接口中的变量必须是static final类型的，必须被初始化，接口中只有常量，没有变量</li><li>在Java中，我们通过abstract来定义抽象类，通过interface关键字来定义接口。</li></ul><h5 id="抽象类和接口应该如何选择？分别在什么情况下使用？"><a href="#抽象类和接口应该如何选择？分别在什么情况下使用？" class="headerlink" title="抽象类和接口应该如何选择？分别在什么情况下使用？"></a>抽象类和接口应该如何选择？分别在什么情况下使用？</h5><p>根据抽象类和接口的不同之处，当我们仅仅需要定义一些抽象方法而不需要其余额外的具体方法或者变量的时候，我们可以使用接口。反之，则需要使用抽象类，因为抽象类中可以有非抽象方法和变量。</p><h5 id="JDK8中为什么会出现默认方法呢？"><a href="#JDK8中为什么会出现默认方法呢？" class="headerlink" title="JDK8中为什么会出现默认方法呢？"></a>JDK8中为什么会出现默认方法呢？</h5><p>使用接口，使得我们可以面向抽象编程，但是其中一个缺点就是当接口中有改动的时候，需要修改所有的实现类（因为实现接口必须实现其中的抽象方法）。在JDK8中，为了给已经存在的接口增加新的方法并且<strong>不影响现有的实现</strong>，所以引入了接口中的默认方法实现。</p><p>默认方法允许在不打破现有继承体系的基础上改进接口，解决接口的修改与现有的实现不兼容的问题。在实际开发中，接口的默认方法应该谨慎使用，因为在复杂的继承体系中，默认方法可能引起歧义和编译错误。</p><h4 id="Object类的方法"><a href="#Object类的方法" class="headerlink" title="Object类的方法"></a>Object类的方法</h4><p>（1）clone方法</p><p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</p><p>（2）getClass方法</p><p>final方法，获得运行时类型。</p><p>（3）toString方法</p><p>该方法用得比较多，一般子类都有覆盖。</p><p>（4）finalize方法</p><p>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</p><p>（5）equals方法</p><p>该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p><p>（6）hashCode方法</p><p>该方法用于哈希查找，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p><p>一般必须满足<code>obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()</code>，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p><p>（7）wait方法</p><p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p><p>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p><p>（1）其他线程调用了该对象的notify方法。</p><p>（2）其他线程调用了该对象的notifyAll方法。</p><p>（3）其他线程调用了interrupt中断该线程。</p><p>（4）时间间隔到了。</p><p>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p><p>（8）notify方法</p><p>该方法唤醒在该对象上等待的某个线程。</p><p>（9）notifyAll方法</p><p>该方法唤醒在该对象上等待的所有线程。</p><h4 id="Java中的八种基本数据类型及其取值范围"><a href="#Java中的八种基本数据类型及其取值范围" class="headerlink" title="Java中的八种基本数据类型及其取值范围"></a>Java中的八种基本数据类型及其取值范围</h4><p>Java的8种基本数据类型分别是：<strong>byte，short，int，long，float，double，char及boolean</strong>。boolean类型的取值为true和false两种，其余每一种基本类型都占有一定的字节，并且拥有着最大值和最小值。比如int的取值范围为Integer.MIN_VALUE到Integer.MAX_VALUE。</p><p>每种基本类型所占用的字节数：</p><ul><li>byte：1字节</li><li>short：2字节</li><li>int：4字节</li><li>long：8字节</li><li>float：4字节</li><li>double：8字节</li><li>char：2字节</li><li>boolean：Java规范中没有规定boolean类型所占字节数</li></ul><p>各个类型的取值范围：</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210420160235.png" alt="image-20210420160235367"></p><h4 id="Java中的元注解有哪些？"><a href="#Java中的元注解有哪些？" class="headerlink" title="Java中的元注解有哪些？"></a>Java中的元注解有哪些？</h4><p>Java提供了4个元注解，元注解的作用是负责注解其他注解。</p><ul><li><strong>@Target：</strong></li></ul><p>说明注解所修饰的对象范围，关键源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Target &#123;  <br>    ElementType[] value();  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ElementType</span> </span>&#123;  <br>  TYPE,FIELD,METHOD,PARAMETED,CONSTRUCTOR,LOCAL_VARIABLE,ANNOCATION_TYPE,PACKAGE,TYPE_PARAMETER,TYPE_USE  <br>&#125;  <br><br></code></pre></td></tr></table></figure><p>例如，如下的注解使用@Target标注，表明MyAnn注解只能作用在类/接口和方法上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnn &#123;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>@Retention：（保留策略）</strong></li></ul><p>保留策略定义了该注解被保留的时间长短。关键源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Retention &#123;  <br>    <span class="hljs-function">RetentionPolicy <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;  <br>&#125;  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">RetentionPolicy</span> </span>&#123;  <br>    SOURCE, CLASS, RUNTIME  <br>&#125; <br></code></pre></td></tr></table></figure><p>其中，<strong>SOURCE：</strong>表示在源文件中有效（即源文件保留）；CLASS：表示在class文件中有效（即class保留）；<strong>RUNTIME：</strong>表示在运行时有效（即运行时保留）。例如，**@Retention(RetentionPolicy.RUNTIME)**标注表示该注解在运行时有效。</p><ul><li><strong>@Documented：</strong></li></ul><p>该注解用于描述其他类型的注解应该被作为被标注的程序成员的公共API，因此可以被javadoc此类的工具文档化。Documented是一个标记注解，没有成员。关键源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Documented &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><strong>@Inherited：</strong></li></ul><p>该注解是一个标记注解，@Inherited阐述了某个被标记的类型是被继承的。如果一个使用了@Inherited修饰的注解类型被用于一个class，则这个annotation将被用于该class的子类。关键源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Inherited &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="注解的作用"><a href="#注解的作用" class="headerlink" title="注解的作用"></a>注解的作用</h5><p>代替繁杂的配置文件，简化开发</p><h5 id="如何定义一个注解？"><a href="#如何定义一个注解？" class="headerlink" title="如何定义一个注解？"></a>如何定义一个注解？</h5><p>定义注解类不能使用class、enum以及interface，必须使用@interface。下边是一个简单的注解定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnn&#123;&#125;  <br></code></pre></td></tr></table></figure><h5 id="如何定义注解的属性？"><a href="#如何定义注解的属性？" class="headerlink" title="如何定义注解的属性？"></a>如何定义注解的属性？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAnn &#123;  <br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;  <br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">value1</span><span class="hljs-params">()</span></span>;  <br>&#125;<br><span class="hljs-comment">// 使用注解MyAnn，可以设置属性</span><br><span class="hljs-meta">@MyAnn(value1=100,value=&quot;hello&quot;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> </span>&#123;  <br>&#125; <br></code></pre></td></tr></table></figure><p>定义注解时候的value就是属性，看着是一个方法，当我们称其为属性。当为注解指定属性后，那么在使用注解时就必须要给属性赋值了。</p><h4 id="说说Java中的反射机制？"><a href="#说说Java中的反射机制？" class="headerlink" title="说说Java中的反射机制？"></a>说说Java中的反射机制？</h4><p><strong>反射机制</strong>是指在运行中，对于任意一个类，都能够知道这个类的所有属性和方法。对于任意一个对象，都能够调用它的任意一个方法和属性。即<strong>动态获取信息和动态调用对象方法的功能</strong>称为反射机制。</p><h5 id="反射机制的作用："><a href="#反射机制的作用：" class="headerlink" title="反射机制的作用："></a>反射机制的作用：</h5><ul><li>在运行时判断任意一个对象所属的类</li><li>在运行时构造一个类的对象</li><li>在运行时判断任意一个类所具有的成员变量和方法</li><li>在运行时调用任意一个对象的方法，生成动态代理</li></ul><h5 id="与反射相关的类："><a href="#与反射相关的类：" class="headerlink" title="与反射相关的类："></a>与反射相关的类：</h5><ul><li><strong>Class：表示类</strong>，用于获取类的相关信息</li><li><strong>Field：表示成员变量</strong>，用于获取实例变量和静态变量等</li><li><strong>Method：表示方法</strong>，用于获取类中的方法参数和方法类型等</li><li><strong>Constructor：表示构造器</strong>，用于获取构造器的相关参数和类型等</li></ul><h5 id="例如，获取Class类有三种基本方式："><a href="#例如，获取Class类有三种基本方式：" class="headerlink" title="例如，获取Class类有三种基本方式："></a>例如，获取Class类有三种基本方式：</h5><ol><li><p>通过类名称.class来获取Class类对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c = <span class="hljs-keyword">int</span>.class；<br>Class c = <span class="hljs-keyword">int</span>[ ].class；<br>Class c = String.class<br></code></pre></td></tr></table></figure></li><li><p>通过对象.getClass()方法来获取Class类对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c = obj.getClass( );<br></code></pre></td></tr></table></figure></li><li><p>通过类名称加载类Class.forName()，只要有类名称就可以得到Class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class c = Class.forName(<span class="hljs-string">&quot;cn.ywq.Demo&quot;</span>);<br></code></pre></td></tr></table></figure></li></ol><p>接下来，是一个通过反射方式来创建对象的Demo：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.qhq;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String className = <span class="hljs-string">&quot;com.qhq.User&quot;</span>;<br>        <span class="hljs-comment">// 获取Class对象</span><br>        Class clazz = Class.forName(className);<br>        <span class="hljs-comment">// 创建User对象</span><br>        User user = (User)clazz.newInstance();<br>        <span class="hljs-comment">// 和普通对象一样，可以设置属性值</span><br>        user.setUsername(<span class="hljs-string">&quot;test&quot;</span>);<br>        user.setPassword(<span class="hljs-string">&quot;123&quot;</span>);<br><br>        System.out.println(user);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String username;<br>    <span class="hljs-keyword">private</span> String password;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUsername</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUsername</span><span class="hljs-params">(String username)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.username = username;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPassword</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> password;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPassword</span><span class="hljs-params">(String password)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.password = password;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;User [username=&quot;</span> + username + <span class="hljs-string">&quot;, password=&quot;</span> + password + <span class="hljs-string">&quot;]&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="Java中的Exception和Error有什么区别？"><a href="#Java中的Exception和Error有什么区别？" class="headerlink" title="Java中的Exception和Error有什么区别？"></a>Java中的Exception和Error有什么区别？</h4><ul><li><strong>Exception</strong>是程序正常运行中<strong>预料到可能会出现</strong>的错误，并且应该被捕获并进行相应的处理，是一种<strong>异常</strong>现象</li><li><strong>Error</strong>是正常情况下不应该出现的，<strong>Error会导致JVM处于一种不可恢复的状态</strong>，不需要进行捕获处理</li></ul><h5 id="异常的类型"><a href="#异常的类型" class="headerlink" title="异常的类型"></a>异常的类型</h5><p>Exception又分为<strong>运行时异常</strong>和<strong>编译时异常</strong>。</p><p><strong>编译时异常（受检异常）</strong>表示当前调用的方法体内部抛出了一个异常，所以编译器检测到这段代码在运行时可能会出异常，所以要求我们必须对异常进行相应的处理，可以捕获异常或抛给上层调用方。</p><p><strong>运行时异常（非受检异常）</strong>表示在运行时出现的异常，常见的运行时异常包括：空指针异常，数组越界异常，数字转换异常以及算数异常等。</p><p>异常应该被捕获，我们可以使用try-catch-finally来处理异常，并且使得程序恢复正常。</p><h5 id="捕获异常应该遵循哪些规则呢？"><a href="#捕获异常应该遵循哪些规则呢？" class="headerlink" title="捕获异常应该遵循哪些规则呢？"></a>捕获异常应该遵循哪些规则呢？</h5><ul><li>尽可能捕捉比较详细的异常，并对每个异常进行相应的处理，而不是使用Exception一起捕获。</li><li>当本模块不知道捕获之后该怎么处理异常时，可以将其抛给上层模块，上层模块拥有更多的业务逻辑，可以进行更好地处理。</li><li>捕获异常后至少应该又日志记录，方便之后的排查。</li><li>不要使用一个很大的try-catch包住整段代码，不利于问题的排查。</li></ul><h5 id="NoClassDefFoundError和ClassNotFoundException有什么区别？"><a href="#NoClassDefFoundError和ClassNotFoundException有什么区别？" class="headerlink" title="NoClassDefFoundError和ClassNotFoundException有什么区别？"></a>NoClassDefFoundError和ClassNotFoundException有什么区别？</h5><p>前者是一个错误，如果JVM或ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候缺找不到类的定义。但是要<strong>查找的类在编译时是存在的，运行的时候却找不到了</strong>。出现这种情况，一<strong>般是由于打包的时候漏掉了部分类或Jar包被篡改已经损坏。</strong></p><p>后者是一个异常，当我们使用例如Class.forName方法来动态加载该类的时候，传入了一个类名，但是其并没有在类路径中被找到的时候，就会导致该异常。<strong>出现这种情况，一般都是类名字传入有误导致的。</strong></p><h4 id="JIT编译器有了解么？"><a href="#JIT编译器有了解么？" class="headerlink" title="JIT编译器有了解么？"></a>JIT编译器有了解么？</h4><p>Java是一种先编译，后解释执行的语言。</p><p>JIT编译器全名为<strong>Just in Time Compile</strong>也就即时编译器，把经常运行的代码<strong>作为“热点代码”编译成与本地平台相关的机器码</strong>，并进行各种层次的优化。JIT编译器除了具有缓存的功能外，还会对代码做各种优化，包括<strong>逃逸分析</strong>、锁消除、锁膨胀、方法内联、空值检查消除、类型检查消除以及公共子表达式消除等。</p><h5 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h5><p>逃逸分析的基本行为就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方，称为<strong>方法逃逸</strong>。JIT编译器的优化包括如下：</p><ul><li><strong>同步省略</strong>：也就是锁消除，当JIT编译器判断不会产生并发问题，那么会将同步锁synchronized去掉。</li><li><strong>标量替换</strong></li></ul><p>标量和聚合量：</p><ul><li><strong>标量（Scalar）</strong>是指一个无法再分解成更小的数据的数据。Java中的原始数据类型就是标量。</li><li><strong>聚合量（Aggregate）</strong>是还可以分解的数据。Java中的对象就是聚合量，因为他可以分解成其他聚合量和标量。</li></ul><p>在JIT阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过JIT优化，就会把这个对象拆解成若干个其中包含的若干个成员变量来代替。这个过程就是标量替换。标量替换的好处就是对象可以不在堆内存进行分配，为栈上分配提供了良好的基础。</p><h5 id="逃逸分析的缺点？"><a href="#逃逸分析的缺点？" class="headerlink" title="逃逸分析的缺点？"></a>逃逸分析的缺点？</h5><p>目前技术尚不成熟，分析过程耗时长，如果没有一个对象是不逃逸的，那么就得不偿失了。</p><h4 id="Java中的值传递和引用传递"><a href="#Java中的值传递和引用传递" class="headerlink" title="Java中的值传递和引用传递"></a>Java中的值传递和引用传递</h4><ul><li><strong>值传递</strong>，意味着传递了对象的一个副本，即使副本被改变，也不会影响源对象。</li><li><strong>引用传递</strong>，意味着传递的并不是实际的对象，而是对象的引用。因此外部对引用对象的改变会反映到所有对象上。</li></ul><h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><p>值传递的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        <span class="hljs-keyword">int</span> x=<span class="hljs-number">0</span>;<br>        change(x);<br>        System.out.println(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        i=<span class="hljs-number">7</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>毫无疑问，上边的代码会输出0。因为如果参数是基本数据类型，那么是属于值传递的范畴，传递的其实是源对象的一个copy副本，不会影响源对象的值。</p><p>下面是一个引用传递的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        StringBuffer x = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        change(x);<br>        System.out.println(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change</span><span class="hljs-params">(StringBuffer i)</span> </span>&#123;<br>        i.append(<span class="hljs-string">&quot; world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行程序后会发现，<strong>输出为Hello world！</strong>下面是执行过程中的内存变化。</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210420194126.png" alt="图片说明"></p><p>从图中可以看出<strong>x和i指向了同样的内存地址</strong>，那么i.append操作将直接修改内存地址里边的值，所以当方法结束，<strong>局部变量i消失</strong>，先前变量x所指向的内存值发生了变化，<strong>所以输出为Hello world！</strong></p><p>接下来，将change方法修改为如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        StringBuffer x = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;Hello&quot;</span>);<br>        change2(x);<br>        System.out.println(x);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">change2</span><span class="hljs-params">(StringBuffer i)</span> </span>&#123;<br>        i = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;hi&quot;</span>);<br>        i.append(<span class="hljs-string">&quot; world!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上边的代码将会输出Hello，画图分析其内存变化：</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210420194443.png" alt="图片说明"></p><p>由图中我们可以看出来，<strong>在函数change2中将引用变量i重新指向了堆内存中另一块区域</strong>，下边都是对另一块区域进行修改，<strong>所以输出是Hello</strong>。</p><p>最后，将代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span>  </span>&#123;<br>        StringBuffer sb = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;Hello &quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;Before change, sb = &quot;</span> + sb);<br>        changeData(sb);<br>        System.out.println(<span class="hljs-string">&quot;After change, sb = &quot;</span> + sb);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">changeData</span><span class="hljs-params">(StringBuffer strBuf)</span> </span>&#123;<br>        StringBuffer sb2 = <span class="hljs-keyword">new</span> StringBuffer(<span class="hljs-string">&quot;Hi，I am &quot;</span>);<br>        strBuf = sb2;<br>        sb2.append(<span class="hljs-string">&quot;World!&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>两次输出是相同的</p><h4 id="String、StringBuffer和StringBuilder的区别"><a href="#String、StringBuffer和StringBuilder的区别" class="headerlink" title="String、StringBuffer和StringBuilder的区别"></a>String、StringBuffer和StringBuilder的区别</h4><p><strong>String：</strong>字符串常量</p><p><strong>StringBuffer：</strong>字符串变量（线程安全）</p><p><strong>StringBuilder：</strong>字符串变量（线程不安全）</p><p>String类是用final修饰的，引用内存中的值不可变。引用数据量一大就不效率。StringBuffer和StringBuilder都是用于频繁修改的字符串的，前者是线程安全的，后者是线程不安全的。</p><p>如果少量的字符串操作采用String，如果单线程下操作大量字符串采用StringBuilder ，如果多线程下操作大量字符串采用StringBuffer 。StringBuilder的性能比StringBuffer的效率高。</p><p>String的+号拼接操作是由StringBuilder实现的，但是直接使用String进行大量修改的话，每次都会指向新的对象，也就是会产生垃圾对象，垃圾对象多了会使JVM启动垃圾回收机制，消耗大量时间。</p><h4 id="Java中泛型的理解"><a href="#Java中泛型的理解" class="headerlink" title="Java中泛型的理解"></a>Java中泛型的理解</h4><p><strong>泛型的本质使参数化类型</strong>，泛型就是将所操作的数据类型作为参数的一种语法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Play</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-function">T <span class="hljs-title">play</span><span class="hljs-params">()</span></span>&#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中<code>T</code>就是作为 类型参数在Play被实例化的时候所传递来的参数，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Play&lt;Integeter&gt; playInteger = <span class="hljs-keyword">new</span> Play&lt;&gt;();<br></code></pre></td></tr></table></figure><p>这里<code>T</code>就会被实例化<code>Integer</code></p><h5 id="泛型的实现"><a href="#泛型的实现" class="headerlink" title="泛型的实现"></a>泛型的实现</h5><p>泛型的实现过程叫作<strong>擦除</strong>，泛型是为了将具体的类型作为参数传递给方法、类、接口，擦除是在代码运行过程中将具体的类型都擦除。泛型会在编译的时候做类型检查，编译成字节码时会自动进行强制类型转换，减少了Java 1.5之前手动强转可能存在的错误。</p><h5 id="泛型的作用"><a href="#泛型的作用" class="headerlink" title="泛型的作用"></a>泛型的作用</h5><ul><li>使用泛型能写出更加灵活通用的代码</li><li>泛型将代码安全性检查提前到编译期</li><li>泛型能够省去类型强制转换<br>Java 1.5之前，Java容器都是通过将类型向上转型为<code>Object</code>类型来实现的，因此在从容器中取出来的时候需要手动的强制转换。<br>加入泛型后，由于编译器知道了具体的类型，因此编译期会自动进行强制转换，使得代码更加优雅。</li></ul><h4 id="Java序列化与反序列化的过程"><a href="#Java序列化与反序列化的过程" class="headerlink" title="Java序列化与反序列化的过程"></a>Java序列化与反序列化的过程</h4><p><strong>Java序列化</strong>是指把Java对象转换为字节序列的过程；而<strong>Java反序列化</strong>是指把字节序列恢复为Java对象的过程。</p><h5 id="进行序列化和反序列化的好处"><a href="#进行序列化和反序列化的好处" class="headerlink" title="进行序列化和反序列化的好处"></a>进行序列化和反序列化的好处</h5><ol><li>实现了数据的持久化，通过序列化可以把数据永久地保存到硬盘中（通常存放在文件里）</li><li>采用序列化实现远程通信，即在网络上传送对象的字节序列</li></ol><h5 id="如何实现Java序列化与反序列化"><a href="#如何实现Java序列化与反序列化" class="headerlink" title="如何实现Java序列化与反序列化"></a>如何实现Java序列化与反序列化</h5><ol><li><p>JDK类库中序列化API<br><strong>java.io.ObjectOutputStream：表示对象输出流</strong></p><p>它的writeObject(Object obj)方法可以对参数指定的obj对象进行序列化，把得到的字节序列写到一个目标输出流中。</p><p><strong>java.io.ObjectInputStream：表示对象输入流</strong></p><p>它的readObject()方法从源输入流中读取字节序列，再把它们反序列化成为一个对象，并将其返回。</p></li><li><p>实现序列化的要求<br>只有实现了Serializable或Externalizable接口的类的对象才能被序列化，否则抛出异常。</p></li><li><p>实现Java对象序列化与反序列化的方法</p><p>假定一个Student类，它的对象需要序列化，可以有如下三种方法：</p><ol><li><p>若Student类仅仅实现了Serializable接口，则可以按照以下方式进行序列化和反序列化</p><p>ObjectOutputStream采用默认的序列化方式，对Student对象的非transient的实例变量进行序列化。</p><p>ObjcetInputStream采用默认的反序列化方式，对对Student对象的非transient的实例变量进行反序列化。</p></li><li><p>若Student类仅仅实现了Serializable接口，并且还定义了readObject(ObjectInputStream in)和writeObject(ObjectOutputSteam out)，则采用以下方式进行序列化与反序列化。</p><p>ObjectOutputStream调用Student对象的writeObject(ObjectOutputStream out)的方法进行序列化。</p><p>ObjectInputStream会调用Student对象的readObject(ObjectInputStream in)的方法进行反序列化。</p></li><li><p>若Student类实现了Externalnalizable接口，且Student类必须实现readExternal(ObjectInput in)和writeExternal(ObjectOutput out)方法，则按照以下方式进行序列化与反序列化。</p><p>ObjectOutputStream调用Student对象的writeExternal(ObjectOutput out))的方法进行序列化。</p><p>ObjectInputStream会调用Student对象的readExternal(ObjectInput in)的方法进行反序列化。</p></li></ol></li></ol><h4 id="equals和hashCode方法的关系"><a href="#equals和hashCode方法的关系" class="headerlink" title="equals和hashCode方法的关系"></a>equals和hashCode方法的关系</h4><p>二者同是Object类中的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object obj)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><ul><li>equals()：用来判断两个对象是否相同，在Object类中是通过判断对象间的内存地址来决定是否相同</li><li>hashCode()：获取哈希码，也成为散列码，返回一个int整数，这个哈希码的作用是确定该对象在哈希表中的索引位置。</li></ul><h5 id="两者的关系"><a href="#两者的关系" class="headerlink" title="两者的关系"></a>两者的关系</h5><ul><li>hashCode主要用于提升查询效率从而提高哈希表性能，来确定在散列结构中对象的存储地址</li><li>重写equals()必须重写hashCode()</li><li>哈希存储结构中，添加元素重复性校验的标准就是先检查hashCode值，后判断equals()</li><li>两个对象equals()相等，hashCode()必定相等</li><li>两个对象hashCode()不等，equals()必定也不等</li><li>两个对象hashCode()相等，对象不一定相等，需要通过equals()进一步判断</li></ul><h4 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h4><p>Java和C++都是面向对象语言。</p><p>C++为了兼容C多多少少影响了其面向对象的彻底性，而Java是完全的面向对象语言。</p><ol><li>指针<br>Java中编写程序不能使用指针，减少了指针操作失误所带来的问题，Java虚拟机内部还是使用了指针</li><li>多重继承<br>C++支持多重继承，允许许多父类派生一个类。尽管多重继承功能很强，但使用复杂，而且会引起许多麻烦，编译程序实现它也很不容易。Java不支持多重继承，但允许一个类继承多个接口（extends+implement），实现了C++多重继承的功能，又避免了C++中的多重继承实现方式带来的诸多不便。</li><li>数据类型及类<br>Java是完全面向对象的语言，所有函数和变量必须是类的一部分。除了基本数据类型之外，其余的都作为类对象，包括数组。C++允许将函数和变量定义为全局的。此外，Java中取消了C/C++中的结构和联合，消除了不必要的麻烦。</li><li>自动内存管理<br>Java程序中所有的对象都是用new操作符建立在内存堆栈上，这个操作符类似于C++的new操作符。Java自动进行无用内存回收操作，不需要程序员进行删除。而C++中必须由程序员释放内存资源，增加了程序设计者的负担。Java中当一个对象不被再用到时，无用内存回收器将给它加上标签以示删除。JAVA里无用内存回收程序是以线程方式在后台运行的，利用空闲时间工作。</li><li>操作符重载<br>Java不支持操作符重载，是为了保持Java语言尽可能简单。</li><li>预处理功能<br>Java不支持预处理功能。C/C++在编译过程中都有一个预编译阶段，即预处理器。预处理器为开发人员提供了方便，但增加了编译的复杂性。Java虚拟机没有预处理器，但它提供的引入语句(import)与C++预处理器的功能类似。</li><li>Java不支持缺省函数参数，而C++支持</li><li>Java不提供goto语句</li><li>C和C++中有时出现数据类型的隐含转换，Java不支持自动强制类型转换，必须由程序显示进行强制类型转换。</li></ol><h4 id="静态与非静态的区别"><a href="#静态与非静态的区别" class="headerlink" title="静态与非静态的区别"></a>静态与非静态的区别</h4><p>静态所修饰的在类中是唯一的，static可以修饰成员变量、方法、代码块。静态成员变量和静态方法属于类本身，在类装载的时候被装载到内存中，不自动进行销毁，会一直存在内存中，直到JVM关闭。</p><p>首先，两者本质上的区别是：静态方法是在类中使用static修饰的方法，在类定义的时候已经被装载和分配。而非静态方法是不加static关键字的方法，在类定义时没有占用内存，只有在类被实例化成对象时，对象调用该方法才被分配内存。非静态变量和方法属于实例对象，实例化之后才会分配内存，必须通过类的实例来引用，当实例对象被JVM回收之后，也跟着消失。</p><p>其次，静态方法中只能调用静态成员或者静态方法，不能调用非静态方法或者非静态成员，而非静态方法既可以调用静态成员或者方法又可以调用其他的非静态成员或者方法。</p><h4 id="Java中equals方法和-的区别"><a href="#Java中equals方法和-的区别" class="headerlink" title="Java中equals方法和==的区别"></a>Java中equals方法和==的区别</h4><p>==：</p><p>==是直接比较的两个对象的堆内存地址，如果相等，则说明这两个引用实际是指向同一个对象地址的。</p><p>对于基本数据类型（byte，short，char，int，float，double，long，boolean）来说，他们是作为常量在方法区中的常量池里面以HashSet策略存储起来的，对于这样的字符串 “123” 也是相同的道理，在常量池中，一个常量只会对应一个地址，因此不管是再多的 123,”123” 这样的数据都只会存储一个地址，所以所有他们的引用都是指向的同一块地址，因此基本数据类型和String常量是可以直接通过==来直接比较的。</p><p>另外，对于基本数据的包装类型（Byte, Short, Character，Integer，Float, Double，Long,  Boolean）除了Float和Double之外，其他的六种都是实现了常量池的，因此对于这些数据类型而言，一般我们也可以直接通过==来判断是否相等。</p><p>Integer 在常量池中的存储范围为[-128,127]，127在这范围内，因此是直接存储于常量池的，而128不在这范围内，所以会在堆内存中创建一个新的对象来保存这个值，所以m，n分别指向了两个不同的对象地址，故而导致了不相等。</p><h4 id="三大集合接口的引出"><a href="#三大集合接口的引出" class="headerlink" title="三大集合接口的引出"></a>三大集合接口的引出</h4><p>Java中的集合，从上层接口看分为了两类，<strong>Map和Collection</strong>。Collection接口的子接口又包括了Set和List接口。这样<strong>常见的Map，Set和List三大集合</strong>接口就出来了。接口类图如下所示：</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210420230156.png" alt="图片说明"></p><p>Map是和Collection并列的集合上层接口，没有继承关系；List和Set是Collection的子接口。</p><h4 id="Java中常见的集合"><a href="#Java中常见的集合" class="headerlink" title="Java中常见的集合"></a>Java中常见的集合</h4><ul><li><strong>Map接口和Collection接口是所有集合框架的父接口</strong></li><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要有：<strong>HashMap</strong>、TreeMap、Hashtable、LinkedHashMap、<strong>ConcurrentHashMap</strong>以及Properties等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：<strong>ArrayList</strong>、<strong>LinkedList</strong>、Stack以及Vector等</li></ul><h4 id="HashMap和Hashtable的区别有哪些？"><a href="#HashMap和Hashtable的区别有哪些？" class="headerlink" title="HashMap和Hashtable的区别有哪些？"></a>HashMap和Hashtable的区别有哪些？</h4><ul><li>HashMap没有考虑同步，是线程不安全的；Hashtable使用了synchronized关键字，是线程安全的；</li><li>HashMap允许null作为Key，Hashtable不允许null作为Key，Hashtable的Value也不能为null</li></ul><h5 id="HashMap线程不安全的例子"><a href="#HashMap线程不安全的例子" class="headerlink" title="HashMap线程不安全的例子"></a>HashMap线程不安全的例子</h5><ul><li>HashMap线程不安全主要是在<strong>多线程环境下进行扩容</strong>可能会出现<strong>HashMap死循环</strong></li><li>HashMap的线程不安全问题还体现在数据丢失上，也就是多个线程在进行put操作的时候，存在数据的覆盖问题</li><li>Hashtable线程安全是由于其内部实现在put和remove等方法上使用了synchronized进行了同步，所以对<strong>单个方法的使用是线程安全</strong>的。但是对多个方法进行<strong>复合操作时，线程安全性无法保证。</strong>比如一个线程在进行get然后put更新的操作，就是两个复合操作，在这两个操作之间，可能别的线程已经对这个key做了改动，接下来的put操作可能不符合预期。</li></ul><h5 id="Java集合中的快速失败（fast-fail）机制"><a href="#Java集合中的快速失败（fast-fail）机制" class="headerlink" title="Java集合中的快速失败（fast-fail）机制"></a>Java集合中的快速失败（fast-fail）机制</h5><p>快速失败是Java集合的一种<strong>错误检测机制</strong>，当多个线程对集合进行结构上的改变的操作时，<strong>有可能</strong>会产生fail-fast。</p><p>例如：</p><p>假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2<strong>修改了集合A的结构</strong>（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就<strong>可能</strong>会抛出<strong>ConcurrentModificationException</strong>，从而产生fast-fail快速失败。</p><h5 id="快速失败机制的底层是怎么实现的？"><a href="#快速失败机制的底层是怎么实现的？" class="headerlink" title="快速失败机制的底层是怎么实现的？"></a>快速失败机制的底层是怎么实现的？</h5><p>迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个modCount变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。当迭代器使用hasNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedModCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p><h5 id="ConcurrentModificationException"><a href="#ConcurrentModificationException" class="headerlink" title="ConcurrentModificationException"></a>ConcurrentModificationException</h5><p>当检测到一个并发的修改，就可能会抛出该异常，一些迭代器的实现会抛出该异常，以便可以快速失败。但是不能为了便捷依赖该异常，而应该把它当作程序的政策手段。</p><h4 id="HashMap的底层实现结构"><a href="#HashMap的底层实现结构" class="headerlink" title="HashMap的底层实现结构"></a>HashMap的底层实现结构</h4><p>JDK8之前，底层实现数据结构为<strong>数组+链表</strong>的形式，JDK8及以后的版本使用了<strong>数组+链表+红黑树</strong>实现，结局了链表太长导致查询速度变慢的问题。大概结构如下图：</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421092228.png" alt="图片说明"></p><h5 id="HashMap的初始容量、加载因子、扩容增量是多少？"><a href="#HashMap的初始容量、加载因子、扩容增量是多少？" class="headerlink" title="HashMap的初始容量、加载因子、扩容增量是多少？"></a>HashMap的初始容量、加载因子、扩容增量是多少？</h5><p>HashMap的初始容量16，加载因子为0.75，扩容增量为原容量的1倍。如果HashMap的容量为16，一次扩容后容量为32。HashMap扩容是指元素个数<strong>（包括数组和链表+红黑树中）</strong>超过了16 * 0.75 = 12之后开始扩容。</p><h5 id="初始容量为什么是16？"><a href="#初始容量为什么是16？" class="headerlink" title="初始容量为什么是16？"></a>初始容量为什么是16？</h5><p>如果太小，4或者8，<strong>扩容比较频繁</strong>；如果太大，32或者64甚至更大，<strong>占用内存空间</strong></p><h5 id="默认加载因子为什么是0-75？"><a href="#默认加载因子为什么是0-75？" class="headerlink" title="默认加载因子为什么是0.75？"></a>默认加载因子为什么是0.75？</h5><p>低了的话，比如0.5，那么哈希表填充到一半就开始扩容，这样会导致<strong>扩容频繁</strong>，并且空间利用率比较低。如果太大，比如1，就说明哈希表等到完全填满才开始扩容，这样虽然空间高度利用了，但是<strong>哈希冲突</strong>的机会也变大了，会提高查找成本。</p><h5 id="链表什么时候会变成红黑树，红黑树什么时候还原为链表"><a href="#链表什么时候会变成红黑树，红黑树什么时候还原为链表" class="headerlink" title="链表什么时候会变成红黑树，红黑树什么时候还原为链表"></a>链表什么时候会变成红黑树，红黑树什么时候还原为链表</h5><p>但添加元素时，如果桶中链表元素超过8，会自动转为红黑树。</p><p>当元素个数少于6时，树将还原为链表，设置为6的目的是为了防止链表和树之间频繁地切换。</p><h5 id="哈希表的最小树形化容量"><a href="#哈希表的最小树形化容量" class="headerlink" title="哈希表的最小树形化容量"></a>哈希表的最小树形化容量</h5><p>最小树形化容量为64，但哈希表中的容量大于这个值时，表中的桶才能进行树形化</p><p>否则桶内元素太多时扩容，而不是树形化</p><h5 id="HashMap的长度为什么是2的幂次方？"><a href="#HashMap的长度为什么是2的幂次方？" class="headerlink" title="HashMap的长度为什么是2的幂次方？"></a>HashMap的长度为什么是2的幂次方？</h5><ul><li>我们将一个键值对插入HashMap时，通过<strong>将Key的hash值与length-1进行&amp;运算</strong>，实现了当前Key的定位，2的幂次方可以减少冲突（碰撞）的次数，提高HashMap查询效率</li><li><strong>如果length为2的幂次方</strong>，则length-1转化为二进制必定是11111……的形式，在与hash值的二进制与操作效率会非常快，而且空间不浪费</li><li><strong>如果length不是2的幂次方</strong>，比如length为15，则length-1为14，对应的二进制为1110，再与hash值进行与操作，最后一位都为0，而0001，0011，0101，0111，1001，1011，1101这几个位置永远都不能存放元素了，空间浪费相当大，更糟的是在这种情况中，数组可以使用的位置比数组长度小了很多，这意味着进一步增加了碰撞的几率，减慢了查询的效率！这要就会造成空间的浪费。</li></ul><h5 id="HashMap存储和获取原理"><a href="#HashMap存储和获取原理" class="headerlink" title="HashMap存储和获取原理"></a>HashMap存储和获取原理</h5><p>当<strong>调用put()方法传递键和值来存储时</strong>，先对键调用hashCode()方法，返回的hashCode用于<strong>找到bucket位置来储存Entry对象</strong>，也就是找到了该元素应该被存储的<strong>桶中（数组）</strong>。当两个键的hashCode值相同时，bucket位置发生了冲突，也就是<strong>发生了Hash冲突</strong>，这个时候，会在每一个bucket后边接上一个链表（JDK8及以后的版本中还会加上红黑树）来解决，将新存储的键值对放在表头（也就是bucket中）。</p><p>当调用get方法<strong>获取存储的值</strong>时，首先根据键的hashCode找到对应的bucket，然后根据equals方法来在链表和红黑树中找到对应的值。</p><h5 id="HashMap的扩容步骤"><a href="#HashMap的扩容步骤" class="headerlink" title="HashMap的扩容步骤"></a>HashMap的扩容步骤</h5><p>HashMap里默认的负载因子大小为0.75.也就是说，当Map中的元素个数<strong>（包括数组，链表和红黑树）</strong>超过了16*0.75=12之后开始扩容。在准备树形化时发现数组长度太小也会进行扩容。将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作<strong>rehashing</strong>，因为它调用hash方法找到新的bucket位置。</p><p>当然了，上述的扩容机制时比较低效的。所以在1.8版本时做了扩容效率方面的优化。因为2的N次幂扩容，所以一个元素要么在原位置不动，要么移动到当前位置+2的N次幂（也就是oldIndex+oldCap的未知）。</p><p>如何实现？</p><ul><li>通过新增的bit位置上是0还是1来判断。</li><li>0是原位置，1则是oldIndex+oldCap的位置</li></ul><p>该设计既省去了重新计算hash值的时间，同时，由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀地把之前冲突的节点分散到新的bucket中了。</p><h5 id="解决Hash冲突的方法有哪些？"><a href="#解决Hash冲突的方法有哪些？" class="headerlink" title="解决Hash冲突的方法有哪些？"></a>解决Hash冲突的方法有哪些？</h5><ul><li>拉链法<strong>（HashMap使用的方法）</strong></li><li>线性探测再散列法</li><li>二次探测再散列法</li><li>伪随机探测再散列法</li></ul><h5 id="哪些类适合作为HashMap的键？"><a href="#哪些类适合作为HashMap的键？" class="headerlink" title="哪些类适合作为HashMap的键？"></a>哪些类适合作为HashMap的键？</h5><p>String和Integer这样的包装类很适合作为HashMap的键，因为他们是final类型的类，而且<strong>重写了equals和hashCode方法</strong>，避免了键值对改写，有效提高HashMap性能。</p><p>为了计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashCode的话，那么就不能从HashMap中找到想要的对象。</p><h4 id="ConcurrentHashMap和Hashtable的区别"><a href="#ConcurrentHashMap和Hashtable的区别" class="headerlink" title="ConcurrentHashMap和Hashtable的区别"></a>ConcurrentHashMap和Hashtable的区别</h4><p>ConcurrentHashMap结合了HashMap和Hashtable的优势。HashMap没有考虑同步，Hashtable考虑了同步问题，但是Hashtable在每次同步执行时都要锁住整个结构。</p><p>ConcurrentHashMap锁的方式是稍微粒度的，ConcurrentHashMap将hash表分为16个桶（默认值），诸如get、put、remove等常用操作只锁上当前需要用到的桶。</p><h5 id="ConcurrentHashMap的具体实现方式（分段锁）1-7及以前"><a href="#ConcurrentHashMap的具体实现方式（分段锁）1-7及以前" class="headerlink" title="ConcurrentHashMap的具体实现方式（分段锁）1.7及以前"></a>ConcurrentHashMap的具体实现方式（分段锁）1.7及以前</h5><ul><li>该类包括两个<strong>静态内部类MapEntry和Segment</strong>,前者用来封装映射表的键值对，后者用来充当锁的角色。</li><li><strong>Segment</strong>是一种<strong>可重入的锁ReentrantLock</strong>，每个Segment守护一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得对应的Segment锁。</li></ul><p>在实际开发中，<strong>单线程环境下可以使用HashMap，多线程环境下可以使用ConcurrentHashMap</strong>。</p><h4 id="集合的类图"><a href="#集合的类图" class="headerlink" title="集合的类图"></a>集合的类图</h4><ul><li>HashMap的类图结构<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421160909.png" alt="图片说明"></li><li>ConcurrentHashMap的类图结构：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421160938.png" alt="图片说明"></li><li>Hashtable的类图结构：<br><img src="https://uploadfiles.nowcoder.com/images/20191026/5459305_1572062499403_8266E4BFEDA1BD42D8F9794EB4EA0A13" alt="图片说明"></li></ul><h4 id="TreeMap的特性"><a href="#TreeMap的特性" class="headerlink" title="TreeMap的特性"></a>TreeMap的特性</h4><p>TreeMap底层使用<strong>红黑树</strong>实现，TreeMap中存储的键值对<strong>按照键来排序</strong>。</p><ul><li><p>如果Key存入的时字符串等类型，那么会按照字典默认顺序排序</p></li><li><p>如果传入的是自定义引用类型，比如说User，那么该对象必须实现Comparable接口，并且覆盖其compareTo方法；或者在创建TreeMap的时候，我们必须指定使用多个比较器。如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 方式一：定义该类的时候，就指定比较规则</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Object o)</span> </span>&#123;<br>        <span class="hljs-comment">// 在这里边定义其比较规则</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-comment">// 方式二：创建TreeMap的时候，可以指定比较规则</span><br>    <span class="hljs-keyword">new</span> TreeMap&lt;User, Integer&gt;(<span class="hljs-keyword">new</span> Comparator&lt;User&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(User o1, User o2)</span> </span>&#123;<br>            <span class="hljs-comment">// 在这里边定义其比较规则</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h5 id="Comparable和Comparator比较"><a href="#Comparable和Comparator比较" class="headerlink" title="Comparable和Comparator比较"></a>Comparable和Comparator比较</h5><p><strong>Comparable接口的后缀是able，表示可以的意思。</strong>也就是说一个类如果实现了这个接口，那么这个<strong>类就是可以比较的</strong>。类似的还有cloneable接口表示可以克隆的。而<strong>Comparator则是一个比较器</strong>，是创建TreeMap的时候传入，用来指定比较规则。</p><ul><li>Comparable实现比较简单，但是当需要重新定义比较规则的时候，<strong>必须修改源代码</strong>，即修改User类里边的compareTo方法</li><li>Comparator接口不需要修改源代码，只需要在创建TreeMap的时候<strong>重新传入一个具有指定规则的比较器</strong>即可。</li></ul><h4 id="ArrayList和LinkedList有哪些区别？"><a href="#ArrayList和LinkedList有哪些区别？" class="headerlink" title="ArrayList和LinkedList有哪些区别？"></a>ArrayList和LinkedList有哪些区别？</h4><ul><li>ArrayList底层使用了<strong>动态数组</strong>实现，实质上是一个动态数组</li><li>LinkedList底层使用了<strong>双向链表</strong>实现，可当作堆栈、队列、双端队列使用</li><li>ArrayList在<strong>随机存取</strong>方面效率高于LinkedList</li><li>LinkedList在节点的<strong>增删方面</strong>效率高于ArrayList</li><li>ArrayList必须预留一定的空间，当空间不足的时候，会进行扩容操作</li><li>LinkedList的开销是必须存储节点的信息以及节点的指针信息</li></ul><p>还有一个集合<strong>Vector</strong>，它<strong>是线程安全的ArrayList</strong>，但是已经被废弃，不推荐使用了。多线程环境下，我们可以使用CopyOnWriteArrayList替代ArrayList来保证线程安全。</p><h5 id="ArrayList的容量和扩容容量等"><a href="#ArrayList的容量和扩容容量等" class="headerlink" title="ArrayList的容量和扩容容量等"></a>ArrayList的容量和扩容容量等</h5><p>ArrayList默认的容量是10，默认最大容量是Interger.MAX_VALUE-8。</p><p>扩容核心源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">grow</span><span class="hljs-params">(<span class="hljs-keyword">int</span> minCapacity)</span> </span>&#123;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">int</span> oldCapacity = elementData.length;<br>        <span class="hljs-keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (newCapacity - minCapacity &lt; <span class="hljs-number">0</span>)<br>            newCapacity = minCapacity;<br>        <span class="hljs-keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)<br>            newCapacity = hugeCapacity(minCapacity);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>        elementData = Arrays.copyOf(elementData, newCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><p>其中参数是插入数据化所需的最小容量。</p><p>首先扩容是扩展原来的一半。若还不够直接扩展到所需容量。</p><p>若新的容量大于默认最大容量，则设置为Integer.MAX_VALUE。</p><h4 id="HashSet和TreeSet有哪些区别？"><a href="#HashSet和TreeSet有哪些区别？" class="headerlink" title="HashSet和TreeSet有哪些区别？"></a>HashSet和TreeSet有哪些区别？</h4><ul><li><strong>HashSet底层使用了Hash表实现。</strong></li></ul><p>保证元素唯一性的原理：判断元素的hashCode值是否相同。如果相同，还会继续判断元素的equals方法，是否为true</p><ul><li><strong>TreeSet底层使用了红黑树来实现。</strong></li></ul><p>保证元素唯一性是通过Comparable或者Comparator接口实现</p><p>其实，HashSet的底层实现还是HashMap，只不过其只使用了其中的Key，具体如下所示：</p><ul><li>HashSet的add方法底层使用HashMap的put方法将key = e，value=PRESENT构建成key-value键值对，当此e存在于HashMap的key中，则value将会覆盖原有value，但是key保持不变，所以如果将一个已经存在的e元素添加中HashSet中，新添加的元素是不会保存到HashMap中，所以这就满足了HashSet中元素不会重复的特性。</li><li>HashSet的contains方法使用HashMap得containsKey方法实现</li></ul><h4 id="LinkedHashMap和LinkedHashSet"><a href="#LinkedHashMap和LinkedHashSet" class="headerlink" title="LinkedHashMap和LinkedHashSet"></a>LinkedHashMap和LinkedHashSet</h4><p><strong>LinkedHashMap可以记录下元素的插入顺序和访问顺序</strong>，具体实现如下：</p><ul><li>LinkedHashMap内部的Entry继承于HashMap.Node，这两个类都实现了Map.Entry&lt;K,V&gt;</li><li>LinkedHashMap的Entry不光有value，next，还有before和after属性，这样通过一个双向链表，<strong>保证了各个元素的插入顺序</strong></li><li>通过构造方法public LinkedHashMap(int initialCapacity,float loadFactor,boolean accessOrder)， <strong>accessOrder传入true可以实现LRU缓存算法（访问顺序）</strong></li><li><strong>LinkedHashSet 底层使用LinkedHashMap实现</strong>，两者的关系类似与HashMap和HashSet的关系，大家可以自行类比。</li></ul><h5 id="什么是LRU算法？LinkedHashMap如何实现LRU算法？"><a href="#什么是LRU算法？LinkedHashMap如何实现LRU算法？" class="headerlink" title="什么是LRU算法？LinkedHashMap如何实现LRU算法？"></a>什么是LRU算法？LinkedHashMap如何实现LRU算法？</h5><p><strong>LRU（Least recently used，最近最少使用）算法</strong>根据数据的历史访问记录来进行淘汰数据，其核心思想是“如果数据最近被访问过，那么将来被访问的几率也更高”。</p><p>由于LinkedHashMap可以记录下Map中元素的访问顺序，所以可以轻易的实现LRU算法。只需要<strong>将构造方法的accessOrder传入true，并且重写removeEldestEntry方法</strong>即可。具体实现参考如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">import</span> java.util.LinkedHashMap;<br><span class="hljs-keyword">import</span> java.util.Map;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUTest</span> &#123;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> size = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> LinkedHashMap&lt;String, String&gt;(size, <span class="hljs-number">0.75f</span>, <span class="hljs-literal">true</span>) &#123;<br>            @Override<br>            <span class="hljs-keyword">protected</span> boolean <span class="hljs-built_in">removeEldestEntry</span>(Map.Entry&lt;String, String&gt; eldest) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-built_in">size</span>() &gt; size;<br>            &#125;<br>        &#125;;<br>        map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>);<br>        map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;2&quot;</span>);<br>        map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>);<br>        map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>);<br>        map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(map.<span class="hljs-built_in">toString</span>());<br><br>        map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(map.<span class="hljs-built_in">toString</span>());<br>        map.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;3&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(map.<span class="hljs-built_in">toString</span>());<br>        map.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(map.<span class="hljs-built_in">toString</span>());<br>        map.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;5&quot;</span>);<br>        System.out.<span class="hljs-built_in">println</span>(map.<span class="hljs-built_in">toString</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>每次put后元素会放入最后边，每次访问后，被访问到的元素放到最后边，如果满了再插入的话，就会丢弃最前边的元素，新的插入最后边。</p><h4 id="List和Set的区别"><a href="#List和Set的区别" class="headerlink" title="List和Set的区别"></a>List和Set的区别</h4><ul><li>List是有序的并且元素是<strong>可以重复</strong>的</li><li>Set是无序（LinkedHashSet除外）的，并且元素是<strong>不可以重复</strong>的<br>（此处的有序和无序是指<strong>放入顺序和取出顺序</strong>是否保持一致）</li></ul><h4 id="Iterator和ListIterator的区别"><a href="#Iterator和ListIterator的区别" class="headerlink" title="Iterator和ListIterator的区别"></a>Iterator和ListIterator的区别</h4><ul><li>Iterator可以遍历list和set集合；ListIterator只能用来遍历list集合</li><li>Iterator只能前向遍历集合；ListIterator可以前向和后向遍历集合</li><li>ListIterator其实就是实现了前者，并且增加了一些新的功能。</li></ul><p>Iterator其实就是一个迭代器，在遍历集合的时候需要使用。Demo实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list =  <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>list.add(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>list.add(<span class="hljs-string">&quot;lisi&quot;</span>);<br>list.add(<span class="hljs-string">&quot;yangwenqiang&quot;</span>);<br><span class="hljs-comment">// 创建迭代器实现遍历集合</span><br>Iterator&lt;String&gt; iterator = list.iterator();<br><span class="hljs-keyword">while</span>(iterator.hasNext())&#123;<br>    System.out.println(iterator.next());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="数组和集合List之间的转换："><a href="#数组和集合List之间的转换：" class="headerlink" title="数组和集合List之间的转换："></a>数组和集合List之间的转换：</h4><p>数组和集合List的转换在我们的日常开发中是很常见的一种操作，主要通过<strong>Arrays.asList以及List.toArray方法</strong>来搞定。这里给出Demo演示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> niuke;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConverTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// list集合转换成数组</span><br>        ArrayList&lt;String&gt; list =  <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;lisi&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;yangwenqiang&quot;</span>);<br>        Object[] arr = list.toArray();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>            System.out.println(arr[i]);<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;---------------&quot;</span>);<br>        <span class="hljs-comment">// 数组转换为list集合</span><br>        String[] arr2 = &#123;<span class="hljs-string">&quot;niuke&quot;</span>, <span class="hljs-string">&quot;alibaba&quot;</span>&#125;;<br>        List&lt;String&gt; asList = Arrays.asList(arr2);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; asList.size(); i++) &#123;<br>            System.out.println(asList.get(i));<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="数组转为集合List："><a href="#数组转为集合List：" class="headerlink" title="数组转为集合List："></a>数组转为集合List：</h5><p>通过Arrays.asList方法搞定，转换之后不可以使用add/remove等修改集合的相关方法，因为该方法返回的<strong>其实是一个Arrays的内部私有的一个类ArrayList</strong>，该类继承于Abstractlist，并没有实现这些操作方法，调用将会直接抛出UnsupportOperationException异常。这种转换体现的是一种<strong>适配器模式</strong>，只是转换接口，本质上还是一个数组。</p><h5 id="集合转换为数组："><a href="#集合转换为数组：" class="headerlink" title="集合转换为数组："></a>集合转换为数组：</h5><p>List.toArray方法搞定了集合转换成数组，这里<strong>最好传入一个类型一样的数组</strong>，大小就是list.size()。因为如果入参分配的数组空间不够大时，toArray方法内部将重新分配内存空间，并返回新数组地址；如果数组元素个数大于实际所需，下标为list.size()及其之后的数组元素将被置为null，其它数组元素保持原值。所以，建议该方法入参数组的大小与集合元素个数保持一致。注意，需要传入包装类型数组，而不是基本类型数组。</p><p>若是<strong>直接使用toArray无参方法</strong>，此方法返回值只能是Object[ ]类，若强转其它类型数组将出现<strong>ClassCastException</strong>错误。</p><p>实例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list =  <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;zhangsan&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;lisi&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;yangwenqiang&quot;</span>);<br>        String[] str = <span class="hljs-keyword">new</span> String[<span class="hljs-number">3</span>];<br>        list.toArray(str);<br>        <span class="hljs-keyword">for</span> (String s : str) &#123;<br>            System.out.println(s);<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="Collection和Collections有什么关系"><a href="#Collection和Collections有什么关系" class="headerlink" title="Collection和Collections有什么关系"></a>Collection和Collections有什么关系</h4><p>Collection是一个顶层集合接口，其子接口包括List和Set；而Collections是一个集合工具类，可以操作集合，比如说排序，二分查找，拷贝集合，寻找最大最小值等。 总而言之：带s的大都是工具类。</p><p>Collection是一个集合的顶层接口，Collections是进行集合操作的工具类。</p><p>Array是数组这个对象的类，Arrays是进行数组操作的工具类。</p><p>Executor是线程池的接口，Executors是进行线程池相关的操作的工具类。</p><h4 id="集合类图"><a href="#集合类图" class="headerlink" title="集合类图"></a>集合类图</h4><ul><li>TreeMap的类图结构：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421213044.png" alt="图片说明"></li><li>LinkedHashMap的类图结构：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421213119.png" alt="图片说明"></li><li>ArrayList的类图结构：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421213158.png" alt="图片说明"></li><li>LinkedList的类图结构：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421213407.png" alt="图片说明"></li><li>Vector的类图结构：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421213433.png" alt="图片说明"></li><li>HashSet的类图结构<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421213457.png" alt="图片说明"></li><li>TreeSet的类图结构：<br><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210421213532.png" alt="图片说明"></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络相关知识</title>
    <link href="/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <url>/2021/04/22/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h1><h2 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h2><h3 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h3><ol><li>处理时延</li><li>排队时延</li><li>传输时延</li><li>传播时延</li></ol><span id="more"></span><h2 id="分层体系结构"><a href="#分层体系结构" class="headerlink" title="分层体系结构"></a>分层体系结构</h2><h3 id="因特网协议栈"><a href="#因特网协议栈" class="headerlink" title="因特网协议栈"></a>因特网协议栈</h3><ol><li>应用层<br>包含网络应用程序及<strong>HTTP、SMTP、FTP</strong>等应用层协议<br>信息分组为<strong>报文</strong></li><li>运输层<br>在应用程序端点之间传送应用层报文<br>包括<strong>TCP和UDP</strong>运输协议<br>分组为<strong>报文段</strong></li><li>网络层<br>负责将网络层分组——<strong>数据报</strong>从一台主机移动到另一台主机<br>包括网际协议<strong>IP</strong>以及路由选择协议</li><li>链路层<br>传输网络层下传的数据<br>分组为<strong>帧</strong></li><li>物理层<br>运输帧中的一个个<strong>比特</strong></li></ol><h3 id="OSI模型-开放系统互连模型"><a href="#OSI模型-开放系统互连模型" class="headerlink" title="OSI模型(开放系统互连模型)"></a>OSI模型(开放系统互连模型)</h3><p>包括以上五层，并在应用层和运输层之间添加了表示层和会话层</p><ol><li>表示层：使通信的应用程序能够交换数据的含义<br>包括<strong>数据压缩</strong>、<strong>数据加密</strong>和<strong>数据描述</strong></li><li>会话层：提供数据交换的定界和同步功能，包括建立检查点和恢复方案的方法</li></ol><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h4 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h4><ol><li>客户-服务器体系结构(CS结构)<br>客户相互之间不直接通信<br>服务器具有固定的、周知的IP地址<br>服务器总是打开的<br>主机分为客户和服务器</li><li>P2P(对等)体系结构<br>主机称为对等方<br>对等方为用户所有<br>应用程序在间断连接的主机对之间使用直接通信<br>高度非集中式结构，面临安全性、性能和可靠性等挑战 </li></ol><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>在两个不同端系统上的进程，通过跨越计算机网络交换<strong>报文</strong>而相互通信。</p><ol><li>客户和服务器进程<br>发起通信的进程被标识为<strong>客户</strong>，在会话开始时等待联系的进程是<strong>服务器</strong></li><li>进程与计算机网络之间的接口<br>进程通过**套接字(Socket)**与网络通信<br>套接字是同一台主机应用层和运输层之间的接口</li><li>进程寻址<br>采用<strong>IP地址</strong>+<strong>端口号</strong></li></ol><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><p>Web的应用层协议是超文本传输协议(HyperText Transfer Protocol, HTTP)，它是Web的核心。</p><p>Web页面(也叫文档)由对象组成。一个对象只是一个文件，且可以通过URL地址进行寻址。</p><p>多数Web页面含有一个HTML基本文件以及几个引用对象。</p><h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><p>HTTP定义了Web客户向Web服务器请求Web页面的方式，以及服务器向客户传送Web页面的方式。</p><p>HTTP使用TCP作为它的支撑运输协议。</p><p>HTTP是<strong>无状态协议</strong>，不保存用户的任何信息。</p><p>HTTP默认使用持续连接，也支持非持续连接。</p><h4 id="采用非持续连接的HTTP"><a href="#采用非持续连接的HTTP" class="headerlink" title="采用非持续连接的HTTP"></a>采用非持续连接的HTTP</h4><p>每个TCP连接在服务器发送一个对象后关闭，即该连接并不为其他的对象而持续下来。</p><p>每个TCP连接只传输一个请求报文和一个响应报文。</p><p>在默认方式下，大部分浏览器打开5~10个并行的TCP连接。用户可以配置浏览器来控制量级的并行度。</p><p>假定Web页面有一个HTML基本文件和10个JPEG图形，并且这11个对象位于同一台服务器上。假设该HTML文件的地址为:<code>http://www.example.com/some/index.html</code>。</p><ol><li>HTTP客户进程在端口号80发起一个到服务器<code>www.example.com</code>的TCP连接。在客户和服务器上分别有一个套接字与该连接相关联。(该过程涉及一次“三次握手”过程，并且第三次握手与下一步中的请求报文相结合)。</li><li>HTTP客户经由它的套接字向该服务器发送一个HTTP请求报文。请求报文中包含了路径名<code>/some/index.html</code>。</li><li>HTTP服务器进程经它的套接字接收该请求报文，从存储器(RAM或磁盘)中检索出对象<code>www.example.com/some/index.html</code>，在一个HTTP响应报文中封装对象，并通过其套接字向客户发送响应报文。</li><li>HTTP服务器进程通知TCP断开该TCP连接。(直到TCP确认客户完整地接收到响应报文为止，它才会实际中断连接。)</li><li>HTTP客户端接收响应报文，TCP连接关闭。该报文指出封装的对象是一个HTML文件，客户从响应报文中提取出该文件，检查该HTML文件，得到对10个JPEG图形的引用。</li><li>对每个引用的JPEG对象重复前四个步骤。</li></ol><p>缺点：</p><ol><li>必须为每一个请求的对象建立和维护一个全新的连接。对于每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量，为Web服务器带来了严重的负担。</li><li>每一个对象都要经受两倍RTT的交付时延。</li></ol><h4 id="采用持续连接的HTTP"><a href="#采用持续连接的HTTP" class="headerlink" title="采用持续连接的HTTP"></a>采用持续连接的HTTP</h4><p>服务器在发送响应后保持该TCP连接打开，后续的请求和响应报文可以通过相同的连接进行传送。</p><p>一般来说，如果一个连接经过一段时间间隔(可配置的时间间隔)仍未被使用，HTTP服务器就关闭该连接。</p><h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><p>下面是一个典型的HTTP请求报文</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-keyword">GET</span> <span class="hljs-string">/somedir/page.html</span> <span class="hljs-meta">HTTP/1.1</span><br><span class="hljs-attribute">Host</span><span class="hljs-punctuation">: </span>www.someschool.edu //指明了对象所在的主机<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close //指明不使用持续连接<br><span class="hljs-attribute">User-agent</span><span class="hljs-punctuation">: </span>Mozilia/5.0 //指名向服务器发送请求的浏览器的类型<br><span class="hljs-attribute">Accept-language</span><span class="hljs-punctuation">: </span>fr //表示用户想要得到的语言版本<br></code></pre></td></tr></table></figure><p>第一行为请求行，包括三个字段：方法字段、URL字段和HTTP版本字段。</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210413165620.png" alt="6D912A7180EBEAC28FE14650C189B3EB"></p><p>上面是一个HTTP请求报文的通用格式</p><p>在首部行之后还有一个“实体体”，使用GET方法时实体体为空，使用POST方法时才使用该实体体。</p><h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><p>下面是一条典型的HTTP响应报文，该响应报文是对刚刚讨论的例子中的请求报文的响应。</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs http"><span class="hljs-meta">HTTP/1.1</span> <span class="hljs-number">200</span> OK<br><span class="hljs-attribute">Connection</span><span class="hljs-punctuation">: </span>close //告诉客户，发送完报文后将关闭该TCP连接<br><span class="hljs-attribute">Date</span><span class="hljs-punctuation">: </span>Tue, 18 Aug 2015 15:44:04 GMT //服务器产生并发送该响应报文的日期和时间<br><span class="hljs-attribute">Server</span><span class="hljs-punctuation">: </span>Apache/2.2.3 (CentOS) //指名服务器的类型<br><span class="hljs-attribute">Last-Modified</span><span class="hljs-punctuation">: </span>Tue, 18 Aug 2015 15:11:03 GMT //对象创建或最后修改的日期和时间<br><span class="hljs-attribute">Content-Length</span><span class="hljs-punctuation">: </span>6821 //指示了被发送对象中的字节数<br><span class="hljs-attribute">Content-Type</span><span class="hljs-punctuation">: </span>text/html //指名实体体中的对象类型<br><br><span class="haskell">(<span class="hljs-class"><span class="hljs-keyword">data</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">data</span> <span class="hljs-keyword">data</span> ...)</span></span><br></code></pre></td></tr></table></figure><p>包含一个初始状态行，包括协议版本字段、状态码和相应状态信息</p><p>6个首部行</p><p>然后是实体体</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210413174044.png" alt="9EA6171716E8F8273B15D1951160A44C"></p><p>上图是一个HTTP响应报文的通用格式</p><p>常见的状态码和相关的短语：</p><ul><li>200 OK：请求成功，信息在返回的响应报文中</li><li>301 Moved Permanently：请求的对象已经被永久转移了，新的URL定义在响应报文的Location：首部行中。客户软件将自动获取新的URL。</li><li>400 Bad Request：一个通用的差错代码，指示该请求不能被服务器理解。</li><li>404 Not Found：被请求的文档不在服务器上</li><li>505 HTTP Version Not Supported：服务器不支持请求报文使用的HTTP协议版本</li></ul><h4 id="用户与服务器的交互：Cookie"><a href="#用户与服务器的交互：Cookie" class="headerlink" title="用户与服务器的交互：Cookie"></a>用户与服务器的交互：Cookie</h4><p>HTTP使用cookie来对用户进行追踪。</p><p>Cookie用四个组件;</p><ol><li>在HTTP响应报文中的一个cookie首部行</li><li>在HTTP请求报文中的一个cookie首部行</li><li>在用户端系统中保留有一个cookie文件，并由用户的浏览器进行管理</li><li>位于Web站点的一个后端数据库</li></ol><p>用户首次请求网站时，服务器会产生一个唯一识别码，并以此为索引在它的后端数据库中产生一个表项。接下来服务器用一个包含Set-cookie：首部的HTTP响应报文对用户的浏览器进行响应。其中Set-cookie首部含有该识别码。</p><p>用户的浏览器收到该HTTP响应报文后，会看到Set-cookie首部。浏览器会在它管理的特定cookie文件中添加一行，该行包括服务器的主机名和在Set-cookie首部中的识别码。</p><p>当用户再次范围网站时，浏览器会查询该cookie文件并提取出该网站的识别码，并放到HTTP请求报文中包括识别码的cookie首部行中。</p><p>服务器就可以根据该识别码跟踪用户在站点的活动。</p><h3 id="HTTP与SMTP的对比"><a href="#HTTP与SMTP的对比" class="headerlink" title="HTTP与SMTP的对比"></a>HTTP与SMTP的对比</h3><p>相同之处：</p><ol><li>都是从一台主机向另一台主机发送文件</li><li>持续的HTTP和SMTP都使用持续连接</li></ol><p>区别：</p><ol><li>HTTP主要是一个<strong>拉协议</strong>，用户从服务器拉取信息。TCP连接是由想接受文件的机器发起的。<br>SMTP主要是一个<strong>推协议</strong>，发送邮件服务器把文件推向接收邮件服务器。TCP连接由要发送文件的机器发起。</li><li>SMTP要求每个报文（包括他们的体）采用7比特ASCII码格式。<br>HTTP不受这种限制。</li><li>HTTP把每个对象封装到它自己的HTTP响应报文中。<br>SMTP则把所有报文对象放在一个报文之中。</li></ol><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><h4 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h4><ol><li>将主机名解析为IP地址</li><li>主机别名</li><li>邮件服务器别名</li><li>负载分配，一个IP地址集合与一个规范主机名相联系，DNS在这些冗余的Web服务器之间循环分配了负载。</li></ol><h4 id="三层DNS服务器"><a href="#三层DNS服务器" class="headerlink" title="三层DNS服务器"></a>三层DNS服务器</h4><ol><li>根DNS服务器</li><li>TLD DNS服务器</li><li>权威DNS服务器</li></ol><h4 id="DNS记录"><a href="#DNS记录" class="headerlink" title="DNS记录"></a>DNS记录</h4><p>资源记录RR：</p><p>​    <code>(Name, Value, Type, TTL)</code>，TTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。</p><p>记录类型：</p><p><code>Type = A</code>，则<code>Name</code>是主机名，<code>Value</code>是该主机名对应的IP地址。提供了标准的主机名到IP地址的映射。</p><p><code>Type = NS</code>，则<code>Name</code>是个域，如(<code>foo.com</code>)，而<code>Value</code>是个知道如何获得该域中主机IP地址的权威DNS服务器的主机名。该记录用于沿着查询链来路由DNS查询。</p><p><code>Type = CNAME</code>，则<code>Value</code>是别名为<code>Name</code>的主机对应的规范主机名。该记录能够向查询的主机提供一个主机名对应的规范主机名。</p><p><code>Type = MX</code>，则<code>Value</code>是个别名为<code>Name</code>的邮件服务器的规范主机名。MX记录允许邮件服务器主机名有简单的别名。通过MX记录，一个公司的邮件服务器和其他服务器可以使用相同的别名。</p><h3 id="DoS"><a href="#DoS" class="headerlink" title="DoS"></a>DoS</h3><p>DoS称为拒绝服务攻击，DDoS是<strong>分布式DoS</strong>。</p><p>Dos的种类：</p><ol><li>弱点攻击</li><li>带宽洪泛：发送大量分组</li><li>连接洪泛：创建大量的半开或全开的TCP连接</li></ol><h2 id="运输层"><a href="#运输层" class="headerlink" title="运输层"></a>运输层</h2><h3 id="多路复用和多路分解"><a href="#多路复用和多路分解" class="headerlink" title="多路复用和多路分解"></a>多路复用和多路分解</h3><p>多路复用和多路分解是所有计算机网络需要的。</p><p>将运输层报文段中的数据交付到争取的套接字的工作称为<strong>多路分解</strong>。</p><p>在源主机从不同套接字中手机数据块，并为每个数据块封装上首部信息（这将在以后用于分解）从而生成报文段，然后将报文段传递到网络层，所有这些工作称为<strong>多路复用</strong>。</p><h3 id="无连接运输：UDP"><a href="#无连接运输：UDP" class="headerlink" title="无连接运输：UDP"></a>无连接运输：UDP</h3><p>UDP除了复用/分解功能及少量的差错检测外，几乎没有对IP增加别的东西。</p><p>UDP首部只有8字节。</p><p>UDP的特点：</p><ol><li><p>关于发送什么数据以及何时发送的应用层控制更为精细。</p></li><li><p>无须建立连接，不会引入建立连接的时延。</p></li><li><p>无连接状态。</p></li><li><p>分组首部开销小。每个TCP报文段都有20字节的首部开销，而UDP仅有8字节的开销。</p></li></ol><h3 id="回退N步（GBN）协议"><a href="#回退N步（GBN）协议" class="headerlink" title="回退N步（GBN）协议"></a>回退N步（GBN）协议</h3><p>允许发送方发送多个分组（当有多个分组可用时）而不需等待确认，但它也受限于在流水线中未确认的分组数不能超过某个最大允许数N。</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210415171754.png" alt="5AAF2F098550DD15DAEAD1395B9EE20E"></p><p>在实践中，一个分组的序号承载在分组首部的一个固定长度的字段中。如果分组序号字段的比特数是<code>k</code>，则该序号范围是<code>[0, 2^k - 1]</code>。</p><p>GBN发送方必须响应三种类型的事件：</p><ul><li>上层的调用。窗口未满则产生一个分组并将其发送，并相应地更新变量。</li><li>收到一个ACK。对序号为n的分组的确认采用<strong>累计确认</strong>的方式，表明接收方已正确接收到序号为n的以前且包括n在内的所有分组。</li><li>超时事件。出现超时，发送方重传所有已发送但还未确认的分组。</li></ul><p>接收方的动作也很简单。如果一个序号为n的分组被接收到，并且按序（即上次交付给上层的数据是序号为n - 1的分组），则接收方为分组n发送一个ACK，并将该分组中的数据部分交付给上层。在所有其他情况下，接收方丢弃该分组，并为最近按序接收的分组重新发送ACK。注意到因为一次交付给上层一个分组，如果分组k已接受并交付，则所有序号比k小的分组也已经交付。</p><p>在GBN协议中，接收方丢弃所有失序分组。这样接收方将不用缓存任何失序分组。</p><h4 id="用到的可靠数据传输技术"><a href="#用到的可靠数据传输技术" class="headerlink" title="用到的可靠数据传输技术"></a>用到的可靠数据传输技术</h4><ol><li>使用序号</li><li>累计确认</li><li>校验和</li><li>超时/重传</li></ol><h3 id="选择重传（SR）"><a href="#选择重传（SR）" class="headerlink" title="选择重传（SR）"></a>选择重传（SR）</h3><p>选择重传协议通过让发送方仅重传那些它怀疑在接收方出错（即丢失或受损）的分组而避免了不必要的重传。这种个别的、按需的重传要求接收方<em>逐个地</em>确认正确接受的分组。</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210415201234.png" alt="0183CCAA4C3B00781FE49AF39B465D43"></p><p>SR发送方的事件与动作：</p><ol><li>从上层收到数据。检查下一个可用于该分组的序号，如果序号在发送方的窗口内，则将数据打包并发送。</li><li>超时。每个分组有自己的逻辑定时器。超时发生时只能发送一个分组。</li><li>收到ACK。倘若该分组序号在窗口内，则发送方将被确认的分组标记为已接收。如果该分组的序号等于send_base，则窗口基序号向前移动到具有最小序号的未确认分组处。如果窗口移动了且有序号落在窗口内的未发送分组，则发送这些分组。</li></ol><p>SR接收方的事件与动作：</p><ol><li>序号在[rcv_base, rcv_base + N - 1]内的分组被正确接收。一个选择ACK被回送给发送方。如果该分组以前没收到过，则缓存该分组。如果分组的序号等于接收窗口的基序号（如上图的rcv_base），则该分组以及以前缓存的序号连续的（起始于rcv_base的）分组交付给上层。然后，接收窗口按向前移动分组的编号向上交付这些分组。</li><li>序号在[rcv_base - N, rcv_base - 1]内的分组被正确收到。在此情况下，必须产生一个ACK，即使该分组是接收方之前已经确认过的分组。</li><li>其他情况。忽略该分组。</li></ol><h3 id="可靠数据传输机制"><a href="#可靠数据传输机制" class="headerlink" title="可靠数据传输机制"></a>可靠数据传输机制</h3><ol><li>检验和</li><li>定时器</li><li>序号</li><li>确认</li><li>否定确认</li><li>窗口、流水线</li></ol><h3 id="面向连接的运输：TCP"><a href="#面向连接的运输：TCP" class="headerlink" title="面向连接的运输：TCP"></a>面向连接的运输：TCP</h3><p>TCP依赖于差错检测、重传、累计确认、定时器以及用于序号和确认号的首部字段。</p><p>TCP的首部字节一般是20字节。</p><p>特点：</p><ol><li><strong>面向连接</strong>，连接组成：一台主机上的缓存、变量和与进程连接的套接字以及另一台主机上的另一组缓存、变量和与进程连接的套接字。</li><li>提供的是<strong>全双工服务</strong></li><li>TCP连接总是<strong>点对点</strong>的，即在单个发送方和单个接收方之间的连接。</li></ol><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><ol><li>客户首先发送给一个特殊的TCP报文段，该报文段中不包含应用层数据。但在报文段首部中的一个标志位（即SYN比特）被置为1。因此，这个特殊报文段称为SYN报文段。客户会随机地选择一个初始序号（client_isn），并将此编号放置于该起始地TCP SYN报文段的序号字段中。</li><li>服务器用另一个特殊的TCP报文段响应。服务器从该数据报中提取出TCP SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户TCP发送允许连接的报文段。这个允许连接的报文段也不包含应用层数据。但是，在报文段的首部却包含3个重要信息。首先，SYN比特被置为1。其次，该TCP报文段首部的确认号字段被置为client_isn + 1。最后，服务器选择自己的初始序号（server_isn），并将其放置在TCP报文段首部的序号字段中。该允许连接的报文段被称为<strong>SYNACK报文段</strong>。</li><li>客户再用第三个特殊报文段作为回应。客户给连接分配缓存和变量。这最后一个报文段对服务器允许连接的报文段进行了确认（该客户通过将值server_isn+1放置到TCP报文段首部的确认字段来完成此项工作）。SYN比特被置为0。该三次握手的第三个阶段可以在报文段负载中携带客户到浏览器的数据。</li></ol><p>前两个报文段不承载“有效载荷”，也就是不包含应用层数据。第三个报文段可以承载有效载荷。</p><h4 id="MSS"><a href="#MSS" class="headerlink" title="MSS"></a>MSS</h4><p>MSS即<strong>最大报文段长度</strong>，MSS是指在报文段里应用层数据的最大长度，而不是指包括首部的TCP报文段的最大长度。</p><p>MSS通常根据最初确定的由本地发送主句发送的最大链路层帧长度（即所谓的<strong>最大传输单元</strong>（MTU））来设置。设置MSS要保证一个TCP报文段（当封装在一个IP数据报中）加上TCP/IP长度（通常为40字节）将适合单个链路层帧。</p><p>以太网和PPP链路层协议都有1500字节的MTU，因此MSS的典型值为1460字节。</p><h4 id="网络拥塞的代价"><a href="#网络拥塞的代价" class="headerlink" title="网络拥塞的代价"></a>网络拥塞的代价</h4><ol><li>分组经历巨大的排队时延。</li><li>发送方必须执行重传以补偿因为缓存溢出而丢弃（丢失）的分组。</li><li>发送方在遇到大时延时所进行的不必要重传会引起路由器利用其链路带宽来转发不必要的分组副本。</li><li>当一个分组沿一条路径被丢弃时，每个上游路由器用于转发该分组到丢弃该分组而使用的传输容量最终被浪费掉了。</li></ol><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>TCP拥塞控制常常被称为<strong>加性增、乘性减</strong>（AIMD）拥塞控制方式。</p><ol><li>慢启动<br>cwnd的值初始置为一个MSS的较小值，在慢启动状态，cwnd的值以1个MSS开始并且每当传输的报文段首次被确认就增加一个MSS。<br>如果存在一个由超时指示的丢包事件（即拥塞），TCP发送方将cwnd设置为1并重新开始慢启动过程。还将ssthresh（慢启动阈值）设置为cwnd/2。<br>当达到或超过ssthresh的值时，结束慢启动并且TCP转移到拥塞避免模式。<br>如果检测到三个冗余ACK，这时TCP执行一种快速重传并进入快速恢复状态。</li><li>拥塞避免<br>每个RTT只将cwnd的值增加一个MSS。一种通用的方式是对于TCP发送方无论何时到达一个新的确认，就将cwnd增加一个MSS（MSS/cwnd）字节。<br>出现超时事件则将ssthresh设置为cwnd的一半，cwnd设置为1，进入慢启动状态。ssthresh = cwnd/2，cwnd = ssthresh。<br>出现三个冗余ACK，则将ssthresh设置为cwnd的一半，cwnd设置为ssthresh + 3*MSS，并进入快速恢复阶状态</li><li>快速恢复<br>对收到的每个冗余的ACK，cwnd的值增加一个MSS。<br>当对丢失报文段的一个ACK到达时，TCP在降低cwnd（降为ssthresh）后进入拥塞避免状态。<br>出现超时事件，则采取跟另两个状态相同的操作并进入慢启动状态。<br>快速恢复时TCP推荐的而非必须的构件。</li></ol><h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><ul><li><strong>应用层：</strong>由用户自己规定，<strong>规定各个应用之间消息传递的形式</strong>等，包括各机互访协议，分布式数据库协议等。常见的应用层协议有HTTP协议、SMTP协议和FTP协议等。</li><li><strong>表示层：</strong>在满足用户需求的基础上，尽可能的节省传输费用而设置的，比如传输压缩文件，jpeg或者加密文件等格式。</li><li><strong>会话层：</strong>用于建立和拆除会话。</li><li><strong>传输层：</strong>负责将来自会话层的消息传递给网络层，<strong>常见的传输层协议有TCP和UDP等协议。</strong></li><li><strong>网络层：</strong>规定通信网内的路由选择等方式，建立用户间的信息报传输设施。常见的网络层协议有IP，ICMP以及ARP等协议。</li><li><strong>数据链路层：</strong>与建立数据传输链路相关。</li><li><strong>物理层：</strong>规定一些机电性能，也包括工作方式如双工、单工或半双工，建立通信的启动和终止等。</li></ul><h3 id="TCP-IP协议"><a href="#TCP-IP协议" class="headerlink" title="TCP/IP协议"></a>TCP/IP协议</h3><p>TCP/IP协议是一系列网络协议的总称，是网络通信的基本骨架。TCP/IP协议模型在OSI七层模型的基础上，通过合并的方式，简化为<strong>四层</strong>，分别为<strong>应用层，传输层，网络层以及链路层</strong>。</p><p>我们通常的应用程序都工作在应用层，当各个应用之间通信时，传输层的TCP模块负责给HTTP数据添加TCP头部等信息；网络层的IP模块负责给HTTP数据添加IP头部等信息；链路层添加以太网首部等信息，并且通过电信号来传输数据包；然后数据包会依次经过对方的链路层，网络层，传输层以及应用层，实现数据的通信。</p><h4 id="IP协议"><a href="#IP协议" class="headerlink" title="IP协议"></a>IP协议</h4><p>IP协议制定了一套网络地址，也就是IP地址，根据IP协议能够区分两台主机是否同属一个网络（子网）。</p><h4 id="ARP协议（地址解析协议）："><a href="#ARP协议（地址解析协议）：" class="headerlink" title="ARP协议（地址解析协议）："></a>ARP协议（地址解析协议）：</h4><p>根据IP地址获取MAC地址，将目标的IP地址在链路层进行包装，生成以太网数据包，在同一个子网内进行广播出去，各个主机拿到IP地址和自己的IP地址对比，若一样，则返回自己的MAC地址。注意，MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间。</p><h4 id="路由协议："><a href="#路由协议：" class="headerlink" title="路由协议："></a>路由协议：</h4><p>ARP的寻址必须是在同一个子网内，我们可以通过IP协议来确定是否是同一个子网。如果不是同一个子网，则通过网关将数据包多次转发到对应的子网中，完成这个路由协议的物理设备就是路由器。</p><h4 id="三次握手流程图"><a href="#三次握手流程图" class="headerlink" title="三次握手流程图"></a>三次握手流程图</h4><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422220405.png" alt="图片说明"></p><p>客户端经历了Close-&gt;SYN_SENT-&gt;ESTABLISHED的状态变化；</p><p>服务端经历了Close-&gt;Listen-&gt;SYN_RCVD-&gt;EATABLISHED的状态变化。</p><h4 id="四次挥手的状态流程图："><a href="#四次挥手的状态流程图：" class="headerlink" title="四次挥手的状态流程图："></a>四次挥手的状态流程图：</h4><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210422221225.png" alt="图片说明"></p><p><strong>客户端经历的状态变化为：</strong><br>    ESTABLISHED-&gt;FIN_WAIT_1-&gt;FIN_WAIT_2-&gt;TIME_WAIT-&gt;CLOSE</p><p><strong>服务端经历的状态变化为：</strong><br>    ESTABLISHED-&gt;CLOSE_WAIT-&gt; LAST_ACK-&gt;CLOSE</p><h3 id="常见的HTTP-Code有哪些？"><a href="#常见的HTTP-Code有哪些？" class="headerlink" title="常见的HTTP Code有哪些？"></a>常见的HTTP Code有哪些？</h3><ul><li>1xx（临时响应）</li><li>2xx（成功）</li><li>3xx（重定向）：表示要完成请求需要进一步操作</li><li>4xx（错误）：表示请求可能出错，妨碍了服务器的处理</li><li>5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误</li></ul><h3 id="常见HTTP协议的状态码"><a href="#常见HTTP协议的状态码" class="headerlink" title="常见HTTP协议的状态码"></a>常见HTTP协议的状态码</h3><ul><li>200（成功）</li><li>302 （重定向）：请求重定向到指定网页</li><li>304（未修改）：自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容</li><li>400：访问的页面域名不存在或者请求错误</li><li>401（未授权）：请求要求身份验证</li><li>403（禁止）：服务器拒绝请求（比如死循环了，一直访问）</li><li>404（未找到）：服务器找不到请求的网页</li><li>405 （方法禁用）:Post请求当成了Get请求直接访问</li><li>500 （服务器内部错误）：有bug导致程序嗝屁了</li><li>502 （错误网关）：服务器从上游接到了无效响应</li><li>504 （ 网关超时）：nginx请求超时，请求一直没有返回</li><li>505：HTTP版本不支持</li></ul><h3 id="SSL协议"><a href="#SSL协议" class="headerlink" title="SSL协议"></a>SSL协议</h3><p>HTTPS协议在HTTP的基础上加入了SSL（安全套接字层）协议，SSL逐渐演变为了TLS协议，但是业界习惯仍然称其为SSL协议。</p><p>SSL协议在传输控制层的基础上建立了安全的连接，它作为一种通用可靠的安全解决方案，可与多种应用层协议结合使用，实现应用数据的安全传输。SSL协议分为<strong>记录协议，握手协议，警告协议和密码规范改变协议</strong>：</p><p><strong>记录协议：</strong>接收上层协议或下层协议的消息并进行一系列的处理，然后再将处理后的消息继续向下或向上传递。主要包括对消息进行加解密，压缩解压缩，分段或者重组等操作。</p><p><strong>握手协议：</strong>建立在三次握手之后，为通信双方确立安全连接所需要的安全参数，通常也会在此阶段对通信双方身份的真实性进行验证。</p><p><strong>警告协议：</strong>无论是在握手阶段还是在对应用层数据的传输阶段，都有可能出现差错。警告协议规定了在SSL协议工作过程中可能出现的差错、错误的严重等级以及相应的处理方式。</p><p><strong>密码规范改变协议：</strong>在SSL握手刚开始的时候，加密参数还没确定，消息都是明文传送的。双方协商好加密参数之后，在发送握手结束消息之前，需要发送一个密码规范改变消息（Change Cipher Message）来通知对方随后的消息都使用刚刚协商好的加密算法和加密密钥进行加密。</p><h3 id="HTTP1-0，HTTP1-1以及HTTP2-0协议的区别"><a href="#HTTP1-0，HTTP1-1以及HTTP2-0协议的区别" class="headerlink" title="HTTP1.0，HTTP1.1以及HTTP2.0协议的区别"></a>HTTP1.0，HTTP1.1以及HTTP2.0协议的区别</h3><ul><li><p>HTTP1.0<br>浏览器的每次请求都需要与服务器建立一个TCP连接，服务器处理完成后立即断开TCP连接，服务器不跟踪每个客户端也不记录过去的请求。也就是默认使用Connection: close</p></li><li><p>HTTP1.1<br>HTTP/1.1中默认使用Connection: keep-alive，避免了连接建立和释放的开销。但服务器必须按照客户端请求的先后顺序依次回送相应的结果，以保证客户端能够区分出每次请求的响应内容。通过Content-Length字段来判断当前请求的数据是否已经全部接收。不允许同时存在两个并行的响应。</p></li><li><p>HTTP2.0</p><p>HTTP2.0协议新增了二进制分帧，多路复用，头部压缩和服务器推送等功能，进一步提高了传输效率。</p></li></ul><h3 id="路由汇聚"><a href="#路由汇聚" class="headerlink" title="路由汇聚"></a>路由汇聚</h3><p><strong>路由汇聚</strong>是指把一组路由汇聚为一个单个的路由广播。路由汇聚优点是可以缩小网络上的路由表的尺寸。</p><ul><li>将各子网地址的网段以二进制写出。</li><li>比较，从第1位比特开始进行比较，将从开始不相同的比特到末尾位填充为0。由此得到的地址为汇总后的网段的网络地址，其网络位为连续的相同的比特的位数。</li></ul><p>假设下面有4个网络:</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs http">172.18.129.0/24<br>172.18.130.0/24<br>172.18.132.0/24<br>172.18.133.0/24<br></code></pre></td></tr></table></figure><p><strong>具体计算方式如下：</strong></p><ul><li>129的二进制代码是10000001</li><li>130的二进制代码是10000010</li><li>132的二进制代码是10000100</li><li>133的二进制代码是10000101</li></ul><p>这四个数的前五位相同都是10000，所以加上前面的172.18这两部分相同的位数，网络号就是<strong>8+8+5=21</strong>。而10000000的十进制数是128，所以，路由汇聚的IP地址就是172.18.128.0。所以最终答案就是172.18.128.0/21</p><h3 id="子网掩码的求法"><a href="#子网掩码的求法" class="headerlink" title="子网掩码的求法"></a>子网掩码的求法</h3><p><strong>根据划分的子网数：</strong></p><p><strong>算法实现：</strong>在求子网掩码之前必须先搞清楚要划分的子网数目，以及每个子网内的所需主机数目。</p><ul><li>将子网数目转化为二进制来表示</li><li>取得该二进制的位数，为 N</li><li>取得该IP地址的类子网掩码，将其主机地址部分的前N位置1 即得出该IP地址划分子网的子网掩码。</li></ul><p><strong>举例：</strong></p><p>如欲将B类IP地址168.195.0.0划分成27个子网，则其子网掩码为<strong>255.255.248.0</strong></p><ul><li>27=11011</li><li>该二进制为五位数，N = 5</li><li>将B类地址的子网掩码255.255.0.0的主机地址前5位置1（B类地址的主机位包括后两个字节，所以这里要把第三个字节的前5位置1），得到 <strong>255.255.248.0</strong></li></ul><p>根据每个子网中的主机数：</p><p><strong>算法实现：</strong>利用主机数来计算。</p><ul><li>将主机数目转化为二进制来表示</li><li>如果主机数小于或等于254（注意去掉保留的两个IP地址），则取得该主机的二进制位数，为 N，这里肯定N&lt;8。如果大于254，则 N&gt;8，这就是说主机地址将占据不止8位。</li><li>使用255.255.255.255来将该类IP地址的主机地址位数全部置1，然后从后向前的将N位全部置为 0，即为子网掩码值。</li></ul><p><strong>举例：</strong></p><p>如欲将B类IP地址168.195.0.0划分成若干子网，每个子网内有主机700台，则其子网掩码为：<strong>255.255.252.0</strong></p><ul><li>700=1010111100</li><li>该二进制为十位数，N = 10</li><li>将该B类地址的子网掩码255.255.0.0的主机地址全部置1，得到255.255.255.255</li><li>然后再从后向前将后10位置0,即为： 11111111.11111111.11111100.00000000</li><li>即255.255.252.0。</li></ul><h3 id="XSS跨站脚本攻击："><a href="#XSS跨站脚本攻击：" class="headerlink" title="XSS跨站脚本攻击："></a>XSS跨站脚本攻击：</h3><p><strong>XSS （Cross-Site Scripting）</strong>跨站脚本攻击是一种常见的安全漏洞，恶意攻击者在用户提交的数据中加入一些代码，将代码嵌入到了Web页面中，从而可以盗取用户资料，控制用户行为或者破坏页面结构和样式等。为了和 CSS 区分，这里把攻击的第一个字母改成了 X，于是叫做 XSS。</p><p>最简单的就是当我们提交一个查询后弹出一个alert页面，却无论如何都关不掉，这就是发生了XSS跨站脚本攻击。</p><h4 id="XSS产生原因："><a href="#XSS产生原因：" class="headerlink" title="XSS产生原因："></a>XSS产生原因：</h4><p>XSS产生的原因是过于信任客户端的数据，没有做好过滤或者转义等工作。如果客户端上传的数据中插入一些符号以及javascript代码，那么这些数据将会成为应用代码中的一部分了，这样就造成了XSS攻击。</p><h4 id="XSS分类："><a href="#XSS分类：" class="headerlink" title="XSS分类："></a>XSS分类：</h4><ul><li><strong>存储型：</strong>攻击者将恶意代码存储到了数据库中，在响应浏览器请求的时候返回恶意代码，并且执行。这种攻击常见于带有用户保存数据的网站功能；</li><li><strong>反射型：</strong>将恶意代码放在URL中，将参数提交到服务器。服务器解析后响应，在响应结果中存在XSS代码，最终通过浏览器解析执行；</li><li><strong>DOM型：</strong>取出和执行恶意代码由浏览器端完成，属于前端 JavaScript的安全漏洞。</li></ul><h4 id="XSS防御"><a href="#XSS防御" class="headerlink" title="XSS防御"></a>XSS防御</h4><p><strong>XSS防御：</strong></p><ul><li>对重要的 cookie设置 httpOnly, 防止客户端通过document.cookie读取 cookie；</li><li>对输入内容的特定字符进行编码，前端后端都可以对传入的内容进行过滤，去掉带javascript等字段的输入</li></ul><h3 id="CSRF跨站请求伪造："><a href="#CSRF跨站请求伪造：" class="headerlink" title="CSRF跨站请求伪造："></a>CSRF跨站请求伪造：</h3><p><strong>CSRF（ Cross-site request forgery）跨站请求伪造</strong>，也是一种常见的安全漏洞。XSS相当于是控制了站点内的信任用户，而CSRF则通过<strong>伪装</strong>成受信任用户的请求来利用受信任的网站。</p><p><strong>CSRF举例：</strong></p><p>用户登录受信任网站A，并在本地生成登录态Cookie。（如果用户没有登录网站A，那么网站B在获取A网站的信息并且去请求网站A的接口时，会提示登录）<strong>在不登出A的情况下</strong>，访问恶意网站B，那么网站B得到了网站A的所有信息，然后B网站去请求A网站的接口，伪装成A网站的正常请求为所欲为。</p><p>下边以示意图来说明<strong>CSRF整个流程</strong>：</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210423100106.png" alt="图片说明"></p><p><strong>注意：</strong></p><p>CSRF中恶意网站仅仅是伪装成了正常用户，但是其并不可以直接获取到正常用户的登录态cookie等信息。如果不做防御，被攻击网站服务器是无法区分是否是冒用用户，因为当前请求确实带着登录凭证等信息。</p><p><strong>CSRF防御：</strong></p><ul><li><strong>Referer 头验证</strong>：在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的来源地址。不靠谱，Referer可以被改变；</li><li><strong>Token验证</strong>：服务器发送给客户端一个Token，客户端提交的表单中（或者URL上）带着这个Token。如果这个Token 不合法，那么服务器拒绝这个请求。</li><li><strong>双重Cookie验证</strong>：利用恶意网站无法获取cookie信息，仅可冒用的特点，我们将cookie中的参数取出来，加入到请求参数中，服务端进行校验，如果参数中没有附加额外的cookie中的参数，那么就拒绝请求。</li></ul><p><strong>解析：</strong></p><p>XSS和CSRF均属于安全漏洞，和我们的开发工作息息相关。对于一些对安全性有一定要求的方向和岗位，了解常见的XSS和CSRF攻击无疑是面试的一大加分项。</p><p>那么接下来，我们看看<strong>CSRF和XSS的区别有哪些呢</strong>？</p><ul><li>CSRF攻击需要用户先登录网站A，恶意网站B获取到A网站用户的 cookie；</li><li>XSS攻击则不需要登录。</li><li>CSRF攻击本质是利用网站A本身的漏洞，去请求网站A的相关接口；</li><li>XSS攻击向网站 A 注入恶意代码，然后通过执行恶意代码，篡改了网站A的内容。</li></ul><h3 id="SSRF服务端请求伪造"><a href="#SSRF服务端请求伪造" class="headerlink" title="SSRF服务端请求伪造"></a>SSRF服务端请求伪造</h3><p>SSRF是一种由攻击者构造请求，利用服务端发起的一种安全漏洞。一般情况下，SSRF攻击的目标是<strong>外网无法访问的内部系统。</strong>我们先来看下SSRF攻击的示意图：</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210423101154.png" alt="图片说明"></p><p><strong>SSRF漏洞举例：</strong></p><ul><li>正常的网络请求流程：客户端A发起请求 -&gt; 服务端B接收请求 -&gt; 服务端B处理请求 -&gt; 服务端B返回响应</li><li>存在SSRF漏洞下的网络请求流程：<br>比如现在客户端A发起的请求是这样的 <a href="http://www.nowcoder.com/xxx.php?image=www.abc.com/photo.jpg">www.nowcoder.com/xxx.php?image=www.abc.com/photo.jpg</a>服务端B收到该请求后，会接着取访问<a href="http://www.abc.com/photo.jpg">www.abc.com/photo.jpg</a> 获取资源文件。如果服务端B对客户端发起的请求没有进行过滤等操作，那么?image=可能会被恶意篡改。最后的结果就是，<strong>借助于公网上的服务器来访问了内网系统。</strong></li></ul><p><strong>SSRF产生原因：</strong></p><p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能，且没有对目标地址做过滤与限制。比如指定URL地址获取网页文本内容，加载指定地址的图片和文档等。</p><p><strong>常见SSRF漏洞出现场景：</strong></p><ul><li>分享场景，通过URL地址分享网页内容。</li><li>转码服务，在线翻译场景。</li><li>地址加载或下载图片。</li><li>图片、文章收藏功能。</li><li>未公开的api实现以及其他调用URL的功能等。</li></ul><p><strong>SSRF漏洞危害：</strong></p><p>因为外网借助了服务端来实现了对内网服务器的访问，所以很多操作都可以进行，包括如下的危害：</p><ul><li>对服务器所在的内网进行端口扫描，获取一些服务的banner信息等。</li><li>攻击运行在内网或者本地的应用程序。</li><li>对内网WEB应用进行指纹识别，通过访问默认文件实现。</li><li>下载内网的一些资源文件等。</li></ul><p><strong>SSRF的防御措施：</strong></p><ul><li>对<strong>错误信息进行统一处理</strong>，避免用户可以根据错误信息来判断远端服务器的端口状态。</li><li>对请求的<strong>端口进行限制</strong>，限定为HTTP常用的端口，比如，80，443和8080等。</li><li>设定<strong>IP黑名单</strong>。避免应用被用来获取内网数据，攻击内网。</li><li><strong>禁用不需要的协议</strong>。仅仅允许HTTP和HTTPS请求。</li><li>对返回信息进行<strong>有效过滤</strong>等。</li></ul><h3 id="SQL注入"><a href="#SQL注入" class="headerlink" title="SQL注入"></a>SQL注入</h3><p>SQL注入是指通过把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串，最终达到欺骗服务器，执行恶意的SQL命令。</p><p>SQL注入就是服务端将客户端传入的恶意SQL语句直接进行了执行，这样会导致问题出现。比如说用户在登录的时候，使用了or 1=1来完成身份验证和授权。</p><p>SQL注入是一种流行的攻击攻击方法，但是通过一些手段是可以防御该攻击的，<strong>常见的防御手段如下：</strong></p><ul><li>使用预编译语句，比如MyBatis中的SQL语句使用#号代替$符号。</li><li>使用安全的存储过程来防止SQL注入。</li><li>对客户端的输入进行数据类型的检查等。</li></ul><p>作为一名优秀的服务端开发人员，我们应该牢记一条原则，“<strong>永远不要相信客户端</strong>”。对客户端的每次请求，我们都要做好充分的过滤，验证与授权，这样才可以尽可能的避免常见的Web安全漏洞，抵御来自外部世界的攻击。</p><h3 id="从浏览器输入一个网站，之后会发生什么"><a href="#从浏览器输入一个网站，之后会发生什么" class="headerlink" title="从浏览器输入一个网站，之后会发生什么"></a>从浏览器输入一个网站，之后会发生什么</h3><p>在浏览器中输入一个网址，首先要做的就是<strong>域名的解析</strong>，也就是域名-&gt;ip的解析，依次查看了浏览器缓存，系统缓存，hosts文件，路由器缓存，递归搜索根域名服务器，直到<strong>找到最终的ip地址</strong>。</p><p>然后就是TCP协议的<strong>三次握手</strong>建立连接，过程我们已经阐述了。由浏览器发送一个HTTP请求；经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器；服务器处理该HTTP请求，返回一个<strong>HTML文件</strong>；浏览器解析该HTML文件，并且<strong>渲染显示</strong>在浏览器端。</p><p>这里，我们可以来具体阐述下<strong>HTTP协议和TCP协议的关系与区别。</strong></p><h3 id="HTTP协议和TCP协议的关系与区别："><a href="#HTTP协议和TCP协议的关系与区别：" class="headerlink" title="HTTP协议和TCP协议的关系与区别："></a>HTTP协议和TCP协议的关系与区别：</h3><p>HTTP协议是一种基于TCP/IP的应用层协议，进行HTTP数据请求必须先建立TCP/IP连接。HTTP协议提供了封装或者显示数据的具体形式；TCP协议提供了网络通信的能力。两个计算机之间的交流其实就是是两个端口之间的数据通信,具体的数据会以什么样的形式展现是以不同的应用层协议来定义的。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>最小覆盖子串</title>
    <link href="/2021/04/12/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/"/>
    <url>/2021/04/12/%E6%9C%80%E5%B0%8F%E8%A6%86%E7%9B%96%E5%AD%90%E4%B8%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h1><p><a href="https://leetcode-cn.com/problems/minimum-window-substring/">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 <code>s</code> 、一个字符串 <code>t</code> 。返回 <code>s</code> 中涵盖 <code>t</code> 所有字符的最小子串。如果 <code>s</code> 中不存在涵盖 <code>t</code> 所有字符的子串，则返回空字符串 <code>&quot;&quot;</code> 。</p><p><strong>注意：</strong>如果 <code>s</code> 中存在这样的子串，我们保证它是唯一的答案。</p><span id="more"></span><p><strong>示例 1：</strong></p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nix">输入：<span class="hljs-attr">s</span> = <span class="hljs-string">&quot;ADOBECODEBANC&quot;</span>, <span class="hljs-attr">t</span> = <span class="hljs-string">&quot;ABC&quot;</span><br>输出：<span class="hljs-string">&quot;BANC&quot;</span><br></code></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs smalltalk">输入：s = <span class="hljs-comment">&quot;a&quot;</span>, t = <span class="hljs-comment">&quot;a&quot;</span><br>输出：<span class="hljs-comment">&quot;a&quot;</span><br></code></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= s.length, t.length &lt;= 105</code></li><li><code>s</code> 和 <code>t</code> 由英文字母组成</li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>该题目可以采用滑动窗口算法，即可清晰简便地完成</p><p>具体步骤：</p><pre><code>1. 用双指针在字符串`S`中标记窗口的位置 2. 扩大窗口直至满足要求，也就是包含`t`中所有字符 3. 缩小窗口直至不满足要求，每次缩小窗口，都更新一下结果 4. 重复2和3直到到达字符串末尾</code></pre><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">string <span class="hljs-title">minWindow</span><span class="hljs-params">(string s, string t)</span> </span>&#123;<br>        unordered_map&lt;<span class="hljs-keyword">char</span>, <span class="hljs-keyword">int</span>&gt; need, window;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> c:t)&#123;<br>            need[c]++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>, len = INT_MAX;<br>        <span class="hljs-keyword">int</span> valid = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(right &lt; s.<span class="hljs-built_in">size</span>())&#123;<br>            <span class="hljs-keyword">char</span> cur = s[right++];<br>            <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(cur))&#123;<br>                window[cur]++;<br>                <span class="hljs-keyword">if</span>(window[cur] == need[cur])<br>                    valid++;<br>            &#125;<br><br>            <span class="hljs-keyword">while</span>(valid == need.<span class="hljs-built_in">size</span>())&#123;<br>                <span class="hljs-keyword">if</span>(valid == need.<span class="hljs-built_in">size</span>())&#123;<br>                   <span class="hljs-keyword">if</span>(len &gt; right - left)&#123;<br>                        start = left;<br>                        len = right - left;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">char</span> head = s[left++];<br>                <span class="hljs-keyword">if</span>(need.<span class="hljs-built_in">count</span>(head))&#123;<br>                    <span class="hljs-keyword">if</span>(window[head] == need[head])<br>                        valid--;<br>                    window[head]--;<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (len == INT_MAX) ? <span class="hljs-string">&quot;&quot;</span>:s.<span class="hljs-built_in">substr</span>(start, len);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>滑动窗口</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>算法</tag>
      
      <tag>滑动窗口</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>验证二叉搜索树</title>
    <link href="/2021/04/09/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/"/>
    <url>/2021/04/09/%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="验证二叉搜索树"><a href="#验证二叉搜索树" class="headerlink" title="验证二叉搜索树"></a>验证二叉搜索树</h1><p><a href="%5B%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%5D(https://leetcode-cn.com/problems/validate-binary-search-tree/">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含<strong>小于</strong>当前节点的数。</li><li>节点的右子树只包含<strong>大于</strong>当前节点的数。</li><li>所有左子树和右子树自身必须也是二叉搜索树。</li></ul><span id="more"></span><p><strong>示例 1:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>    <span class="hljs-number">2</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">1</span>   <span class="hljs-number">3</span><br>输出: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs livescript">输入:<br>    <span class="hljs-number">5</span><br>   / <span class="hljs-string">\</span><br>  <span class="hljs-number">1</span>   <span class="hljs-number">4</span><br>     / <span class="hljs-string">\</span><br>    <span class="hljs-number">3</span>   <span class="hljs-number">6</span><br>输出: <span class="hljs-literal">false</span><br>解释: 输入为: [<span class="hljs-number">5</span>,<span class="hljs-number">1</span>,<span class="hljs-number">4</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">3</span>,<span class="hljs-number">6</span>]。<br>     根节点的值为 <span class="hljs-number">5</span> ，但是其右子节点值为 <span class="hljs-number">4</span> 。<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="解法一：递归"><a href="#解法一：递归" class="headerlink" title="解法一：递归"></a>解法一：递归</h3><h4 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h4><p>由二叉搜索树的性质知，每个结点左子树的值都小于该结点，右子树的值都大于该结点，因此，每个结点的左右子树的值分别在两个固定的开区间内，我们可以递归判断每个节点的左右子树的值是否满足区间要求，从而最终判断出树是否是二叉搜索树。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(root, LONG_MIN, LONG_MAX);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(TreeNode* root, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> low, <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> high)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">if</span>(root-&gt;val &lt;= low || root-&gt;val &gt;= high)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">check</span>(root-&gt;left, low, root-&gt;val) &amp;&amp; <span class="hljs-built_in">check</span>(root-&gt;right, root-&gt;val, high);<br>    &#125;<br><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="解法二：中序遍历"><a href="#解法二：中序遍历" class="headerlink" title="解法二：中序遍历"></a>解法二：中序遍历</h3><h4 id="主要思路-1"><a href="#主要思路-1" class="headerlink" title="主要思路"></a>主要思路</h4><p>二叉搜索树的中序遍历顺序是升序序列，因此我们可以对数进行中序遍历，如果其符合升序顺序，则代表是二叉搜索树。</p><h4 id="代码："><a href="#代码：" class="headerlink" title="代码："></a>代码：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">bool</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>        stack&lt;TreeNode*&gt; stk;<br>        <span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span> inorder = (<span class="hljs-keyword">long</span> <span class="hljs-keyword">long</span>)INT_MIN - <span class="hljs-number">1</span>;<br><br>        <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() || root != <span class="hljs-literal">nullptr</span>)&#123;<br>            <span class="hljs-keyword">while</span>(root != <span class="hljs-literal">nullptr</span>)&#123;<br>                stk.<span class="hljs-built_in">push</span>(root);<br>                root = root-&gt;left;<br>            &#125;<br>            root = stk.<span class="hljs-built_in">top</span>();<br>            stk.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">if</span>(root-&gt;val &lt;= inorder)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            inorder = root-&gt;val;<br>            root = root-&gt;right;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br><br>&#125;;<br></code></pre></td></tr></table></figure><p>ps: 该题需要注意要使用long long，int的范围是不够的</p>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二叉树的层次遍历</title>
    <link href="/2021/04/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/"/>
    <url>/2021/04/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86/</url>
    
    <content type="html"><![CDATA[<h1 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h1><p><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal/">原题链接</a></p><h2 id="相关题目"><a href="#相关题目" class="headerlink" title="相关题目"></a>相关题目</h2><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof/">从上到下打印二叉树</a></p><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">从上到下打印二叉树 II</a></p><p><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof/">从上到下打印二叉树 III</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个二叉树，请你返回其按 <strong>层序遍历</strong> 得到的节点值。 （即逐层地，从左到右访问所有节点）。</p><span id="more"></span><p><strong>示例：</strong><br>二叉树：<code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>返回其层序遍历结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  [<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">9</span>,<span class="hljs-number">20</span>],<br>  [<span class="hljs-number">15</span>,<span class="hljs-number">7</span>]<br>]<br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这几个题目的思路相同。都是采用广度优先搜索进行层次遍历，然后将结果存入数组中即可。</p><p>因为有的题目需要按层次进行输出。</p><p>我们可以用一种巧妙的方法修改广度优先搜索：</p><ul><li>首先根元素入队</li><li>当队列不为空的时候<ul><li>求当前队列的长度 <em>s<del>i</del></em></li><li>依次从队列中取 <em>s<del>i</del></em> 个元素进行拓展，然后进入下一次迭代</li></ul></li></ul><p>它和普通广度优先搜索的区别在于，普通广度优先搜索每次只取一个元素拓展，而这里每次取 <em>s<del>i</del></em> 个元素。在上述过程中的第 <em>i</em> 次迭代就得到了二叉树的第 <em>i</em> 层的 <em>s<del>i</del></em> 个元素。</p><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; <span class="hljs-built_in">levelOrder</span>(TreeNode* root) &#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> &#123;&#125;;<br>        vector&lt;vector&lt;<span class="hljs-keyword">int</span>&gt;&gt; res;<br>        queue&lt;TreeNode*&gt; q;<br>        q.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">while</span>(!q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-keyword">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>            vector&lt;<span class="hljs-keyword">int</span>&gt; curVec;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; ++i)&#123;<br>                TreeNode* curNode = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                curVec.<span class="hljs-built_in">push_back</span>(curNode-&gt;val);<br>                <span class="hljs-keyword">if</span>(curNode-&gt;left != <span class="hljs-literal">nullptr</span>)&#123;<br>                    q.<span class="hljs-built_in">push</span>(curNode-&gt;left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(curNode-&gt;right != <span class="hljs-literal">nullptr</span>)&#123;<br>                    q.<span class="hljs-built_in">push</span>(curNode-&gt;right);<br>                &#125;<br>            &#125;<br>            res.<span class="hljs-built_in">push_back</span>(curVec);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从前序与中序遍历序列构造二叉树</title>
    <link href="/2021/04/08/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <url>/2021/04/08/%E4%BB%8E%E5%89%8D%E5%BA%8F%E4%B8%8E%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<h1 id="从前序与中序遍历序列构造二叉树"><a href="#从前序与中序遍历序列构造二叉树" class="headerlink" title="从前序与中序遍历序列构造二叉树"></a>从前序与中序遍历序列构造二叉树</h1><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">原题链接</a></p><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>根据一棵树的前序遍历与中序遍历构造二叉树。</p><span id="more"></span><p><strong>注意:</strong></p><p>你可以假设树中没有重复的元素。</p><p>例如，给出</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog">前序遍历 preorder = <span class="hljs-string">[3,9,20,15,7]</span><br>中序遍历 inorder = <span class="hljs-string">[9,3,15,20,7]</span><br></code></pre></td></tr></table></figure><p>返回如下的二叉树：</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs livescript">  <span class="hljs-number">3</span><br> / <span class="hljs-string">\</span><br><span class="hljs-number">9</span>  <span class="hljs-number">20</span><br>  /  <span class="hljs-string">\</span><br> <span class="hljs-number">15</span>   <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><h3 id="方法一：递归"><a href="#方法一：递归" class="headerlink" title="方法一：递归"></a>方法一：递归</h3><p>对于任意一颗树而言，前序遍历的形式总是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[ 根节点, [左子树的前序遍历结果], [右子树的前序遍历结果] ]<br></code></pre></td></tr></table></figure><p>即根节点总是前序遍历中的第一个节点。而中序遍历的形式总是</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">[ [左子树的中序遍历结果], 根节点, [右子树的中序遍历结果] ]<br></code></pre></td></tr></table></figure><p>前序遍历序列的第一个必定为当前树的树根。每次选前序遍历的第一个作为树根，找到其在中序遍历中的位置，然后就可以获取到左右子树的长度。</p><p>这样以来，我们就知道了左子树的前序遍历和中序遍历结果，以及右子树的前序遍历和中序遍历结果，我们就可以递归地对构造出左子树和右子树，再将这两颗子树接到根节点的左右位置。</p><p>具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">build</span>(preorder, <span class="hljs-number">0</span>, preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>, inorder, <span class="hljs-number">0</span>, inorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function">TreeNode* <span class="hljs-title">build</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt; preorder, <span class="hljs-keyword">int</span> preStart, <span class="hljs-keyword">int</span> preEnd, vector&lt;<span class="hljs-keyword">int</span>&gt; inorder, <span class="hljs-keyword">int</span> inStart, <span class="hljs-keyword">int</span> inEnd)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(preStart &gt; preEnd)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br><br>        <span class="hljs-keyword">int</span> rootVal = preorder[preStart];<br><br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = inStart; i &lt;= inEnd; ++i)&#123;<br>            <span class="hljs-keyword">if</span>(inorder[i] == rootVal)&#123;<br>                index = i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> leftSize = index - inStart;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootVal);<br><br>        root-&gt;left = <span class="hljs-built_in">build</span>(preorder, preStart + <span class="hljs-number">1</span>, preStart + leftSize, inorder, inStart, index - <span class="hljs-number">1</span>);<br>        root-&gt;right = <span class="hljs-built_in">build</span>(preorder, preStart + leftSize + <span class="hljs-number">1</span>, preEnd, inorder, index + <span class="hljs-number">1</span>, inEnd);<br><br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="方法二：迭代"><a href="#方法二：迭代" class="headerlink" title="方法二：迭代"></a>方法二：迭代</h3><blockquote><p>对于前序遍历中的任意两个连续节点 <em>u</em> 和 <em>v</em>，根据前序遍历的流程，我们可以知道 <em>u</em> 和<em>v</em> 只有两种可能的关系：</p><ul><li><em>v</em> 是 <em>u</em> 的左儿子。这是因为在遍历到 <em>u</em> 之后，下一个遍历的节点就是 <em>u</em> 的左儿子，即 <em>v</em>；</li><li><em>u</em> 没有左儿子，并且 <em>v</em> 是 <em>u</em> 的某个祖先节点（或者 <em>u</em> 本身）的右儿子。如果 <em>u</em> 没有左儿子，那么下一个遍历的节点就是 <em>u</em> 的右儿子。如果 <em>u</em> 没有右儿子，我们就会向上回溯，直到遇到第一个有右儿子（且 <em>u</em> 不在它的右儿子的子树中）的节点 *u<del>a</del>*，那么 <em>v</em> 就是 <em>u<del>a</del></em> 的右儿子。</li></ul></blockquote><p> 因为前序遍历是根-&gt;左孩子-&gt;右孩子的顺序，所以在树中会向左一直访问到左孩子直到没有左孩子往上再访问右孩子。而中序遍历则是左孩子-&gt;根-&gt;右孩子的顺序，所以第一个访问的就是最左边的左孩子，再依次访问根和右孩子。因此，我们在前序遍历中找到中序的第一个，再往前回退，前序回退时中序往后走，若值仍相等，则说明这一个是前一个的左孩子，然后一直往下走，直到值不同时出现右孩子应在的位置。</p><blockquote><p>我们用一个栈 <code>stack</code> 来维护「当前节点的所有还没有考虑过右儿子的祖先节点」，栈顶就是当前节点。也就是说，只有在栈中的节点才可能连接一个新的右儿子。同时，我们用一个指针 <code>index</code> 指向中序遍历的某个位置，初始值为 <code>0</code>。<code>index</code> 对应的节点是「当前节点不断往左走达到的最终节点」，这也是符合中序遍历的。</p></blockquote><p>具体代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;</span><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; preorder, vector&lt;<span class="hljs-keyword">int</span>&gt;&amp; inorder)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(preorder.<span class="hljs-built_in">size</span>() == <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>        stack&lt;TreeNode*&gt; stk;<br>        TreeNode* root = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preorder[<span class="hljs-number">0</span>]);<br>        stk.<span class="hljs-built_in">push</span>(root);<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; preorder.<span class="hljs-built_in">size</span>(); ++i)&#123;<br>            <span class="hljs-keyword">int</span> preVal = preorder[i];<br>            TreeNode* node = stk.<span class="hljs-built_in">top</span>();<br>            <span class="hljs-keyword">if</span>(node-&gt;val != inorder[index])&#123;<br>                node-&gt;left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preVal);<br>                stk.<span class="hljs-built_in">push</span>(node-&gt;left);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">while</span>(!stk.<span class="hljs-built_in">empty</span>() &amp;&amp; stk.<span class="hljs-built_in">top</span>()-&gt;val == inorder[index])&#123;<br>                    node = stk.<span class="hljs-built_in">top</span>();<br>                    stk.<span class="hljs-built_in">pop</span>();<br>                    index++;<br>                &#125;<br>                node-&gt;right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(preVal);<br>                stk.<span class="hljs-built_in">push</span>(node-&gt;right);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>leetcode</category>
      
      <category>树</category>
      
    </categories>
    
    
    <tags>
      
      <tag>leetcode</tag>
      
      <tag>树</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试技巧总结</title>
    <link href="/2021/04/08/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/"/>
    <url>/2021/04/08/%E9%9D%A2%E8%AF%95%E6%8A%80%E5%B7%A7%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="面试技巧总结"><a href="#面试技巧总结" class="headerlink" title="面试技巧总结"></a>面试技巧总结</h1><h2 id="央视新闻微博发的面试技巧"><a href="#央视新闻微博发的面试技巧" class="headerlink" title="央视新闻微博发的面试技巧"></a>央视新闻微博发的面试技巧</h2><span id="more"></span><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210408212021.jpg" alt="微信图片_20210408211903"></p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210408212034.jpg" alt="微信图片_20210408211909"></p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210408212045.jpg" alt="微信图片_20210408211912"></p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210408212129.jpg" alt="微信图片_20210408211915"></p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210408212138.jpg" alt="微信图片_20210408211917"></p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210408212157.jpg" alt="微信图片_20210408211920"></p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210408212204.jpg" alt="微信图片_20210408211922"></p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210408212211.jpg" alt="微信图片_20210408211925"></p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210408211951.jpg" alt="微信图片_20210408211927"></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PicGo+Github+Typora实现笔记图片上传到github图床</title>
    <link href="/2021/04/03/PicGo-Github-Typora%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github%E5%9B%BE%E5%BA%8A/"/>
    <url>/2021/04/03/PicGo-Github-Typora%E5%AE%9E%E7%8E%B0%E7%AC%94%E8%AE%B0%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0%E5%88%B0github%E5%9B%BE%E5%BA%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="PicGo-Github-Typora实现笔记图片上传到github图床"><a href="#PicGo-Github-Typora实现笔记图片上传到github图床" class="headerlink" title="PicGo+Github+Typora实现笔记图片上传到github图床"></a>PicGo+Github+Typora实现笔记图片上传到github图床</h1><h2 id="GIthub新建仓库并获取Token"><a href="#GIthub新建仓库并获取Token" class="headerlink" title="GIthub新建仓库并获取Token"></a>GIthub新建仓库并获取Token</h2><p>首先创建一个公有库，因为若是私有库的话在外部是访问不到图片的</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210404000450.png"></p><span id="more"></span><p>点击用户里的设置</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210404000600.png"></p><p>点击开发者选项</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210404000643.png"></p><p>点击个人token</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210404000755.png"></p><p>点击生成新的token</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210404000836.png"></p><p>只需要选择repo选项即可</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210404000905.png"></p><p>将token保存下来，因为只有这一次机会可以复制，不要错过！！！</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210404000941.png"></p><h2 id="设置PicGo"><a href="#设置PicGo" class="headerlink" title="设置PicGo"></a>设置PicGo</h2><p>然后下载<a href="https://github.com/Molunerfinn/PicGo/releases">PicGo</a>，选择适合自己的版本即可</p><p>安装完成后设置Github图床</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210404001032.png"></p><p>然后就可以测试是否可以上传了，因为某些原因(你懂的)，直接上传可能会失败，可以配置代理，就不再赘述，自行摸索。</p><h2 id="配置Typora"><a href="#配置Typora" class="headerlink" title="配置Typora"></a>配置Typora</h2><p>打开偏好设置</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210404001441.png"></p><p>进行如下图所示的设置即可</p><p><img src="https://raw.githubusercontent.com/juhick/picJuhick/master/20210404001554.png"></p><p><del>但由于未知原因，我直接在Typora内插入时会失败，只能通过PicGo客户端上传，之后解决的话再修改</del></p><p>发现了是因为网的原因有的图片在本地删除了云端还保存着，将冗余图片删除即可</p>]]></content>
    
    
    
    <tags>
      
      <tag>个人博客</tag>
      
      <tag>图床</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
